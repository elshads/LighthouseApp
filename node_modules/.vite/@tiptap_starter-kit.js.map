{
  "version": 3,
  "sources": ["../@tiptap/extension-blockquote/src/blockquote.ts", "../@tiptap/extension-bold/src/bold.ts", "../@tiptap/extension-bullet-list/src/bullet-list.ts", "../@tiptap/extension-code/src/code.ts", "../@tiptap/extension-code-block/src/code-block.ts", "../@tiptap/extension-document/src/document.ts", "../prosemirror-dropcursor/src/dropcursor.js", "../@tiptap/extension-dropcursor/src/dropcursor.ts", "../prosemirror-gapcursor/src/gapcursor.js", "../prosemirror-gapcursor/src/index.js", "../@tiptap/extension-gapcursor/src/gapcursor.ts", "../@tiptap/extension-hard-break/src/hard-break.ts", "../@tiptap/extension-heading/src/heading.ts", "../rope-sequence/dist/index.es.js", "../prosemirror-history/src/history.js", "../@tiptap/extension-history/src/history.ts", "../@tiptap/extension-horizontal-rule/src/horizontal-rule.ts", "../@tiptap/extension-italic/src/italic.ts", "../@tiptap/extension-list-item/src/list-item.ts", "../@tiptap/extension-ordered-list/src/ordered-list.ts", "../@tiptap/extension-paragraph/src/paragraph.ts", "../@tiptap/extension-strike/src/strike.ts", "../@tiptap/extension-text/src/text.ts", "../@tiptap/starter-kit/src/starter-kit.ts", "dep:@tiptap_starter-kit"],
  "sourcesContent": ["import { Node, mergeAttributes, wrappingInputRule } from '@tiptap/core'\n\nexport interface BlockquoteOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    blockQuote: {\n      /**\n       * Set a blockquote node\n       */\n      setBlockquote: () => ReturnType,\n      /**\n       * Toggle a blockquote node\n       */\n      toggleBlockquote: () => ReturnType,\n      /**\n       * Unset a blockquote node\n       */\n      unsetBlockquote: () => ReturnType,\n    }\n  }\n}\n\nexport const inputRegex = /^\\s*>\\s$/\n\nexport const Blockquote = Node.create<BlockquoteOptions>({\n\n  name: 'blockquote',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'block+',\n\n  group: 'block',\n\n  defining: true,\n\n  parseHTML() {\n    return [\n      { tag: 'blockquote' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['blockquote', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setBlockquote: () => ({ commands }) => {\n        return commands.wrapIn(this.name)\n      },\n      toggleBlockquote: () => ({ commands }) => {\n        return commands.toggleWrap(this.name)\n      },\n      unsetBlockquote: () => ({ commands }) => {\n        return commands.lift(this.name)\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-b': () => this.editor.commands.toggleBlockquote(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import {\n  Mark,\n  markInputRule,\n  markPasteRule,\n  mergeAttributes,\n} from '@tiptap/core'\n\nexport interface BoldOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    bold: {\n      /**\n       * Set a bold mark\n       */\n      setBold: () => ReturnType,\n      /**\n       * Toggle a bold mark\n       */\n      toggleBold: () => ReturnType,\n      /**\n       * Unset a bold mark\n       */\n      unsetBold: () => ReturnType,\n    }\n  }\n}\n\nexport const starInputRegex = /(?:^|\\s)((?:\\*\\*)((?:[^*]+))(?:\\*\\*))$/\nexport const starPasteRegex = /(?:^|\\s)((?:\\*\\*)((?:[^*]+))(?:\\*\\*))/g\nexport const underscoreInputRegex = /(?:^|\\s)((?:__)((?:[^__]+))(?:__))$/\nexport const underscorePasteRegex = /(?:^|\\s)((?:__)((?:[^__]+))(?:__))/g\n\nexport const Bold = Mark.create<BoldOptions>({\n  name: 'bold',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'strong',\n      },\n      {\n        tag: 'b',\n        getAttrs: node => (node as HTMLElement).style.fontWeight !== 'normal' && null,\n      },\n      {\n        style: 'font-weight',\n        getAttrs: value => /^(bold(er)?|[5-9]\\d{2,})$/.test(value as string) && null,\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['strong', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setBold: () => ({ commands }) => {\n        return commands.setMark(this.name)\n      },\n      toggleBold: () => ({ commands }) => {\n        return commands.toggleMark(this.name)\n      },\n      unsetBold: () => ({ commands }) => {\n        return commands.unsetMark(this.name)\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-b': () => this.editor.commands.toggleBold(),\n      'Mod-B': () => this.editor.commands.toggleBold(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: starInputRegex,\n        type: this.type,\n      }),\n      markInputRule({\n        find: underscoreInputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: starPasteRegex,\n        type: this.type,\n      }),\n      markPasteRule({\n        find: underscorePasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Node, mergeAttributes, wrappingInputRule } from '@tiptap/core'\n\nexport interface BulletListOptions {\n  itemTypeName: string,\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    bulletList: {\n      /**\n       * Toggle a bullet list\n       */\n      toggleBulletList: () => ReturnType,\n    }\n  }\n}\n\nexport const inputRegex = /^\\s*([-+*])\\s$/\n\nexport const BulletList = Node.create<BulletListOptions>({\n  name: 'bulletList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  parseHTML() {\n    return [\n      { tag: 'ul' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      toggleBulletList: () => ({ commands }) => {\n        return commands.toggleList(this.name, this.options.itemTypeName)\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-8': () => this.editor.commands.toggleBulletList(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import {\n  Mark,\n  markInputRule,\n  markPasteRule,\n  mergeAttributes,\n} from '@tiptap/core'\n\nexport interface CodeOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    code: {\n      /**\n       * Set a code mark\n       */\n      setCode: () => ReturnType,\n      /**\n       * Toggle inline code\n       */\n      toggleCode: () => ReturnType,\n      /**\n       * Unset a code mark\n       */\n      unsetCode: () => ReturnType,\n    }\n  }\n}\n\nexport const inputRegex = /(?:^|\\s)((?:`)((?:[^`]+))(?:`))$/\nexport const pasteRegex = /(?:^|\\s)((?:`)((?:[^`]+))(?:`))/g\n\nexport const Code = Mark.create<CodeOptions>({\n  name: 'code',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  excludes: '_',\n\n  code: true,\n\n  parseHTML() {\n    return [\n      { tag: 'code' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['code', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setCode: () => ({ commands }) => {\n        return commands.setMark(this.name)\n      },\n      toggleCode: () => ({ commands }) => {\n        return commands.toggleMark(this.name)\n      },\n      unsetCode: () => ({ commands }) => {\n        return commands.unsetMark(this.name)\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-e': () => this.editor.commands.toggleCode(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: pasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Node, textblockTypeInputRule, mergeAttributes } from '@tiptap/core'\nimport { Plugin, PluginKey, TextSelection } from 'prosemirror-state'\n\nexport interface CodeBlockOptions {\n  /**\n   * Adds a prefix to language classes that are applied to code tags.\n   * Defaults to `'language-'`.\n   */\n  languageClassPrefix: string,\n  /**\n   * Define whether the node should be exited on triple enter.\n   * Defaults to `true`.\n   */\n  exitOnTripleEnter: boolean,\n  /**\n   * Define whether the node should be exited on arrow down if there is no node after it.\n   * Defaults to `true`.\n   */\n  exitOnArrowDown: boolean,\n  /**\n   * Custom HTML attributes that should be added to the rendered HTML tag.\n   */\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    codeBlock: {\n      /**\n       * Set a code block\n       */\n      setCodeBlock: (attributes?: { language: string }) => ReturnType,\n      /**\n       * Toggle a code block\n       */\n      toggleCodeBlock: (attributes?: { language: string }) => ReturnType,\n    }\n  }\n}\n\nexport const backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/\nexport const tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/\n\nexport const CodeBlock = Node.create<CodeBlockOptions>({\n  name: 'codeBlock',\n\n  addOptions() {\n    return {\n      languageClassPrefix: 'language-',\n      exitOnTripleEnter: true,\n      exitOnArrowDown: true,\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'text*',\n\n  marks: '',\n\n  group: 'block',\n\n  code: true,\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      language: {\n        default: null,\n        parseHTML: element => {\n          const { languageClassPrefix } = this.options\n          const classNames = [...element.firstElementChild?.classList || []]\n          const languages = classNames\n            .filter(className => className.startsWith(languageClassPrefix))\n            .map(className => className.replace(languageClassPrefix, ''))\n          const language = languages[0]\n\n          if (!language) {\n            return null\n          }\n\n          return language\n        },\n        rendered: false,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'pre',\n        preserveWhitespace: 'full',\n      },\n    ]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      'pre',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      [\n        'code',\n        {\n          class: node.attrs.language\n            ? this.options.languageClassPrefix + node.attrs.language\n            : null,\n        },\n        0,\n      ],\n    ]\n  },\n\n  addCommands() {\n    return {\n      setCodeBlock: attributes => ({ commands }) => {\n        return commands.setNode(this.name, attributes)\n      },\n      toggleCodeBlock: attributes => ({ commands }) => {\n        return commands.toggleNode(this.name, 'paragraph', attributes)\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),\n\n      // remove code block when at start of document or code block is empty\n      Backspace: () => {\n        const { empty, $anchor } = this.editor.state.selection\n        const isAtStart = $anchor.pos === 1\n\n        if (!empty || $anchor.parent.type.name !== this.name) {\n          return false\n        }\n\n        if (isAtStart || !$anchor.parent.textContent.length) {\n          return this.editor.commands.clearNodes()\n        }\n\n        return false\n      },\n\n      // exit node on triple enter\n      Enter: ({ editor }) => {\n        if (!this.options.exitOnTripleEnter) {\n          return false\n        }\n\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2\n        const endsWithDoubleNewline = $from.parent.textContent.endsWith('\\n\\n')\n\n        if (!isAtEnd || !endsWithDoubleNewline) {\n          return false\n        }\n\n        return editor\n          .chain()\n          .command(({ tr }) => {\n            tr.delete($from.pos - 2, $from.pos)\n\n            return true\n          })\n          .exitCode()\n          .run()\n      },\n\n      // exit node on arrow down\n      ArrowDown: ({ editor }) => {\n        if (!this.options.exitOnArrowDown) {\n          return false\n        }\n\n        const { state } = editor\n        const { selection, doc } = state\n        const { $from, empty } = selection\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2\n\n        if (!isAtEnd) {\n          return false\n        }\n\n        const after = $from.after()\n\n        if (after === undefined) {\n          return false\n        }\n\n        const nodeAfter = doc.nodeAt(after)\n\n        if (nodeAfter) {\n          return false\n        }\n\n        return editor.commands.exitCode()\n      },\n    }\n  },\n\n  addInputRules() {\n    return [\n      textblockTypeInputRule({\n        find: backtickInputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          language: match[1],\n        }),\n      }),\n      textblockTypeInputRule({\n        find: tildeInputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          language: match[1],\n        }),\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      // this plugin creates a code block for pasted content from VS Code\n      // we can also detect the copied code language\n      new Plugin({\n        key: new PluginKey('codeBlockVSCodeHandler'),\n        props: {\n          handlePaste: (view, event) => {\n            if (!event.clipboardData) {\n              return false\n            }\n\n            // don\u2019t create a new code block within code blocks\n            if (this.editor.isActive(this.type.name)) {\n              return false\n            }\n\n            const text = event.clipboardData.getData('text/plain')\n            const vscode = event.clipboardData.getData('vscode-editor-data')\n            const vscodeData = vscode\n              ? JSON.parse(vscode)\n              : undefined\n            const language = vscodeData?.mode\n\n            if (!text || !language) {\n              return false\n            }\n\n            const { tr } = view.state\n\n            // create an empty code block\n            tr.replaceSelectionWith(this.type.create({ language }))\n\n            // put cursor inside the newly created code block\n            tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))))\n\n            // add text to code block\n            // strip carriage return chars from text pasted as code\n            // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n            tr.insertText(text.replace(/\\r\\n?/g, '\\n'))\n\n            // store meta information\n            // this is useful for other plugins that depends on the paste event\n            // like the paste rule plugin\n            tr.setMeta('paste', true)\n\n            view.dispatch(tr)\n\n            return true\n          },\n        },\n      }),\n    ]\n  },\n})\n", "import { Node } from '@tiptap/core'\n\nexport const Document = Node.create({\n  name: 'doc',\n  topNode: true,\n  content: 'block+',\n})\n", "import {Plugin} from \"prosemirror-state\"\nimport {dropPoint} from \"prosemirror-transform\"\n\n// :: (options: ?Object) \u2192 Plugin\n// Create a plugin that, when added to a ProseMirror instance,\n// causes a decoration to show up at the drop position when something\n// is dragged over the editor.\n//\n// Nodes may add a `disableDropCursor` property to their spec to\n// control the showing of a drop cursor inside them. This may be a\n// boolean or a function, which will be called with a view and a\n// position, and should return a boolean.\n//\n//   options::- These options are supported:\n//\n//     color:: ?string\n//     The color of the cursor. Defaults to `black`.\n//\n//     width:: ?number\n//     The precise width of the cursor in pixels. Defaults to 1.\n//\n//     class:: ?string\n//     A CSS class name to add to the cursor element.\nexport function dropCursor(options = {}) {\n  return new Plugin({\n    view(editorView) { return new DropCursorView(editorView, options) }\n  })\n}\n\nclass DropCursorView {\n  constructor(editorView, options) {\n    this.editorView = editorView\n    this.width = options.width || 1\n    this.color = options.color || \"black\"\n    this.class = options.class\n    this.cursorPos = null\n    this.element = null\n    this.timeout = null\n\n    this.handlers = [\"dragover\", \"dragend\", \"drop\", \"dragleave\"].map(name => {\n      let handler = e => this[name](e)\n      editorView.dom.addEventListener(name, handler)\n      return {name, handler}\n    })\n  }\n\n  destroy() {\n    this.handlers.forEach(({name, handler}) => this.editorView.dom.removeEventListener(name, handler))\n  }\n\n  update(editorView, prevState) {\n    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {\n      if (this.cursorPos > editorView.state.doc.content.size) this.setCursor(null)\n      else this.updateOverlay()\n    }\n  }\n\n  setCursor(pos) {\n    if (pos == this.cursorPos) return\n    this.cursorPos = pos\n    if (pos == null) {\n      this.element.parentNode.removeChild(this.element)\n      this.element = null\n    } else {\n      this.updateOverlay()\n    }\n  }\n\n  updateOverlay() {\n    let $pos = this.editorView.state.doc.resolve(this.cursorPos), rect\n    if (!$pos.parent.inlineContent) {\n      let before = $pos.nodeBefore, after = $pos.nodeAfter\n      if (before || after) {\n        let nodeRect = this.editorView.nodeDOM(this.cursorPos - (before ?  before.nodeSize : 0)).getBoundingClientRect()\n        let top = before ? nodeRect.bottom : nodeRect.top\n        if (before && after)\n          top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2\n        rect = {left: nodeRect.left, right: nodeRect.right, top: top - this.width / 2, bottom: top + this.width / 2}\n      }\n    }\n    if (!rect) {\n      let coords = this.editorView.coordsAtPos(this.cursorPos)\n      rect = {left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom}\n    }\n\n    let parent = this.editorView.dom.offsetParent\n    if (!this.element) {\n      this.element = parent.appendChild(document.createElement(\"div\"))\n      if (this.class) this.element.className = this.class\n      this.element.style.cssText = \"position: absolute; z-index: 50; pointer-events: none; background-color: \" + this.color\n    }\n    let parentLeft, parentTop\n    if (!parent || parent == document.body && getComputedStyle(parent).position == \"static\") {\n      parentLeft = -pageXOffset\n      parentTop = -pageYOffset\n    } else {\n      let rect = parent.getBoundingClientRect()\n      parentLeft = rect.left - parent.scrollLeft\n      parentTop = rect.top - parent.scrollTop\n    }\n    this.element.style.left = (rect.left - parentLeft) + \"px\"\n    this.element.style.top = (rect.top - parentTop) + \"px\"\n    this.element.style.width = (rect.right - rect.left) + \"px\"\n    this.element.style.height = (rect.bottom - rect.top) + \"px\"\n  }\n\n  scheduleRemoval(timeout) {\n    clearTimeout(this.timeout)\n    this.timeout = setTimeout(() => this.setCursor(null), timeout)\n  }\n\n  dragover(event) {\n    if (!this.editorView.editable) return\n    let pos = this.editorView.posAtCoords({left: event.clientX, top: event.clientY})\n\n    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside)\n    let disableDropCursor = node && node.type.spec.disableDropCursor\n    let disabled = typeof disableDropCursor == \"function\" ? disableDropCursor(this.editorView, pos) : disableDropCursor\n\n    if (pos && !disabled) {\n      let target = pos.pos\n      if (this.editorView.dragging && this.editorView.dragging.slice) {\n        target = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice)\n        if (target == null) return this.setCursor(null)\n      }\n      this.setCursor(target)\n      this.scheduleRemoval(5000)\n    }\n  }\n\n  dragend() {\n    this.scheduleRemoval(20)\n  }\n\n  drop() {\n    this.scheduleRemoval(20)\n  }\n\n  dragleave(event) {\n    if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))\n      this.setCursor(null)\n  }\n}\n", "import { Extension } from '@tiptap/core'\nimport { dropCursor } from 'prosemirror-dropcursor'\n\nexport interface DropcursorOptions {\n  color: string | null,\n  width: number | null,\n  class: string | null,\n}\n\nexport const Dropcursor = Extension.create<DropcursorOptions>({\n  name: 'dropCursor',\n\n  addOptions() {\n    return {\n      color: 'currentColor',\n      width: 1,\n      class: null,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      dropCursor(this.options),\n    ]\n  },\n})\n", "import {Selection, NodeSelection} from \"prosemirror-state\"\nimport {Slice} from \"prosemirror-model\"\n\n// ::- Gap cursor selections are represented using this class. Its\n// `$anchor` and `$head` properties both point at the cursor position.\nexport class GapCursor extends Selection {\n  // :: (ResolvedPos)\n  // Create a gap cursor.\n  constructor($pos) {\n    super($pos, $pos)\n  }\n\n  map(doc, mapping) {\n    let $pos = doc.resolve(mapping.map(this.head))\n    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos)\n  }\n\n  content() { return Slice.empty }\n\n  eq(other) {\n    return other instanceof GapCursor && other.head == this.head\n  }\n\n  toJSON() {\n    return {type: \"gapcursor\", pos: this.head}\n  }\n\n  static fromJSON(doc, json) {\n    if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for GapCursor.fromJSON\")\n    return new GapCursor(doc.resolve(json.pos))\n  }\n\n  getBookmark() { return new GapBookmark(this.anchor) }\n\n  static valid($pos) {\n    let parent = $pos.parent\n    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) return false\n    let override = parent.type.spec.allowGapCursor\n    if (override != null) return override\n    let deflt = parent.contentMatchAt($pos.index()).defaultType\n    return deflt && deflt.isTextblock\n  }\n\n  static findFrom($pos, dir, mustMove) {\n    search: for (;;) {\n      if (!mustMove && GapCursor.valid($pos)) return $pos\n      let pos = $pos.pos, next = null\n      // Scan up from this position\n      for (let d = $pos.depth;; d--) {\n        let parent = $pos.node(d)\n        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1)\n          break\n        } else if (d == 0) {\n          return null\n        }\n        pos += dir\n        let $cur = $pos.doc.resolve(pos)\n        if (GapCursor.valid($cur)) return $cur\n      }\n\n      // And then down into the next node\n      for (;;) {\n        let inside = dir > 0 ? next.firstChild : next.lastChild\n        if (!inside) {\n          if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {\n            $pos = $pos.doc.resolve(pos + next.nodeSize * dir)\n            mustMove = false\n            continue search\n          }\n          break\n        }\n        next = inside\n        pos += dir\n        let $cur = $pos.doc.resolve(pos)\n        if (GapCursor.valid($cur)) return $cur\n      }\n\n      return null\n    }\n  }\n}\n\nGapCursor.prototype.visible = false\n\nSelection.jsonID(\"gapcursor\", GapCursor)\n\nclass GapBookmark {\n  constructor(pos) {\n    this.pos = pos\n  }\n  map(mapping) {\n    return new GapBookmark(mapping.map(this.pos))\n  }\n  resolve(doc) {\n    let $pos = doc.resolve(this.pos)\n    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos)\n  }\n}\n\nfunction closedBefore($pos) {\n  for (let d = $pos.depth; d >= 0; d--) {\n    let index = $pos.index(d), parent = $pos.node(d)\n    // At the start of this parent, look at next one\n    if (index == 0) {\n      if (parent.type.spec.isolating) return true\n      continue\n    }\n    // See if the node before (or its first ancestor) is closed\n    for (let before = parent.child(index - 1);; before = before.lastChild) {\n      if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating) return true\n      if (before.inlineContent) return false\n    }\n  }\n  // Hit start of document\n  return true\n}\n\nfunction closedAfter($pos) {\n  for (let d = $pos.depth; d >= 0; d--) {\n    let index = $pos.indexAfter(d), parent = $pos.node(d)\n    if (index == parent.childCount) {\n      if (parent.type.spec.isolating) return true\n      continue\n    }\n    for (let after = parent.child(index);; after = after.firstChild) {\n      if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating) return true\n      if (after.inlineContent) return false\n    }\n  }\n  return true\n}\n", "import {keydownHandler} from \"prosemirror-keymap\"\nimport {TextSelection, NodeSelection, Plugin} from \"prosemirror-state\"\nimport {Decoration, DecorationSet} from \"prosemirror-view\"\n\nimport {GapCursor} from \"./gapcursor\"\n\n// :: () \u2192 Plugin\n// Create a gap cursor plugin. When enabled, this will capture clicks\n// near and arrow-key-motion past places that don't have a normally\n// selectable position nearby, and create a gap cursor selection for\n// them. The cursor is drawn as an element with class\n// `ProseMirror-gapcursor`. You can either include\n// `style/gapcursor.css` from the package's directory or add your own\n// styles to make it visible.\nexport const gapCursor = function() {\n  return new Plugin({\n    props: {\n      decorations: drawGapCursor,\n\n      createSelectionBetween(_view, $anchor, $head) {\n        if ($anchor.pos == $head.pos && GapCursor.valid($head)) return new GapCursor($head)\n      },\n\n      handleClick,\n      handleKeyDown\n    }\n  })\n}\n\nexport {GapCursor}\n\nconst handleKeyDown = keydownHandler({\n  \"ArrowLeft\": arrow(\"horiz\", -1),\n  \"ArrowRight\": arrow(\"horiz\", 1),\n  \"ArrowUp\": arrow(\"vert\", -1),\n  \"ArrowDown\": arrow(\"vert\", 1)\n})\n\nfunction arrow(axis, dir) {\n  let dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\")\n  return function(state, dispatch, view) {\n    let sel = state.selection\n    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty\n    if (sel instanceof TextSelection) {\n      if (!view.endOfTextblock(dirStr) || $start.depth == 0) return false\n      mustMove = false\n      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before())\n    }\n    let $found = GapCursor.findFrom($start, dir, mustMove)\n    if (!$found) return false\n    if (dispatch) dispatch(state.tr.setSelection(new GapCursor($found)))\n    return true\n  }\n}\n\nfunction handleClick(view, pos, event) {\n  if (!view.editable) return false\n  let $pos = view.state.doc.resolve(pos)\n  if (!GapCursor.valid($pos)) return false\n  let {inside} = view.posAtCoords({left: event.clientX, top: event.clientY})\n  if (inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(inside))) return false\n  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)))\n  return true\n}\n\nfunction drawGapCursor(state) {\n  if (!(state.selection instanceof GapCursor)) return null\n  let node = document.createElement(\"div\")\n  node.className = \"ProseMirror-gapcursor\"\n  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, {key: \"gapcursor\"})])\n}\n", "import {\n  Extension,\n  callOrReturn,\n  getExtensionField,\n  ParentConfig,\n} from '@tiptap/core'\nimport { gapCursor } from 'prosemirror-gapcursor'\n\ndeclare module '@tiptap/core' {\n  interface NodeConfig<Options, Storage> {\n    /**\n     * Allow gap cursor\n     */\n    allowGapCursor?:\n      | boolean\n      | null\n      | ((this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        parent: ParentConfig<NodeConfig<Options>>['allowGapCursor'],\n      }) => boolean | null),\n  }\n}\n\nexport const Gapcursor = Extension.create({\n  name: 'gapCursor',\n\n  addProseMirrorPlugins() {\n    return [\n      gapCursor(),\n    ]\n  },\n\n  extendNodeSchema(extension) {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    return {\n      allowGapCursor: callOrReturn(getExtensionField(extension, 'allowGapCursor', context)) ?? null,\n    }\n  },\n})\n", "import { Node, mergeAttributes } from '@tiptap/core'\n\nexport interface HardBreakOptions {\n  keepMarks: boolean,\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    hardBreak: {\n      /**\n       * Add a hard break\n       */\n      setHardBreak: () => ReturnType,\n    }\n  }\n}\n\nexport const HardBreak = Node.create<HardBreakOptions>({\n  name: 'hardBreak',\n\n  addOptions() {\n    return {\n      keepMarks: true,\n      HTMLAttributes: {},\n    }\n  },\n\n  inline: true,\n\n  group: 'inline',\n\n  selectable: false,\n\n  parseHTML() {\n    return [\n      { tag: 'br' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['br', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  renderText() {\n    return '\\n'\n  },\n\n  addCommands() {\n    return {\n      setHardBreak: () => ({\n        commands,\n        chain,\n        state,\n        editor,\n      }) => {\n        return commands.first([\n          () => commands.exitCode(),\n          () => commands.command(() => {\n            const { selection, storedMarks } = state\n\n            if (selection.$from.parent.type.spec.isolating) {\n              return false\n            }\n\n            const { keepMarks } = this.options\n            const { splittableMarks } = editor.extensionManager\n            const marks = storedMarks\n              || (selection.$to.parentOffset && selection.$from.marks())\n\n            return chain()\n              .insertContent({ type: this.name })\n              .command(({ tr, dispatch }) => {\n                if (dispatch && marks && keepMarks) {\n                  const filteredMarks = marks\n                    .filter(mark => splittableMarks.includes(mark.type.name))\n\n                  tr.ensureMarks(filteredMarks)\n                }\n\n                return true\n              })\n              .run()\n          }),\n        ])\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Enter': () => this.editor.commands.setHardBreak(),\n      'Shift-Enter': () => this.editor.commands.setHardBreak(),\n    }\n  },\n})\n", "import { Node, mergeAttributes, textblockTypeInputRule } from '@tiptap/core'\n\nexport type Level = 1 | 2 | 3 | 4 | 5 | 6\n\nexport interface HeadingOptions {\n  levels: Level[],\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    heading: {\n      /**\n       * Set a heading node\n       */\n      setHeading: (attributes: { level: Level }) => ReturnType,\n      /**\n       * Toggle a heading node\n       */\n      toggleHeading: (attributes: { level: Level }) => ReturnType,\n    }\n  }\n}\n\nexport const Heading = Node.create<HeadingOptions>({\n  name: 'heading',\n\n  addOptions() {\n    return {\n      levels: [1, 2, 3, 4, 5, 6],\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'inline*',\n\n  group: 'block',\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      level: {\n        default: 1,\n        rendered: false,\n      },\n    }\n  },\n\n  parseHTML() {\n    return this.options.levels\n      .map((level: Level) => ({\n        tag: `h${level}`,\n        attrs: { level },\n      }))\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    const hasLevel = this.options.levels.includes(node.attrs.level)\n    const level = hasLevel\n      ? node.attrs.level\n      : this.options.levels[0]\n\n    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setHeading: attributes => ({ commands }) => {\n        if (!this.options.levels.includes(attributes.level)) {\n          return false\n        }\n\n        return commands.setNode(this.name, attributes)\n      },\n      toggleHeading: attributes => ({ commands }) => {\n        if (!this.options.levels.includes(attributes.level)) {\n          return false\n        }\n\n        return commands.toggleNode(this.name, 'paragraph', attributes)\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return this.options.levels.reduce((items, level) => ({\n      ...items,\n      ...{\n        [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level }),\n      },\n    }), {})\n  },\n\n  addInputRules() {\n    return this.options.levels.map(level => {\n      return textblockTypeInputRule({\n        find: new RegExp(`^(#{1,${level}})\\\\s$`),\n        type: this.type,\n        getAttributes: {\n          level,\n        },\n      })\n    })\n  },\n})\n", "var GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) \u2192 RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) \u2192 RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) \u2192 T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) \u2192 ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) \u2192 U, ?number, ?number) \u2192 [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) \u2192 RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nvar ropeSequence = RopeSequence;\n\nexport default ropeSequence;\n", "import RopeSequence from \"rope-sequence\"\nimport {Mapping} from \"prosemirror-transform\"\nimport {Plugin, PluginKey} from \"prosemirror-state\"\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' \u2014 a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n\n// Used to schedule history compression\nconst max_empty_items = 500\n\nclass Branch {\n  constructor(items, eventCount) {\n    this.items = items\n    this.eventCount = eventCount\n  }\n\n  // : (EditorState, bool) \u2192 ?{transform: Transform, selection: ?SelectionBookmark, remaining: Branch}\n  // Pop the latest event off the branch's history and apply it\n  // to a document transform.\n  popEvent(state, preserveItems) {\n    if (this.eventCount == 0) return null\n\n    let end = this.items.length\n    for (;; end--) {\n      let next = this.items.get(end - 1)\n      if (next.selection) { --end; break }\n    }\n\n    let remap, mapFrom\n    if (preserveItems) {\n      remap = this.remapping(end, this.items.length)\n      mapFrom = remap.maps.length\n    }\n    let transform = state.tr\n    let selection, remaining\n    let addAfter = [], addBefore = []\n\n    this.items.forEach((item, i) => {\n      if (!item.step) {\n        if (!remap) {\n          remap = this.remapping(end, i + 1)\n          mapFrom = remap.maps.length\n        }\n        mapFrom--\n        addBefore.push(item)\n        return\n      }\n\n      if (remap) {\n        addBefore.push(new Item(item.map))\n        let step = item.step.map(remap.slice(mapFrom)), map\n\n        if (step && transform.maybeStep(step).doc) {\n          map = transform.mapping.maps[transform.mapping.maps.length - 1]\n          addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length))\n        }\n        mapFrom--\n        if (map) remap.appendMap(map, mapFrom)\n      } else {\n        transform.maybeStep(item.step)\n      }\n\n      if (item.selection) {\n        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection\n        remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1)\n        return false\n      }\n    }, this.items.length, 0)\n\n    return {remaining, transform, selection}\n  }\n\n  // : (Transform, ?SelectionBookmark, Object) \u2192 Branch\n  // Create a new branch with the given transform added.\n  addTransform(transform, selection, histOptions, preserveItems) {\n    let newItems = [], eventCount = this.eventCount\n    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null\n\n    for (let i = 0; i < transform.steps.length; i++) {\n      let step = transform.steps[i].invert(transform.docs[i])\n      let item = new Item(transform.mapping.maps[i], step, selection), merged\n      if (merged = lastItem && lastItem.merge(item)) {\n        item = merged\n        if (i) newItems.pop()\n        else oldItems = oldItems.slice(0, oldItems.length - 1)\n      }\n      newItems.push(item)\n      if (selection) {\n        eventCount++\n        selection = null\n      }\n      if (!preserveItems) lastItem = item\n    }\n    let overflow = eventCount - histOptions.depth\n    if (overflow > DEPTH_OVERFLOW) {\n      oldItems = cutOffEvents(oldItems, overflow)\n      eventCount -= overflow\n    }\n    return new Branch(oldItems.append(newItems), eventCount)\n  }\n\n  remapping(from, to) {\n    let maps = new Mapping\n    this.items.forEach((item, i) => {\n      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n          ? maps.maps.length - item.mirrorOffset : null\n      maps.appendMap(item.map, mirrorPos)\n    }, from, to)\n    return maps\n  }\n\n  addMaps(array) {\n    if (this.eventCount == 0) return this\n    return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount)\n  }\n\n  // : (Transform, number)\n  // When the collab module receives remote changes, the history has\n  // to know about those, so that it can adjust the steps that were\n  // rebased on top of the remote changes, and include the position\n  // maps for the remote changes in its array of items.\n  rebased(rebasedTransform, rebasedCount) {\n    if (!this.eventCount) return this\n\n    let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount)\n\n    let mapping = rebasedTransform.mapping\n    let newUntil = rebasedTransform.steps.length\n    let eventCount = this.eventCount\n    this.items.forEach(item => { if (item.selection) eventCount-- }, start)\n\n    let iRebased = rebasedCount\n    this.items.forEach(item => {\n      let pos = mapping.getMirror(--iRebased)\n      if (pos == null) return\n      newUntil = Math.min(newUntil, pos)\n      let map = mapping.maps[pos]\n      if (item.step) {\n        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos])\n        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos))\n        if (selection) eventCount++\n        rebasedItems.push(new Item(map, step, selection))\n      } else {\n        rebasedItems.push(new Item(map))\n      }\n    }, start)\n\n    let newMaps = []\n    for (let i = rebasedCount; i < newUntil; i++)\n      newMaps.push(new Item(mapping.maps[i]))\n    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems)\n    let branch = new Branch(items, eventCount)\n\n    if (branch.emptyItemCount() > max_empty_items)\n      branch = branch.compress(this.items.length - rebasedItems.length)\n    return branch\n  }\n\n  emptyItemCount() {\n    let count = 0\n    this.items.forEach(item => { if (!item.step) count++ })\n    return count\n  }\n\n  // Compressing a branch means rewriting it to push the air (map-only\n  // items) out. During collaboration, these naturally accumulate\n  // because each remote change adds one. The `upto` argument is used\n  // to ensure that only the items below a given level are compressed,\n  // because `rebased` relies on a clean, untouched set of items in\n  // order to associate old items with rebased steps.\n  compress(upto = this.items.length) {\n    let remap = this.remapping(0, upto), mapFrom = remap.maps.length\n    let items = [], events = 0\n    this.items.forEach((item, i) => {\n      if (i >= upto) {\n        items.push(item)\n        if (item.selection) events++\n      } else if (item.step) {\n        let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap()\n        mapFrom--\n        if (map) remap.appendMap(map, mapFrom)\n        if (step) {\n          let selection = item.selection && item.selection.map(remap.slice(mapFrom))\n          if (selection) events++\n          let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1\n          if (merged = items.length && items[last].merge(newItem))\n            items[last] = merged\n          else\n            items.push(newItem)\n        }\n      } else if (item.map) {\n        mapFrom--\n      }\n    }, this.items.length, 0)\n    return new Branch(RopeSequence.from(items.reverse()), events)\n  }\n}\n\nBranch.empty = new Branch(RopeSequence.empty, 0)\n\nfunction cutOffEvents(items, n) {\n  let cutPoint\n  items.forEach((item, i) => {\n    if (item.selection && (n-- == 0)) {\n      cutPoint = i\n      return false\n    }\n  })\n  return items.slice(cutPoint)\n}\n\nclass Item {\n  constructor(map, step, selection, mirrorOffset) {\n    // The (forward) step map for this item.\n    this.map = map\n    // The inverted step\n    this.step = step\n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    this.selection = selection\n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    this.mirrorOffset = mirrorOffset\n  }\n\n  merge(other) {\n    if (this.step && other.step && !other.selection) {\n      let step = other.step.merge(this.step)\n      if (step) return new Item(step.getMap().invert(), step, this.selection)\n    }\n  }\n}\n\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nexport class HistoryState {\n  constructor(done, undone, prevRanges, prevTime) {\n    this.done = done\n    this.undone = undone\n    this.prevRanges = prevRanges\n    this.prevTime = prevTime\n  }\n}\n\nconst DEPTH_OVERFLOW = 20\n\n// : (HistoryState, EditorState, Transaction, Object)\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n  let historyTr = tr.getMeta(historyKey), rebased\n  if (historyTr) return historyTr.historyState\n\n  if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0)\n\n  let appended = tr.getMeta(\"appendedTransaction\")\n\n  if (tr.steps.length == 0) {\n    return history\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo)\n      return new HistoryState(history.done.addTransform(tr, null, options, mustPreserveItems(state)),\n                              history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime)\n    else\n      return new HistoryState(history.done, history.undone.addTransform(tr, null, options, mustPreserveItems(state)),\n                              null, history.prevTime)\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    // Group transforms that occur in quick succession into one event.\n    let newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay ||\n                                                          !isAdjacentTo(tr, history.prevRanges))\n    let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1])\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null,\n                                                      options, mustPreserveItems(state)),\n                            Branch.empty, prevRanges, tr.time)\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased),\n                            history.undone.rebased(tr, rebased),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps),\n                            history.undone.addMaps(tr.mapping.maps),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  }\n}\n\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges) return false\n  if (!transform.docChanged) return true\n  let adjacent = false\n  transform.mapping.maps[0].forEach((start, end) => {\n    for (let i = 0; i < prevRanges.length; i += 2)\n      if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n        adjacent = true\n  })\n  return adjacent\n}\n\nfunction rangesFor(map) {\n  let result = []\n  map.forEach((_from, _to, from, to) => result.push(from, to))\n  return result\n}\n\nfunction mapRanges(ranges, mapping) {\n  if (!ranges) return null\n  let result = []\n  for (let i = 0; i < ranges.length; i += 2) {\n    let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1)\n    if (from <= to) result.push(from, to)\n  }\n  return result\n}\n\n// : (HistoryState, EditorState, (tr: Transaction), bool)\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n  let preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config\n  let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems)\n  if (!pop) return\n\n  let selection = pop.selection.resolve(pop.transform.doc)\n  let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(),\n                                                                  histOptions, preserveItems)\n\n  let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0)\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {redo, historyState: newHist}).scrollIntoView())\n}\n\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n  let plugins = state.plugins\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false\n    cachedPreserveItemsPlugins = plugins\n    for (let i = 0; i < plugins.length; i++) if (plugins[i].spec.historyPreserveItems) {\n      cachedPreserveItems = true\n      break\n    }\n  }\n  return cachedPreserveItems\n}\n\n// :: (Transaction) \u2192 Transaction\n// Set a flag on the given transaction that will prevent further steps\n// from being appended to an existing history event (so that they\n// require a separate undo command to undo).\nexport function closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true)\n}\n\nconst historyKey = new PluginKey(\"history\")\nconst closeHistoryKey = new PluginKey(\"closeHistory\")\n\n// :: (?Object) \u2192 Plugin\n// Returns a plugin that enables the undo history for an editor. The\n// plugin will track undo and redo stacks, which can be used with the\n// [`undo`](#history.undo) and [`redo`](#history.redo) commands.\n//\n// You can set an `\"addToHistory\"` [metadata\n// property](#state.Transaction.setMeta) of `false` on a transaction\n// to prevent it from being rolled back by undo.\n//\n//   config::-\n//   Supports the following configuration options:\n//\n//     depth:: ?number\n//     The amount of history events that are collected before the\n//     oldest events are discarded. Defaults to 100.\n//\n//     newGroupDelay:: ?number\n//     The delay between changes after which a new group should be\n//     started. Defaults to 500 (milliseconds). Note that when changes\n//     aren't adjacent, a new group is always started.\nexport function history(config) {\n  config = {depth: config && config.depth || 100,\n            newGroupDelay: config && config.newGroupDelay || 500}\n  return new Plugin({\n    key: historyKey,\n\n    state: {\n      init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0)\n      },\n      apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config)\n      }\n    },\n\n    config,\n\n    props: {\n      handleDOMEvents: {\n        beforeinput(view, e) {\n          let handled = e.inputType == \"historyUndo\" ? undo(view.state, view.dispatch) :\n              e.inputType == \"historyRedo\" ? redo(view.state, view.dispatch) : false\n          if (handled) e.preventDefault()\n          return handled\n        }\n      }\n    }\n  })\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// A command function that undoes the last change, if any.\nexport function undo(state, dispatch) {\n  let hist = historyKey.getState(state)\n  if (!hist || hist.done.eventCount == 0) return false\n  if (dispatch) histTransaction(hist, state, dispatch, false)\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// A command function that redoes the last undone change, if any.\nexport function redo(state, dispatch) {\n  let hist = historyKey.getState(state)\n  if (!hist || hist.undone.eventCount == 0) return false\n  if (dispatch) histTransaction(hist, state, dispatch, true)\n  return true\n}\n\n// :: (EditorState) \u2192 number\n// The amount of undoable events available in a given state.\nexport function undoDepth(state) {\n  let hist = historyKey.getState(state)\n  return hist ? hist.done.eventCount : 0\n}\n\n// :: (EditorState) \u2192 number\n// The amount of redoable events available in a given editor state.\nexport function redoDepth(state) {\n  let hist = historyKey.getState(state)\n  return hist ? hist.undone.eventCount : 0\n}\n", "import { Extension } from '@tiptap/core'\nimport { history, undo, redo } from 'prosemirror-history'\n\nexport interface HistoryOptions {\n  depth: number,\n  newGroupDelay: number,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    history: {\n      /**\n       * Undo recent changes\n       */\n      undo: () => ReturnType,\n      /**\n       * Reapply reverted changes\n       */\n      redo: () => ReturnType,\n    }\n  }\n}\n\nexport const History = Extension.create<HistoryOptions>({\n  name: 'history',\n\n  addOptions() {\n    return {\n      depth: 100,\n      newGroupDelay: 500,\n    }\n  },\n\n  addCommands() {\n    return {\n      undo: () => ({ state, dispatch }) => {\n        return undo(state, dispatch)\n      },\n      redo: () => ({ state, dispatch }) => {\n        return redo(state, dispatch)\n      },\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      history(this.options),\n    ]\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-z': () => this.editor.commands.undo(),\n      'Mod-y': () => this.editor.commands.redo(),\n      'Shift-Mod-z': () => this.editor.commands.redo(),\n\n      // Russian keyboard layouts\n      'Mod-\u044F': () => this.editor.commands.undo(),\n      'Shift-Mod-\u044F': () => this.editor.commands.redo(),\n    }\n  },\n})\n", "import {\n  Node,\n  nodeInputRule,\n  mergeAttributes,\n} from '@tiptap/core'\nimport { TextSelection } from 'prosemirror-state'\n\nexport interface HorizontalRuleOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    horizontalRule: {\n      /**\n       * Add a horizontal rule\n       */\n      setHorizontalRule: () => ReturnType,\n    }\n  }\n}\n\nexport const HorizontalRule = Node.create<HorizontalRuleOptions>({\n  name: 'horizontalRule',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [\n      { tag: 'hr' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule: () => ({ chain }) => {\n        return chain()\n          .insertContent({ type: this.name })\n          // set cursor after horizontal rule\n          .command(({ tr, dispatch }) => {\n            if (dispatch) {\n              const { $to } = tr.selection\n              const posAfter = $to.end()\n\n              if ($to.nodeAfter) {\n                tr.setSelection(TextSelection.create(tr.doc, $to.pos))\n              } else {\n                // add node after horizontal rule if it\u2019s the end of the document\n                const node = $to.parent.type.contentMatch.defaultType?.create()\n\n                if (node) {\n                  tr.insert(posAfter, node)\n                  tr.setSelection(TextSelection.create(tr.doc, posAfter))\n                }\n              }\n\n              tr.scrollIntoView()\n            }\n\n            return true\n          })\n          .run()\n      },\n    }\n  },\n\n  addInputRules() {\n    return [\n      nodeInputRule({\n        find: /^(?:---|\u2014-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import {\n  Mark,\n  markInputRule,\n  markPasteRule,\n  mergeAttributes,\n} from '@tiptap/core'\n\nexport interface ItalicOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    italic: {\n      /**\n       * Set an italic mark\n       */\n      setItalic: () => ReturnType,\n      /**\n       * Toggle an italic mark\n       */\n      toggleItalic: () => ReturnType,\n      /**\n       * Unset an italic mark\n       */\n      unsetItalic: () => ReturnType,\n    }\n  }\n}\n\nexport const starInputRegex = /(?:^|\\s)((?:\\*)((?:[^*]+))(?:\\*))$/\nexport const starPasteRegex = /(?:^|\\s)((?:\\*)((?:[^*]+))(?:\\*))/g\nexport const underscoreInputRegex = /(?:^|\\s)((?:_)((?:[^_]+))(?:_))$/\nexport const underscorePasteRegex = /(?:^|\\s)((?:_)((?:[^_]+))(?:_))/g\n\nexport const Italic = Mark.create<ItalicOptions>({\n  name: 'italic',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'em',\n      },\n      {\n        tag: 'i',\n        getAttrs: node => (node as HTMLElement).style.fontStyle !== 'normal' && null,\n      },\n      {\n        style: 'font-style=italic',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['em', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setItalic: () => ({ commands }) => {\n        return commands.setMark(this.name)\n      },\n      toggleItalic: () => ({ commands }) => {\n        return commands.toggleMark(this.name)\n      },\n      unsetItalic: () => ({ commands }) => {\n        return commands.unsetMark(this.name)\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-i': () => this.editor.commands.toggleItalic(),\n      'Mod-I': () => this.editor.commands.toggleItalic(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: starInputRegex,\n        type: this.type,\n      }),\n      markInputRule({\n        find: underscoreInputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: starPasteRegex,\n        type: this.type,\n      }),\n      markPasteRule({\n        find: underscorePasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Node, mergeAttributes } from '@tiptap/core'\n\nexport interface ListItemOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\nexport const ListItem = Node.create<ListItemOptions>({\n  name: 'listItem',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'paragraph block*',\n\n  defining: true,\n\n  parseHTML() {\n    return [\n      {\n        tag: 'li',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['li', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n  },\n})\n", "import { Node, mergeAttributes, wrappingInputRule } from '@tiptap/core'\n\nexport interface OrderedListOptions {\n  itemTypeName: string,\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    orderedList: {\n      /**\n       * Toggle an ordered list\n       */\n      toggleOrderedList: () => ReturnType,\n    }\n  }\n}\n\nexport const inputRegex = /^(\\d+)\\.\\s$/\n\nexport const OrderedList = Node.create<OrderedListOptions>({\n  name: 'orderedList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: element => {\n          return element.hasAttribute('start')\n            ? parseInt(element.getAttribute('start') || '', 10)\n            : 1\n        },\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'ol',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const { start, ...attributesWithoutStart } = HTMLAttributes\n\n    return start === 1\n      ? ['ol', mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0]\n      : ['ol', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      toggleOrderedList: () => ({ commands }) => {\n        return commands.toggleList(this.name, this.options.itemTypeName)\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-7': () => this.editor.commands.toggleOrderedList(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n        getAttributes: match => ({ start: +match[1] }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n      }),\n    ]\n  },\n})\n", "import { Node, mergeAttributes } from '@tiptap/core'\n\nexport interface ParagraphOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    paragraph: {\n      /**\n       * Toggle a paragraph\n       */\n      setParagraph: () => ReturnType,\n    }\n  }\n}\n\nexport const Paragraph = Node.create<ParagraphOptions>({\n  name: 'paragraph',\n\n  priority: 1000,\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block',\n\n  content: 'inline*',\n\n  parseHTML() {\n    return [\n      { tag: 'p' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['p', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setParagraph: () => ({ commands }) => {\n        return commands.setNode(this.name)\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-0': () => this.editor.commands.setParagraph(),\n    }\n  },\n})\n", "import {\n  Mark,\n  markInputRule,\n  markPasteRule,\n  mergeAttributes,\n} from '@tiptap/core'\n\nexport interface StrikeOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    strike: {\n      /**\n       * Set a strike mark\n       */\n      setStrike: () => ReturnType,\n      /**\n       * Toggle a strike mark\n       */\n      toggleStrike: () => ReturnType,\n      /**\n       * Unset a strike mark\n       */\n      unsetStrike: () => ReturnType,\n    }\n  }\n}\n\nexport const inputRegex = /(?:^|\\s)((?:~~)((?:[^~]+))(?:~~))$/\nexport const pasteRegex = /(?:^|\\s)((?:~~)((?:[^~]+))(?:~~))/g\n\nexport const Strike = Mark.create<StrikeOptions>({\n  name: 'strike',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 's',\n      },\n      {\n        tag: 'del',\n      },\n      {\n        tag: 'strike',\n      },\n      {\n        style: 'text-decoration',\n        consuming: false,\n        getAttrs: style => ((style as string).includes('line-through') ? {} : false),\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['s', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setStrike: () => ({ commands }) => {\n        return commands.setMark(this.name)\n      },\n      toggleStrike: () => ({ commands }) => {\n        return commands.toggleMark(this.name)\n      },\n      unsetStrike: () => ({ commands }) => {\n        return commands.unsetMark(this.name)\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-x': () => this.editor.commands.toggleStrike(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: pasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Node } from '@tiptap/core'\n\nexport const Text = Node.create({\n  name: 'text',\n  group: 'inline',\n})\n", "import { Extension } from '@tiptap/core'\nimport Blockquote, { BlockquoteOptions } from '@tiptap/extension-blockquote'\nimport Bold, { BoldOptions } from '@tiptap/extension-bold'\nimport BulletList, { BulletListOptions } from '@tiptap/extension-bullet-list'\nimport Code, { CodeOptions } from '@tiptap/extension-code'\nimport CodeBlock, { CodeBlockOptions } from '@tiptap/extension-code-block'\nimport Document from '@tiptap/extension-document'\nimport Dropcursor, { DropcursorOptions } from '@tiptap/extension-dropcursor'\nimport Gapcursor from '@tiptap/extension-gapcursor'\nimport HardBreak, { HardBreakOptions } from '@tiptap/extension-hard-break'\nimport Heading, { HeadingOptions } from '@tiptap/extension-heading'\nimport History, { HistoryOptions } from '@tiptap/extension-history'\nimport HorizontalRule, { HorizontalRuleOptions } from '@tiptap/extension-horizontal-rule'\nimport Italic, { ItalicOptions } from '@tiptap/extension-italic'\nimport ListItem, { ListItemOptions } from '@tiptap/extension-list-item'\nimport OrderedList, { OrderedListOptions } from '@tiptap/extension-ordered-list'\nimport Paragraph, { ParagraphOptions } from '@tiptap/extension-paragraph'\nimport Strike, { StrikeOptions } from '@tiptap/extension-strike'\nimport Text from '@tiptap/extension-text'\n\nexport interface StarterKitOptions {\n  blockquote: Partial<BlockquoteOptions> | false,\n  bold: Partial<BoldOptions> | false,\n  bulletList: Partial<BulletListOptions> | false,\n  code: Partial<CodeOptions> | false,\n  codeBlock: Partial<CodeBlockOptions> | false,\n  document: false,\n  dropcursor: Partial<DropcursorOptions> | false,\n  gapcursor: false,\n  hardBreak: Partial<HardBreakOptions> | false,\n  heading: Partial<HeadingOptions> | false,\n  history: Partial<HistoryOptions> | false,\n  horizontalRule: Partial<HorizontalRuleOptions> | false,\n  italic: Partial<ItalicOptions> | false,\n  listItem: Partial<ListItemOptions> | false,\n  orderedList: Partial<OrderedListOptions> | false,\n  paragraph: Partial<ParagraphOptions> | false,\n  strike: Partial<StrikeOptions> | false,\n  text: false,\n}\n\nexport const StarterKit = Extension.create<StarterKitOptions>({\n  name: 'starterKit',\n\n  addExtensions() {\n    const extensions = []\n\n    if (this.options.blockquote !== false) {\n      extensions.push(Blockquote.configure(this.options?.blockquote))\n    }\n\n    if (this.options.bold !== false) {\n      extensions.push(Bold.configure(this.options?.bold))\n    }\n\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options?.bulletList))\n    }\n\n    if (this.options.code !== false) {\n      extensions.push(Code.configure(this.options?.code))\n    }\n\n    if (this.options.codeBlock !== false) {\n      extensions.push(CodeBlock.configure(this.options?.codeBlock))\n    }\n\n    if (this.options.document !== false) {\n      extensions.push(Document.configure(this.options?.document))\n    }\n\n    if (this.options.dropcursor !== false) {\n      extensions.push(Dropcursor.configure(this.options?.dropcursor))\n    }\n\n    if (this.options.gapcursor !== false) {\n      extensions.push(Gapcursor.configure(this.options?.gapcursor))\n    }\n\n    if (this.options.hardBreak !== false) {\n      extensions.push(HardBreak.configure(this.options?.hardBreak))\n    }\n\n    if (this.options.heading !== false) {\n      extensions.push(Heading.configure(this.options?.heading))\n    }\n\n    if (this.options.history !== false) {\n      extensions.push(History.configure(this.options?.history))\n    }\n\n    if (this.options.horizontalRule !== false) {\n      extensions.push(HorizontalRule.configure(this.options?.horizontalRule))\n    }\n\n    if (this.options.italic !== false) {\n      extensions.push(Italic.configure(this.options?.italic))\n    }\n\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options?.listItem))\n    }\n\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options?.orderedList))\n    }\n\n    if (this.options.paragraph !== false) {\n      extensions.push(Paragraph.configure(this.options?.paragraph))\n    }\n\n    if (this.options.strike !== false) {\n      extensions.push(Strike.configure(this.options?.strike))\n    }\n\n    if (this.options.text !== false) {\n      extensions.push(Text.configure(this.options?.text))\n    }\n\n    return extensions\n  },\n})\n", "import d from \"./node_modules/@tiptap/starter-kit/dist/tiptap-starter-kit.esm.js\";export default d;"],
  "mappings": "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",
  "names": []
}
