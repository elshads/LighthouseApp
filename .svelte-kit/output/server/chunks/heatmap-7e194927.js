import { c as create_ssr_component, a as compute_rest_props, b as spread, e as escape_object, k as each, d as escape, i as add_classes, v as validate_component, s as setContext, n as getContext, g as add_attribute } from "./index-167532fe.js";
import { w as writable } from "./HeaderSearch.svelte_svelte_type_style_lang-41e053f4.js";
import { C as ChevronRight16 } from "./ChevronRight16-1783b04e.js";
const SkeletonText = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let rows;
  let widthNum;
  let widthPx;
  let $$restProps = compute_rest_props($$props, ["lines", "heading", "paragraph", "width"]);
  let { lines: lines2 = 3 } = $$props;
  let { heading = false } = $$props;
  let { paragraph = false } = $$props;
  let { width = "100%" } = $$props;
  const RANDOM = [0.973, 0.153, 0.567];
  if ($$props.lines === void 0 && $$bindings.lines && lines2 !== void 0)
    $$bindings.lines(lines2);
  if ($$props.heading === void 0 && $$bindings.heading && heading !== void 0)
    $$bindings.heading(heading);
  if ($$props.paragraph === void 0 && $$bindings.paragraph && paragraph !== void 0)
    $$bindings.paragraph(paragraph);
  if ($$props.width === void 0 && $$bindings.width && width !== void 0)
    $$bindings.width(width);
  rows = [];
  widthNum = parseInt(width, 10);
  widthPx = width.includes("px");
  {
    if (paragraph) {
      for (let i = 0; i < lines2; i++) {
        const min2 = widthPx ? widthNum - 75 : 0;
        const max2 = widthPx ? widthNum : 75;
        const rand = Math.floor(RANDOM[i % 3] * (max2 - min2 + 1)) + min2 + "px";
        rows = [
          ...rows,
          {
            width: widthPx ? rand : `calc(${width} - ${rand})`
          }
        ];
      }
    }
  }
  return `
${paragraph ? `<div${spread([escape_object($$restProps)], {})}>${each(rows, ({ width: width2 }) => {
    return `<p style="${"width: " + escape(width2)}"${add_classes(("bx--skeleton__text " + (heading ? "bx--skeleton__heading" : "")).trim())}></p>`;
  })}</div>` : `<p${spread([
    escape_object($$restProps),
    {
      style: "width: " + escape(width) + ";" + escape($$restProps.style)
    }
  ], {
    classes: "bx--skeleton__text " + (heading ? "bx--skeleton__heading" : "")
  })}></p>`}`;
});
const AccordionSkeleton = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["count", "align", "size", "open"]);
  let { count: count2 = 4 } = $$props;
  let { align = "end" } = $$props;
  let { size = void 0 } = $$props;
  let { open = true } = $$props;
  if ($$props.count === void 0 && $$bindings.count && count2 !== void 0)
    $$bindings.count(count2);
  if ($$props.align === void 0 && $$bindings.align && align !== void 0)
    $$bindings.align(align);
  if ($$props.size === void 0 && $$bindings.size && size !== void 0)
    $$bindings.size(size);
  if ($$props.open === void 0 && $$bindings.open && open !== void 0)
    $$bindings.open(open);
  return `
<ul${spread([escape_object($$restProps)], {
    classes: "bx--skeleton bx--accordion " + (align === "start" ? "bx--accordion--start" : "") + " " + (align === "end" ? "bx--accordion--end" : "") + " " + (size === "sm" ? "bx--accordion--sm" : "") + " " + (size === "xl" ? "bx--accordion--xl" : "")
  })}>${open ? `<li${add_classes("bx--accordion__item bx--accordion__item--active".trim())}><span${add_classes("bx--accordion__heading".trim())}>${validate_component(ChevronRight16, "ChevronRight16").$$render($$result, { class: "bx--accordion__arrow" }, {}, {})}
        ${validate_component(SkeletonText, "SkeletonText").$$render($$result, { class: "bx--accordion__title" }, {}, {})}</span>
      <div class="${"bx--accordion__content"}">${validate_component(SkeletonText, "SkeletonText").$$render($$result, { width: "90%" }, {}, {})}
        ${validate_component(SkeletonText, "SkeletonText").$$render($$result, { width: "80%" }, {}, {})}
        ${validate_component(SkeletonText, "SkeletonText").$$render($$result, { width: "95%" }, {}, {})}</div></li>` : ``}
  ${each(Array.from({ length: open ? count2 - 1 : count2 }, (_, i) => i), (item) => {
    return `<li class="${"bx--accordion__item"}"><span class="${"bx--accordion__heading"}">${validate_component(ChevronRight16, "ChevronRight16").$$render($$result, { class: "bx--accordion__arrow" }, {}, {})}
        ${validate_component(SkeletonText, "SkeletonText").$$render($$result, { class: "bx--accordion__title" }, {}, {})}</span>
    </li>`;
  })}</ul>`;
});
const Accordion = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["align", "size", "disabled", "skeleton"]);
  let { align = "end" } = $$props;
  let { size = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { skeleton = false } = $$props;
  const disableItems = writable(disabled);
  setContext("Accordion", { disableItems });
  if ($$props.align === void 0 && $$bindings.align && align !== void 0)
    $$bindings.align(align);
  if ($$props.size === void 0 && $$bindings.size && size !== void 0)
    $$bindings.size(size);
  if ($$props.disabled === void 0 && $$bindings.disabled && disabled !== void 0)
    $$bindings.disabled(disabled);
  if ($$props.skeleton === void 0 && $$bindings.skeleton && skeleton !== void 0)
    $$bindings.skeleton(skeleton);
  {
    disableItems.set(disabled);
  }
  return `
${skeleton ? `${validate_component(AccordionSkeleton, "AccordionSkeleton").$$render($$result, Object.assign($$restProps, { align }, { size }), {}, {})}` : `<ul${spread([escape_object($$restProps)], {
    classes: "bx--accordion " + (align === "start" ? "bx--accordion--start" : "") + " " + (align === "end" ? "bx--accordion--end" : "") + " " + (size === "sm" ? "bx--accordion--sm" : "") + " " + (size === "xl" ? "bx--accordion--xl" : "")
  })}>${slots.default ? slots.default({}) : ``}</ul>`}`;
});
const AccordionItem = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["title", "open", "disabled", "iconDescription"]);
  let { title = "title" } = $$props;
  let { open = false } = $$props;
  let { disabled = false } = $$props;
  let { iconDescription = "Expand/Collapse" } = $$props;
  let initialDisabled = disabled;
  const ctx = getContext("Accordion");
  ctx.disableItems.subscribe((value2) => {
    if (!value2 && initialDisabled)
      return;
    disabled = value2;
  });
  if ($$props.title === void 0 && $$bindings.title && title !== void 0)
    $$bindings.title(title);
  if ($$props.open === void 0 && $$bindings.open && open !== void 0)
    $$bindings.open(open);
  if ($$props.disabled === void 0 && $$bindings.disabled && disabled !== void 0)
    $$bindings.disabled(disabled);
  if ($$props.iconDescription === void 0 && $$bindings.iconDescription && iconDescription !== void 0)
    $$bindings.iconDescription(iconDescription);
  return `
<li${spread([escape_object($$restProps)], {
    classes: "bx--accordion__item " + (open ? "bx--accordion__item--active" : "") + " " + (disabled ? "bx--accordion__item--disabled" : "") + "  "
  })}><button type="${"button"}"${add_attribute("title", iconDescription, 0)}${add_attribute("aria-expanded", open, 0)} ${disabled ? "disabled" : ""}${add_classes("bx--accordion__heading".trim())}>${validate_component(ChevronRight16, "ChevronRight16").$$render($$result, {
    class: "bx--accordion__arrow",
    "aria-label": iconDescription
  }, {}, {})}
    <div${add_classes("bx--accordion__title".trim())}>${slots.title ? slots.title({}) : `${escape(title)}`}</div></button>
  <div${add_classes("bx--accordion__content".trim())}>${slots.default ? slots.default({}) : ``}</div></li>`;
});
var Roles;
(function(Roles2) {
  Roles2["GRAPHICS_DOCUMENT"] = "graphics-document";
  Roles2["GRAPHICS_OBJECT"] = "graphics-object";
  Roles2["GRAPHICS_SYMBOL"] = "graphics-symbol";
  Roles2["GROUP"] = "group";
  Roles2["DOCUMENT"] = "document";
  Roles2["CHECKBOX"] = "checkbox";
  Roles2["BUTTON"] = "button";
  Roles2["MENU"] = "menu";
  Roles2["MENU_ITEM"] = "menuitem";
  Roles2["IMG"] = "img";
})(Roles || (Roles = {}));
var Chart$1;
(function(Chart2) {
  Chart2["RENDER_FINISHED"] = "render-finished";
  Chart2["RESIZE"] = "chart-resize";
  Chart2["MOUSEOVER"] = "chart-mouseover";
  Chart2["MOUSEOUT"] = "chart-mouseout";
})(Chart$1 || (Chart$1 = {}));
var Modal$2;
(function(Modal2) {
  Modal2["SHOW"] = "show-modal";
  Modal2["HIDE"] = "hide-modal";
})(Modal$2 || (Modal$2 = {}));
var Model;
(function(Model2) {
  Model2["UPDATE"] = "model-update";
})(Model || (Model = {}));
var Toolbar$1;
(function(Toolbar2) {
  Toolbar2["SHOW_OVERFLOW_MENU"] = "show-toolbar-overflow-menu";
  Toolbar2["HIDE_OVERFLOW_MENU"] = "hide-toolbar-overflow-menu";
  Toolbar2["BUTTON_CLICK"] = "toolbar-button-click";
})(Toolbar$1 || (Toolbar$1 = {}));
var ZoomBar$1;
(function(ZoomBar2) {
  ZoomBar2["UPDATE"] = "zoom-bar-update";
  ZoomBar2["SELECTION_START"] = "zoom-bar-selection-start";
  ZoomBar2["SELECTION_IN_PROGRESS"] = "zoom-bar-selection-in-progress";
  ZoomBar2["SELECTION_END"] = "zoom-bar-selection-end";
})(ZoomBar$1 || (ZoomBar$1 = {}));
var ZoomDomain;
(function(ZoomDomain2) {
  ZoomDomain2["CHANGE"] = "zoom-domain-change";
})(ZoomDomain || (ZoomDomain = {}));
var CanvasZoom$1;
(function(CanvasZoom2) {
  CanvasZoom2["CANVAS_ZOOM_IN"] = "canvas-zoom-in";
  CanvasZoom2["CANVAS_ZOOM_OUT"] = "canvas-zoom-out";
})(CanvasZoom$1 || (CanvasZoom$1 = {}));
var Axis$1;
(function(Axis2) {
  Axis2["LABEL_MOUSEOVER"] = "axis-label-mouseover";
  Axis2["LABEL_MOUSEMOVE"] = "axis-label-mousemove";
  Axis2["LABEL_CLICK"] = "axis-label-click";
  Axis2["LABEL_MOUSEOUT"] = "axis-label-mouseout";
  Axis2["LABEL_FOCUS"] = "axis-label-focus";
  Axis2["LABEL_BLUR"] = "axis-label-blur";
  Axis2["RENDER_COMPLETE"] = "axis-render-complete";
})(Axis$1 || (Axis$1 = {}));
var Area$1;
(function(Area2) {
  Area2["POINT_MOUSEOVER"] = "scatter-mouseover";
  Area2["POINT_MOUSEMOVE"] = "scatter-mousemove";
  Area2["POINT_CLICK"] = "scatter-click";
  Area2["POINT_MOUSEOUT"] = "scatter-mouseout";
})(Area$1 || (Area$1 = {}));
var WordCloud$1;
(function(WordCloud2) {
  WordCloud2["WORD_MOUSEOVER"] = "wordcloud-word-mouseover";
  WordCloud2["WORD_MOUSEMOVE"] = "wordcloud-word-mousemove";
  WordCloud2["WORD_CLICK"] = "wordcloud-word-click";
  WordCloud2["WORD_MOUSEOUT"] = "wordcloud-word-mouseout";
})(WordCloud$1 || (WordCloud$1 = {}));
var Pie$1;
(function(Pie2) {
  Pie2["SLICE_MOUSEOVER"] = "pie-slice-mouseover";
  Pie2["SLICE_MOUSEMOVE"] = "pie-slice-mousemove";
  Pie2["SLICE_CLICK"] = "pie-slice-click";
  Pie2["SLICE_MOUSEOUT"] = "pie-slice-mouseout";
})(Pie$1 || (Pie$1 = {}));
var Gauge$1;
(function(Gauge2) {
  Gauge2["ARC_MOUSEOVER"] = "gauge-arc-mouseover";
  Gauge2["ARC_MOUSEMOVE"] = "gauge-arc-mousemove";
  Gauge2["ARC_CLICK"] = "gauge-arc-click";
  Gauge2["ARC_MOUSEOUT"] = "gauge-arc-mouseout";
})(Gauge$1 || (Gauge$1 = {}));
var Bar$1;
(function(Bar2) {
  Bar2["BAR_MOUSEOVER"] = "bar-mouseover";
  Bar2["BAR_MOUSEMOVE"] = "bar-mousemove";
  Bar2["BAR_CLICK"] = "bar-click";
  Bar2["BAR_MOUSEOUT"] = "bar-mouseout";
})(Bar$1 || (Bar$1 = {}));
var Boxplot$1;
(function(Boxplot2) {
  Boxplot2["BOX_MOUSEOVER"] = "box-mouseover";
  Boxplot2["BOX_MOUSEMOVE"] = "box-mousemove";
  Boxplot2["BOX_CLICK"] = "box-click";
  Boxplot2["BOX_MOUSEOUT"] = "box-mouseout";
  Boxplot2["OUTLIER_MOUSEOVER"] = "outlier-mouseover";
  Boxplot2["OUTLIER_MOUSEMOVE"] = "outlier-mousemove";
  Boxplot2["OUTLIER_CLICK"] = "outlier-click";
  Boxplot2["OUTLIER_MOUSEOUT"] = "outlier-mouseout";
})(Boxplot$1 || (Boxplot$1 = {}));
var Scatter$1;
(function(Scatter2) {
  Scatter2["SCATTER_MOUSEOVER"] = "scatter-mouseover";
  Scatter2["SCATTER_MOUSEMOVE"] = "scatter-mousemove";
  Scatter2["SCATTER_CLICK"] = "scatter-click";
  Scatter2["SCATTER_MOUSEOUT"] = "scatter-mouseout";
})(Scatter$1 || (Scatter$1 = {}));
var Line$1;
(function(Line2) {
  Line2["POINT_MOUSEOVER"] = "scatter-mouseover";
  Line2["POINT_MOUSEMOVE"] = "scatter-mousemove";
  Line2["POINT_CLICK"] = "scatter-click";
  Line2["POINT_MOUSEOUT"] = "scatter-mouseout";
})(Line$1 || (Line$1 = {}));
var Radar$1;
(function(Radar2) {
  Radar2["X_AXIS_MOUSEOVER"] = "radar-x-axis-mouseover";
  Radar2["X_AXIS_MOUSEMOVE"] = "radar-x-axis-mousemove";
  Radar2["X_AXIS_CLICK"] = "radar-x-axis-click";
  Radar2["X_AXIS_MOUSEOUT"] = "radar-x-axis-mouseout";
})(Radar$1 || (Radar$1 = {}));
var Tree$1;
(function(Tree2) {
  Tree2["NODE_MOUSEOVER"] = "tree-node-mouseover";
  Tree2["NODE_CLICK"] = "tree-node-click";
  Tree2["NODE_MOUSEOUT"] = "tree-node-mouseout";
})(Tree$1 || (Tree$1 = {}));
var Treemap$1;
(function(Treemap2) {
  Treemap2["LEAF_MOUSEOVER"] = "leaf-mouseover";
  Treemap2["LEAF_MOUSEMOVE"] = "leaf-mousemove";
  Treemap2["LEAF_CLICK"] = "leaf-click";
  Treemap2["LEAF_MOUSEOUT"] = "leaf-mouseout";
})(Treemap$1 || (Treemap$1 = {}));
var Tooltip$1;
(function(Tooltip2) {
  Tooltip2["SHOW"] = "show-tooltip";
  Tooltip2["MOVE"] = "move-tooltip";
  Tooltip2["HIDE"] = "hide-tooltip";
})(Tooltip$1 || (Tooltip$1 = {}));
var Threshold$1;
(function(Threshold2) {
  Threshold2["SHOW"] = "show-threshold";
  Threshold2["HIDE"] = "hide-threshold";
})(Threshold$1 || (Threshold$1 = {}));
var Legend$1;
(function(Legend2) {
  Legend2["ITEM_HOVER"] = "legend-item-onhover";
  Legend2["ITEM_CLICK"] = "legend-item-onclick";
  Legend2["ITEM_MOUSEOUT"] = "legend-item-onmouseout";
  Legend2["ITEMS_UPDATE"] = "legend-items-update";
})(Legend$1 || (Legend$1 = {}));
var CirclePack$1;
(function(CirclePack2) {
  CirclePack2["CIRCLE_MOUSEOVER"] = "circle-leaf-mouseover";
  CirclePack2["CIRCLE_CLICK"] = "circle-leaf-click";
  CirclePack2["CIRCLE_MOUSEOUT"] = "circle-leaf-mouseout";
  CirclePack2["CIRCLE_MOUSEMOVE"] = "circle-leaf-mousemove";
})(CirclePack$1 || (CirclePack$1 = {}));
var Alluvial$1;
(function(Alluvial2) {
  Alluvial2["NODE_MOUSEOVER"] = "alluvial-node-mouseover";
  Alluvial2["NODE_CLICK"] = "alluvial-node-click";
  Alluvial2["NODE_MOUSEOUT"] = "alluvial-node-mouseout";
  Alluvial2["NODE_MOUSEMOVE"] = "alluvial-node-mousemove";
  Alluvial2["LINE_MOUSEOVER"] = "alluvial-line-mouseover";
  Alluvial2["LINE_CLICK"] = "alluvial-line-click";
  Alluvial2["LINE_MOUSEOUT"] = "alluvial-line-mouseout";
  Alluvial2["LINE_MOUSEMOVE"] = "alluvial-line-mousemove";
})(Alluvial$1 || (Alluvial$1 = {}));
var Meter$1;
(function(Meter2) {
  Meter2["METER_MOUSEOVER"] = "meter-mouseover";
  Meter2["METER_CLICK"] = "meter-click";
  Meter2["METER_MOUSEOUT"] = "meter-mouseout";
  Meter2["METER_MOUSEMOVE"] = "meter-mousemove";
})(Meter$1 || (Meter$1 = {}));
var Heatmap$1;
(function(Heatmap2) {
  Heatmap2["HEATMAP_MOUSEOVER"] = "heatmap-mouseover";
  Heatmap2["HEATMAP_CLICK"] = "heatmap-click";
  Heatmap2["HEATMAP_MOUSEOUT"] = "heatmap-mouseout";
  Heatmap2["HEATMAP_MOUSEMOVE"] = "hetmap-mousemove";
})(Heatmap$1 || (Heatmap$1 = {}));
var EventEnums = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get Chart() {
    return Chart$1;
  },
  get Modal() {
    return Modal$2;
  },
  get Model() {
    return Model;
  },
  get Toolbar() {
    return Toolbar$1;
  },
  get ZoomBar() {
    return ZoomBar$1;
  },
  get ZoomDomain() {
    return ZoomDomain;
  },
  get CanvasZoom() {
    return CanvasZoom$1;
  },
  get Axis() {
    return Axis$1;
  },
  get Area() {
    return Area$1;
  },
  get WordCloud() {
    return WordCloud$1;
  },
  get Pie() {
    return Pie$1;
  },
  get Gauge() {
    return Gauge$1;
  },
  get Bar() {
    return Bar$1;
  },
  get Boxplot() {
    return Boxplot$1;
  },
  get Scatter() {
    return Scatter$1;
  },
  get Line() {
    return Line$1;
  },
  get Radar() {
    return Radar$1;
  },
  get Tree() {
    return Tree$1;
  },
  get Treemap() {
    return Treemap$1;
  },
  get Tooltip() {
    return Tooltip$1;
  },
  get Threshold() {
    return Threshold$1;
  },
  get Legend() {
    return Legend$1;
  },
  get CirclePack() {
    return CirclePack$1;
  },
  get Alluvial() {
    return Alluvial$1;
  },
  get Meter() {
    return Meter$1;
  },
  get Heatmap() {
    return Heatmap$1;
  }
});
var Events$1 = EventEnums;
var RenderTypes;
(function(RenderTypes2) {
  RenderTypes2["HTML"] = "html";
  RenderTypes2["SVG"] = "svg";
})(RenderTypes || (RenderTypes = {}));
var ChartTheme;
(function(ChartTheme2) {
  ChartTheme2["DEFAULT"] = "default";
  ChartTheme2["G100"] = "g100";
  ChartTheme2["G90"] = "g90";
  ChartTheme2["G10"] = "g10";
})(ChartTheme || (ChartTheme = {}));
var ColorClassNameTypes;
(function(ColorClassNameTypes2) {
  ColorClassNameTypes2["BACKGROUND"] = "background";
  ColorClassNameTypes2["FILL"] = "fill";
  ColorClassNameTypes2["STROKE"] = "stroke";
  ColorClassNameTypes2["TOOLTIP"] = "tooltip";
})(ColorClassNameTypes || (ColorClassNameTypes = {}));
var AxisPositions;
(function(AxisPositions2) {
  AxisPositions2["LEFT"] = "left";
  AxisPositions2["RIGHT"] = "right";
  AxisPositions2["TOP"] = "top";
  AxisPositions2["BOTTOM"] = "bottom";
})(AxisPositions || (AxisPositions = {}));
var ZoomBarTypes;
(function(ZoomBarTypes2) {
  ZoomBarTypes2["GRAPH_VIEW"] = "graph_view";
  ZoomBarTypes2["SLIDER_VIEW"] = "slider_view";
})(ZoomBarTypes || (ZoomBarTypes = {}));
var TruncationTypes;
(function(TruncationTypes2) {
  TruncationTypes2["END_LINE"] = "end_line";
  TruncationTypes2["MID_LINE"] = "mid_line";
  TruncationTypes2["FRONT_LINE"] = "front_line";
  TruncationTypes2["NONE"] = "none";
})(TruncationTypes || (TruncationTypes = {}));
var CartesianOrientations;
(function(CartesianOrientations2) {
  CartesianOrientations2["VERTICAL"] = "vertical";
  CartesianOrientations2["HORIZONTAL"] = "horizontal";
})(CartesianOrientations || (CartesianOrientations = {}));
var ScaleTypes;
(function(ScaleTypes2) {
  ScaleTypes2["TIME"] = "time";
  ScaleTypes2["LINEAR"] = "linear";
  ScaleTypes2["LOG"] = "log";
  ScaleTypes2["LABELS"] = "labels";
  ScaleTypes2["LABELS_RATIO"] = "labels-ratio";
})(ScaleTypes || (ScaleTypes = {}));
var LegendPositions;
(function(LegendPositions2) {
  LegendPositions2["RIGHT"] = "right";
  LegendPositions2["LEFT"] = "left";
  LegendPositions2["TOP"] = "top";
  LegendPositions2["BOTTOM"] = "bottom";
})(LegendPositions || (LegendPositions = {}));
var Alignments;
(function(Alignments2) {
  Alignments2["LEFT"] = "left";
  Alignments2["CENTER"] = "center";
  Alignments2["RIGHT"] = "right";
})(Alignments || (Alignments = {}));
var LegendOrientations;
(function(LegendOrientations2) {
  LegendOrientations2["HORIZONTAL"] = "horizontal";
  LegendOrientations2["VERTICAL"] = "vertical";
})(LegendOrientations || (LegendOrientations = {}));
var TreeTypes;
(function(TreeTypes2) {
  TreeTypes2["TREE"] = "tree";
  TreeTypes2["DENDROGRAM"] = "dendrogram";
})(TreeTypes || (TreeTypes = {}));
var LayoutDirection;
(function(LayoutDirection2) {
  LayoutDirection2["ROW"] = "row";
  LayoutDirection2["COLUMN"] = "column";
  LayoutDirection2["ROW_REVERSE"] = "row-reverse";
  LayoutDirection2["COLUMN_REVERSE"] = "column-reverse";
})(LayoutDirection || (LayoutDirection = {}));
var LayoutGrowth;
(function(LayoutGrowth2) {
  LayoutGrowth2["FIXED"] = "fixed";
  LayoutGrowth2["PREFERRED"] = "preferred";
  LayoutGrowth2["STRETCH"] = "stretch";
})(LayoutGrowth || (LayoutGrowth = {}));
var LayoutAlignItems;
(function(LayoutAlignItems2) {
  LayoutAlignItems2["CENTER"] = "center";
})(LayoutAlignItems || (LayoutAlignItems = {}));
var CalloutDirections;
(function(CalloutDirections2) {
  CalloutDirections2["LEFT"] = "left";
  CalloutDirections2["RIGHT"] = "right";
})(CalloutDirections || (CalloutDirections = {}));
var Skeletons;
(function(Skeletons2) {
  Skeletons2["GRID"] = "grid";
  Skeletons2["VERT_OR_HORIZ"] = "vertOrHoriz";
  Skeletons2["PIE"] = "pie";
  Skeletons2["DONUT"] = "donut";
})(Skeletons || (Skeletons = {}));
var TextAnchor;
(function(TextAnchor2) {
  TextAnchor2["START"] = "start";
  TextAnchor2["MIDDLE"] = "middle";
  TextAnchor2["END"] = "end";
})(TextAnchor || (TextAnchor = {}));
var DominantBaseline;
(function(DominantBaseline2) {
  DominantBaseline2["BASELINE"] = "baseline";
  DominantBaseline2["MIDDLE"] = "middle";
  DominantBaseline2["HANGING"] = "hanging";
})(DominantBaseline || (DominantBaseline = {}));
var GaugeTypes;
(function(GaugeTypes2) {
  GaugeTypes2["SEMI"] = "semi";
  GaugeTypes2["FULL"] = "full";
})(GaugeTypes || (GaugeTypes = {}));
var ArrowDirections;
(function(ArrowDirections2) {
  ArrowDirections2["UP"] = "up";
  ArrowDirections2["DOWN"] = "down";
})(ArrowDirections || (ArrowDirections = {}));
var Statuses;
(function(Statuses2) {
  Statuses2["SUCCESS"] = "success";
  Statuses2["WARNING"] = "warning";
  Statuses2["DANGER"] = "danger";
})(Statuses || (Statuses = {}));
var TickRotations;
(function(TickRotations2) {
  TickRotations2["ALWAYS"] = "always";
  TickRotations2["AUTO"] = "auto";
  TickRotations2["NEVER"] = "never";
})(TickRotations || (TickRotations = {}));
var ChartTypes;
(function(ChartTypes2) {
  ChartTypes2["SCATTER"] = "scatter";
  ChartTypes2["LINE"] = "line";
  ChartTypes2["SIMPLE_BAR"] = "simple-bar";
  ChartTypes2["STACKED_BAR"] = "stacked-bar";
  ChartTypes2["GROUPED_BAR"] = "grouped-bar";
  ChartTypes2["AREA"] = "area";
  ChartTypes2["STACKED_AREA"] = "stacked-area";
})(ChartTypes || (ChartTypes = {}));
var ToolbarControlTypes;
(function(ToolbarControlTypes2) {
  ToolbarControlTypes2["EXPORT_CSV"] = "Export as CSV";
  ToolbarControlTypes2["EXPORT_PNG"] = "Export as PNG";
  ToolbarControlTypes2["EXPORT_JPG"] = "Export as JPG";
  ToolbarControlTypes2["ZOOM_IN"] = "Zoom in";
  ToolbarControlTypes2["ZOOM_OUT"] = "Zoom out";
  ToolbarControlTypes2["RESET_ZOOM"] = "Reset zoom";
  ToolbarControlTypes2["MAKE_FULLSCREEN"] = "Make fullscreen";
  ToolbarControlTypes2["SHOW_AS_DATATABLE"] = "Show as data-table";
  ToolbarControlTypes2["CUSTOM"] = "Custom";
})(ToolbarControlTypes || (ToolbarControlTypes = {}));
var AxisTitleOrientations;
(function(AxisTitleOrientations2) {
  AxisTitleOrientations2["LEFT"] = "left";
  AxisTitleOrientations2["RIGHT"] = "right";
})(AxisTitleOrientations || (AxisTitleOrientations = {}));
var LegendItemType;
(function(LegendItemType2) {
  LegendItemType2["CHECKBOX"] = "checkbox";
  LegendItemType2["RADIUS"] = "radius";
  LegendItemType2["AREA"] = "area";
  LegendItemType2["SIZE"] = "size";
  LegendItemType2["LINE"] = "line";
  LegendItemType2["QUARTILE"] = "quartile";
  LegendItemType2["ZOOM"] = "zoom";
})(LegendItemType || (LegendItemType = {}));
var ColorLegendType;
(function(ColorLegendType2) {
  ColorLegendType2["LINEAR"] = "linear";
  ColorLegendType2["QUANTIZE"] = "quantize";
})(ColorLegendType || (ColorLegendType = {}));
var DividerStatus;
(function(DividerStatus2) {
  DividerStatus2["ON"] = "on";
  DividerStatus2["AUTO"] = "auto";
  DividerStatus2["OFF"] = "off";
})(DividerStatus || (DividerStatus = {}));
var AxisFlavor;
(function(AxisFlavor2) {
  AxisFlavor2["DEFAULT"] = "default";
  AxisFlavor2["HOVERABLE"] = "hoverable";
})(AxisFlavor || (AxisFlavor = {}));
const linear$2 = (t) => +t;
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
var _a$2;
var area$1 = {
  opacity: {
    unselected: 0.05,
    selected: 0.4
  }
};
var axis$1 = {
  ticks: {
    number: 7,
    rotateIfSmallerThan: 30,
    verticalSpaceRatio: 2.5,
    horizontalSpaceRatio: 3.5
  },
  ratio: {
    reference: "value",
    compareTo: "marker"
  },
  paddingRatio: 0.1,
  hover: {
    rectanglePadding: 4
  }
};
var canvasZoomSettings = {
  duration: 1e3,
  ease: cubicInOut,
  zoomLevel: 3
};
var circlePack = {
  circles: {
    fillOpacity: 0.3,
    hover: {
      stroke: "#FFF"
    }
  },
  padding: {
    mainGroup: 4,
    children: 2
  },
  hierarchyLevel: 2
};
var color$1 = {
  pairingOptions: {
    "1-color": 4,
    "2-color": 5,
    "3-color": 5,
    "4-color": 3,
    "5-color": 2,
    "14-color": 1
  }
};
var boxplot = {
  circle: {
    radius: 4,
    opacity: {
      hovered: 1,
      default: 0.3
    }
  },
  box: {
    opacity: {
      hovered: 0.5,
      default: 0.3
    }
  },
  strokeWidth: {
    default: 1,
    thicker: 2
  }
};
var histogram = {
  defaultBins: 10
};
var legend$1 = {
  items: {
    status: {
      ACTIVE: 1,
      DISABLED: 0
    },
    horizontalSpace: 12,
    verticalSpace: 24,
    textYOffset: 8,
    spaceAfter: 4
  },
  checkbox: {
    radius: 6.5
  },
  radius: {
    iconData: [
      { cx: 7, cy: 7, r: 6.5 },
      { cx: 7, cy: 10, r: 3.5 }
    ],
    fill: null,
    stroke: "#8c8c8c"
  },
  line: {
    yPosition: 6,
    width: 24,
    strokeWidth: 1.4,
    fill: null,
    stroke: "#999999"
  },
  area: {
    width: 24,
    height: 14,
    fill: "#6f6f6f",
    stroke: null
  },
  size: {
    iconData: [
      { width: 23, height: 12 },
      { width: 13, height: 6 }
    ],
    fill: null,
    stroke: "#8D8D8D"
  },
  quartile: {
    iconData: [
      { x: 0, y: 0, width: 24, height: 13 },
      { x: 11, y: 4, width: 1, height: 4 }
    ]
  },
  zoom: {
    iconData: [{ x: 0, y: 0, width: 12, height: 12 }],
    color: "#8D8D8D"
  },
  color: {
    barWidth: 300,
    barHeight: 8,
    axisYTranslation: 10
  }
};
var lines = {
  opacity: {
    unselected: 0.3,
    selected: 1
  },
  weight: {
    selected: 2,
    unselected: 1
  }
};
var meter = {
  statusBar: {
    paddingRight: 5
  },
  status: {
    indicatorSize: 16,
    paddingLeft: 15
  },
  total: {
    paddingLeft: 36,
    paddingRight: 24
  },
  height: {
    default: 8,
    proportional: 16
  },
  dividerWidth: 2
};
var pie$1 = {
  radiusOffset: -15,
  innerRadius: 2,
  padAngle: 7e-3,
  hoverArc: {
    outerRadiusOffset: 3
  },
  xOffset: 30,
  yOffset: 20,
  yOffsetCallout: 10,
  callout: {
    minSliceDegree: 5,
    offsetX: 15,
    offsetY: 12,
    horizontalLineLength: 8,
    textMargin: 2
  }
};
var radar = {
  opacity: {
    unselected: 0.1,
    selected: 0.3
  },
  xLabelPadding: 10,
  yLabelPadding: 8,
  yTicksNumber: 4,
  minRange: 10,
  xAxisRectHeight: 50,
  dotsRadius: 5
};
var alluvial = {
  nodeWidth: 4,
  nodeHoveredWidth: 8,
  minNodePadding: 24,
  opacity: {
    unfocus: 0.3,
    default: 0.8,
    selected: 1
  }
};
var heatmap = {
  minCellDividerDimension: 16,
  chartPadding: 0.5
};
var spacers = {
  default: {
    size: 24
  }
};
var tooltips = {
  horizontalOffset: 10
};
var transitions = {
  default: {
    duration: 300
  },
  pie_slice_mouseover: {
    duration: 100
  },
  pie_chart_titles: {
    duration: 375
  },
  graph_element_mouseover_fill_update: {
    duration: 100
  },
  graph_element_mouseout_fill_update: {
    duration: 100
  }
};
var toolbar = {
  buttonSize: 32,
  iconSize: 20,
  height: 32,
  spacerHeight: 10,
  iconPadding: 6
};
var zoomBar = {
  height: (_a$2 = {}, _a$2[ZoomBarTypes.GRAPH_VIEW] = 32, _a$2[ZoomBarTypes.SLIDER_VIEW] = 10, _a$2),
  spacerHeight: 8,
  handleWidth: 5,
  handleBarWidth: 1,
  handleBarHeight: 12
};
var defaultLegendAdditionalItems = [
  {
    type: LegendItemType.RADIUS,
    name: "Radius"
  },
  {
    type: LegendItemType.AREA,
    name: "Poor area"
  },
  {
    type: LegendItemType.AREA,
    name: "Satisfactory area"
  },
  {
    type: LegendItemType.AREA,
    name: "Great area"
  },
  {
    type: LegendItemType.QUARTILE,
    name: "Quartiles"
  }
];
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$1 = freeGlobal$1 || freeSelf || Function("return this")();
var root$2 = root$1;
var Symbol$1 = root$2.Symbol;
var Symbol$2 = Symbol$1;
var objectProto$h = Object.prototype;
var hasOwnProperty$e = objectProto$h.hasOwnProperty;
var nativeObjectToString$1 = objectProto$h.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value2) {
  var isOwn = hasOwnProperty$e.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
  try {
    value2[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$1] = tag;
    } else {
      delete value2[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$g = Object.prototype;
var nativeObjectToString = objectProto$g.toString;
function objectToString(value2) {
  return nativeObjectToString.call(value2);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
}
function isObjectLike(value2) {
  return value2 != null && typeof value2 == "object";
}
var symbolTag$3 = "[object Symbol]";
function isSymbol(value2) {
  return typeof value2 == "symbol" || isObjectLike(value2) && baseGetTag(value2) == symbolTag$3;
}
function arrayMap(array2, iteratee) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array2[index2], index2, array2);
  }
  return result;
}
var isArray = Array.isArray;
var isArray$1 = isArray;
var INFINITY$3 = 1 / 0;
var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
function baseToString(value2) {
  if (typeof value2 == "string") {
    return value2;
  }
  if (isArray$1(value2)) {
    return arrayMap(value2, baseToString) + "";
  }
  if (isSymbol(value2)) {
    return symbolToString ? symbolToString.call(value2) : "";
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -INFINITY$3 ? "-0" : result;
}
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
function isObject(value2) {
  var type2 = typeof value2;
  return value2 != null && (type2 == "object" || type2 == "function");
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value2) {
  if (typeof value2 == "number") {
    return value2;
  }
  if (isSymbol(value2)) {
    return NAN;
  }
  if (isObject(value2)) {
    var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
    value2 = isObject(other) ? other + "" : other;
  }
  if (typeof value2 != "string") {
    return value2 === 0 ? value2 : +value2;
  }
  value2 = baseTrim(value2);
  var isBinary = reIsBinary.test(value2);
  return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
}
function identity$6(value2) {
  return value2;
}
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(value2) {
  if (!isObject(value2)) {
    return false;
  }
  var tag = baseGetTag(value2);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$2["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$f = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$d = objectProto$f.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$d).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value2) {
  if (!isObject(value2) || isMasked(value2)) {
    return false;
  }
  var pattern = isFunction(value2) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value2));
}
function getValue(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
function getNative(object2, key) {
  var value2 = getValue(object2, key);
  return baseIsNative(value2) ? value2 : void 0;
}
var WeakMap$1 = getNative(root$2, "WeakMap");
var WeakMap$2 = WeakMap$1;
var objectCreate = Object.create;
var baseCreate = function() {
  function object2() {
  }
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object2.prototype = proto;
    var result = new object2();
    object2.prototype = void 0;
    return result;
  };
}();
var baseCreate$1 = baseCreate;
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
function noop$3() {
}
function copyArray(source, array2) {
  var index2 = -1, length = source.length;
  array2 || (array2 = Array(length));
  while (++index2 < length) {
    array2[index2] = source[index2];
  }
  return array2;
}
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
function constant$8(value2) {
  return function() {
    return value2;
  };
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty$1 = defineProperty;
var baseSetToString = !defineProperty$1 ? identity$6 : function(func, string) {
  return defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant$8(string),
    "writable": true
  });
};
var baseSetToString$1 = baseSetToString;
var setToString = shortOut(baseSetToString$1);
var setToString$1 = setToString;
function arrayEach(array2, iteratee) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (iteratee(array2[index2], index2, array2) === false) {
      break;
    }
  }
  return array2;
}
function baseFindIndex(array2, predicate, fromIndex, fromRight) {
  var length = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length) {
    if (predicate(array2[index2], index2, array2)) {
      return index2;
    }
  }
  return -1;
}
function baseIsNaN(value2) {
  return value2 !== value2;
}
function strictIndexOf(array2, value2, fromIndex) {
  var index2 = fromIndex - 1, length = array2.length;
  while (++index2 < length) {
    if (array2[index2] === value2) {
      return index2;
    }
  }
  return -1;
}
function baseIndexOf(array2, value2, fromIndex) {
  return value2 === value2 ? strictIndexOf(array2, value2, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
}
function arrayIncludes(array2, value2) {
  var length = array2 == null ? 0 : array2.length;
  return !!length && baseIndexOf(array2, value2, 0) > -1;
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value2, length) {
  var type2 = typeof value2;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
}
function baseAssignValue(object2, key, value2) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object2, key, {
      "configurable": true,
      "enumerable": true,
      "value": value2,
      "writable": true
    });
  } else {
    object2[key] = value2;
  }
}
function eq(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var objectProto$e = Object.prototype;
var hasOwnProperty$c = objectProto$e.hasOwnProperty;
function assignValue(object2, key, value2) {
  var objValue = object2[key];
  if (!(hasOwnProperty$c.call(object2, key) && eq(objValue, value2)) || value2 === void 0 && !(key in object2)) {
    baseAssignValue(object2, key, value2);
  }
}
function copyObject(source, props, object2, customizer) {
  var isNew = !object2;
  object2 || (object2 = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object2, key, newValue);
    } else {
      assignValue(object2, key, newValue);
    }
  }
  return object2;
}
var nativeMax$1 = Math.max;
function overRest(func, start2, transform) {
  start2 = nativeMax$1(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax$1(args.length - start2, 0), array2 = Array(length);
    while (++index2 < length) {
      array2[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform(array2);
    return apply(func, this, otherArgs);
  };
}
function baseRest(func, start2) {
  return setToString$1(overRest(func, start2, identity$6), func + "");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
}
function isArrayLike(value2) {
  return value2 != null && isLength(value2.length) && !isFunction(value2);
}
function isIterateeCall(value2, index2, object2) {
  if (!isObject(object2)) {
    return false;
  }
  var type2 = typeof index2;
  if (type2 == "number" ? isArrayLike(object2) && isIndex(index2, object2.length) : type2 == "string" && index2 in object2) {
    return eq(object2[index2], value2);
  }
  return false;
}
function createAssigner(assigner) {
  return baseRest(function(object2, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object2 = Object(object2);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object2, source, index2, customizer);
      }
    }
    return object2;
  });
}
var objectProto$d = Object.prototype;
function isPrototype(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$d;
  return value2 === proto;
}
function baseTimes(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$3 = "[object Arguments]";
function baseIsArguments(value2) {
  return isObjectLike(value2) && baseGetTag(value2) == argsTag$3;
}
var objectProto$c = Object.prototype;
var hasOwnProperty$b = objectProto$c.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$c.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value2) {
  return isObjectLike(value2) && hasOwnProperty$b.call(value2, "callee") && !propertyIsEnumerable$1.call(value2, "callee");
};
var isArguments$1 = isArguments;
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$1 = moduleExports$2 ? root$2.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var isBuffer$1 = isBuffer;
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$6 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$6 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$6] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$6] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray(value2) {
  return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
}
function baseUnary(func) {
  return function(value2) {
    return func(value2);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$1 = isTypedArray;
var objectProto$b = Object.prototype;
var hasOwnProperty$a = objectProto$b.hasOwnProperty;
function arrayLikeKeys(value2, inherited) {
  var isArr = isArray$1(value2), isArg = !isArr && isArguments$1(value2), isBuff = !isArr && !isArg && isBuffer$1(value2), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length = result.length;
  for (var key in value2) {
    if ((inherited || hasOwnProperty$a.call(value2, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var nativeKeys$1 = nativeKeys;
var objectProto$a = Object.prototype;
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
function baseKeys(object2) {
  if (!isPrototype(object2)) {
    return nativeKeys$1(object2);
  }
  var result = [];
  for (var key in Object(object2)) {
    if (hasOwnProperty$9.call(object2, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys(object2) {
  return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
}
function nativeKeysIn(object2) {
  var result = [];
  if (object2 != null) {
    for (var key in Object(object2)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
function baseKeysIn(object2) {
  if (!isObject(object2)) {
    return nativeKeysIn(object2);
  }
  var isProto = isPrototype(object2), result = [];
  for (var key in object2) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$8.call(object2, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object2) {
  return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value2, object2) {
  if (isArray$1(value2)) {
    return false;
  }
  var type2 = typeof value2;
  if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value2 == null || isSymbol(value2)) {
    return true;
  }
  return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object2 != null && value2 in Object(object2);
}
var nativeCreate = getNative(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$7.call(data, key) ? data[key] : void 0;
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$6.call(data, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value2) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$1 && value2 === void 0 ? HASH_UNDEFINED$1 : value2;
  return this;
}
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value2) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value2]);
  } else {
    data[index2][1] = value2;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root$2, "Map");
var Map$2 = Map$1;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value2) {
  var type2 = typeof value2;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value2 !== "__proto__" : value2 === null;
}
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value2) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value2);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match2, number3, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match2);
  });
  return result;
});
var stringToPath$1 = stringToPath;
function toString(value2) {
  return value2 == null ? "" : baseToString(value2);
}
function castPath(value2, object2) {
  if (isArray$1(value2)) {
    return value2;
  }
  return isKey(value2, object2) ? [value2] : stringToPath$1(toString(value2));
}
var INFINITY$2 = 1 / 0;
function toKey(value2) {
  if (typeof value2 == "string" || isSymbol(value2)) {
    return value2;
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -INFINITY$2 ? "-0" : result;
}
function baseGet(object2, path2) {
  path2 = castPath(path2, object2);
  var index2 = 0, length = path2.length;
  while (object2 != null && index2 < length) {
    object2 = object2[toKey(path2[index2++])];
  }
  return index2 && index2 == length ? object2 : void 0;
}
function get$3(object2, path2, defaultValue) {
  var result = object2 == null ? void 0 : baseGet(object2, path2);
  return result === void 0 ? defaultValue : result;
}
function arrayPush(array2, values) {
  var index2 = -1, length = values.length, offset = array2.length;
  while (++index2 < length) {
    array2[offset + index2] = values[index2];
  }
  return array2;
}
var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
function isFlattenable(value2) {
  return isArray$1(value2) || isArguments$1(value2) || !!(spreadableSymbol && value2 && value2[spreadableSymbol]);
}
function baseFlatten(array2, depth, predicate, isStrict, result) {
  var index2 = -1, length = array2.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length) {
    var value2 = array2[index2];
    if (depth > 0 && predicate(value2)) {
      if (depth > 1) {
        baseFlatten(value2, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value2);
      }
    } else if (!isStrict) {
      result[result.length] = value2;
    }
  }
  return result;
}
function flatten$1(array2) {
  var length = array2 == null ? 0 : array2.length;
  return length ? baseFlatten(array2, 1) : [];
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;
var objectTag$3 = "[object Object]";
var funcProto = Function.prototype, objectProto$6 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject(value2) {
  if (!isObjectLike(value2) || baseGetTag(value2) != objectTag$3) {
    return false;
  }
  var proto = getPrototype$1(value2);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$5.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
function baseSlice(array2, start2, end) {
  var index2 = -1, length = array2.length;
  if (start2 < 0) {
    start2 = -start2 > length ? 0 : length + start2;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start2 > end ? 0 : end - start2 >>> 0;
  start2 >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array2[index2 + start2];
  }
  return result;
}
function castSlice(array2, start2, end) {
  var length = array2.length;
  end = end === void 0 ? length : end;
  return !start2 && end >= length ? array2 : baseSlice(array2, start2, end);
}
var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f";
var rsZWJ$2 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
function asciiToArray(string) {
  return string.split("");
}
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange$1 + "]", rsCombo$2 = "[" + rsComboRange$2 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d";
var reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
function stringToArray(string) {
  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
}
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);
    var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var upperFirst = createCaseFirst("toUpperCase");
var upperFirst$1 = upperFirst;
function capitalize(string) {
  return upperFirst$1(toString(string).toLowerCase());
}
function arrayReduce(array2, iteratee, accumulator, initAccum) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  if (initAccum && length) {
    accumulator = array2[++index2];
  }
  while (++index2 < length) {
    accumulator = iteratee(accumulator, array2[index2], index2, array2);
  }
  return accumulator;
}
function basePropertyOf(object2) {
  return function(key) {
    return object2 == null ? void 0 : object2[key];
  };
}
var deburredLetters = {
  "\xC0": "A",
  "\xC1": "A",
  "\xC2": "A",
  "\xC3": "A",
  "\xC4": "A",
  "\xC5": "A",
  "\xE0": "a",
  "\xE1": "a",
  "\xE2": "a",
  "\xE3": "a",
  "\xE4": "a",
  "\xE5": "a",
  "\xC7": "C",
  "\xE7": "c",
  "\xD0": "D",
  "\xF0": "d",
  "\xC8": "E",
  "\xC9": "E",
  "\xCA": "E",
  "\xCB": "E",
  "\xE8": "e",
  "\xE9": "e",
  "\xEA": "e",
  "\xEB": "e",
  "\xCC": "I",
  "\xCD": "I",
  "\xCE": "I",
  "\xCF": "I",
  "\xEC": "i",
  "\xED": "i",
  "\xEE": "i",
  "\xEF": "i",
  "\xD1": "N",
  "\xF1": "n",
  "\xD2": "O",
  "\xD3": "O",
  "\xD4": "O",
  "\xD5": "O",
  "\xD6": "O",
  "\xD8": "O",
  "\xF2": "o",
  "\xF3": "o",
  "\xF4": "o",
  "\xF5": "o",
  "\xF6": "o",
  "\xF8": "o",
  "\xD9": "U",
  "\xDA": "U",
  "\xDB": "U",
  "\xDC": "U",
  "\xF9": "u",
  "\xFA": "u",
  "\xFB": "u",
  "\xFC": "u",
  "\xDD": "Y",
  "\xFD": "y",
  "\xFF": "y",
  "\xC6": "Ae",
  "\xE6": "ae",
  "\xDE": "Th",
  "\xFE": "th",
  "\xDF": "ss",
  "\u0100": "A",
  "\u0102": "A",
  "\u0104": "A",
  "\u0101": "a",
  "\u0103": "a",
  "\u0105": "a",
  "\u0106": "C",
  "\u0108": "C",
  "\u010A": "C",
  "\u010C": "C",
  "\u0107": "c",
  "\u0109": "c",
  "\u010B": "c",
  "\u010D": "c",
  "\u010E": "D",
  "\u0110": "D",
  "\u010F": "d",
  "\u0111": "d",
  "\u0112": "E",
  "\u0114": "E",
  "\u0116": "E",
  "\u0118": "E",
  "\u011A": "E",
  "\u0113": "e",
  "\u0115": "e",
  "\u0117": "e",
  "\u0119": "e",
  "\u011B": "e",
  "\u011C": "G",
  "\u011E": "G",
  "\u0120": "G",
  "\u0122": "G",
  "\u011D": "g",
  "\u011F": "g",
  "\u0121": "g",
  "\u0123": "g",
  "\u0124": "H",
  "\u0126": "H",
  "\u0125": "h",
  "\u0127": "h",
  "\u0128": "I",
  "\u012A": "I",
  "\u012C": "I",
  "\u012E": "I",
  "\u0130": "I",
  "\u0129": "i",
  "\u012B": "i",
  "\u012D": "i",
  "\u012F": "i",
  "\u0131": "i",
  "\u0134": "J",
  "\u0135": "j",
  "\u0136": "K",
  "\u0137": "k",
  "\u0138": "k",
  "\u0139": "L",
  "\u013B": "L",
  "\u013D": "L",
  "\u013F": "L",
  "\u0141": "L",
  "\u013A": "l",
  "\u013C": "l",
  "\u013E": "l",
  "\u0140": "l",
  "\u0142": "l",
  "\u0143": "N",
  "\u0145": "N",
  "\u0147": "N",
  "\u014A": "N",
  "\u0144": "n",
  "\u0146": "n",
  "\u0148": "n",
  "\u014B": "n",
  "\u014C": "O",
  "\u014E": "O",
  "\u0150": "O",
  "\u014D": "o",
  "\u014F": "o",
  "\u0151": "o",
  "\u0154": "R",
  "\u0156": "R",
  "\u0158": "R",
  "\u0155": "r",
  "\u0157": "r",
  "\u0159": "r",
  "\u015A": "S",
  "\u015C": "S",
  "\u015E": "S",
  "\u0160": "S",
  "\u015B": "s",
  "\u015D": "s",
  "\u015F": "s",
  "\u0161": "s",
  "\u0162": "T",
  "\u0164": "T",
  "\u0166": "T",
  "\u0163": "t",
  "\u0165": "t",
  "\u0167": "t",
  "\u0168": "U",
  "\u016A": "U",
  "\u016C": "U",
  "\u016E": "U",
  "\u0170": "U",
  "\u0172": "U",
  "\u0169": "u",
  "\u016B": "u",
  "\u016D": "u",
  "\u016F": "u",
  "\u0171": "u",
  "\u0173": "u",
  "\u0174": "W",
  "\u0175": "w",
  "\u0176": "Y",
  "\u0177": "y",
  "\u0178": "Y",
  "\u0179": "Z",
  "\u017B": "Z",
  "\u017D": "Z",
  "\u017A": "z",
  "\u017C": "z",
  "\u017E": "z",
  "\u0132": "IJ",
  "\u0133": "ij",
  "\u0152": "Oe",
  "\u0153": "oe",
  "\u0149": "'n",
  "\u017F": "s"
};
var deburrLetter = basePropertyOf(deburredLetters);
var deburrLetter$1 = deburrLetter;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsCombo$1 = "[" + rsComboRange$1 + "]";
var reComboMark = RegExp(rsCombo$1, "g");
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter$1).replace(reComboMark, "");
}
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos$1 = "['\u2019]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}
var rsApos = "['\u2019]";
var reApos = RegExp(rsApos, "g");
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
  };
}
var camelCase = createCompounder(function(result, word, index2) {
  word = word.toLowerCase();
  return result + (index2 ? capitalize(word) : word);
});
var lodashCamelCase = camelCase;
function baseClamp(number3, lower2, upper) {
  if (number3 === number3) {
    if (upper !== void 0) {
      number3 = number3 <= upper ? number3 : upper;
    }
    if (lower2 !== void 0) {
      number3 = number3 >= lower2 ? number3 : lower2;
    }
  }
  return number3;
}
function clamp(number3, lower2, upper) {
  if (upper === void 0) {
    upper = lower2;
    lower2 = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower2 !== void 0) {
    lower2 = toNumber(lower2);
    lower2 = lower2 === lower2 ? lower2 : 0;
  }
  return baseClamp(toNumber(number3), lower2, upper);
}
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet(key, value2) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key, value2]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value2);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function baseAssign(object2, source) {
  return object2 && copyObject(source, keys(source), object2);
}
function baseAssignIn(object2, source) {
  return object2 && copyObject(source, keysIn(source), object2);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root$2.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
function arrayFilter(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value2 = array2[index2];
    if (predicate(value2, index2, array2)) {
      result[resIndex++] = value2;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$5 = Object.prototype;
var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object2) {
  if (object2 == null) {
    return [];
  }
  object2 = Object(object2);
  return arrayFilter(nativeGetSymbols$1(object2), function(symbol) {
    return propertyIsEnumerable.call(object2, symbol);
  });
};
var getSymbols$1 = getSymbols;
function copySymbols(source, object2) {
  return copyObject(source, getSymbols$1(source), object2);
}
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
  var result = [];
  while (object2) {
    arrayPush(result, getSymbols$1(object2));
    object2 = getPrototype$1(object2);
  }
  return result;
};
var getSymbolsIn$1 = getSymbolsIn;
function copySymbolsIn(source, object2) {
  return copyObject(source, getSymbolsIn$1(source), object2);
}
function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
  var result = keysFunc(object2);
  return isArray$1(object2) ? result : arrayPush(result, symbolsFunc(object2));
}
function getAllKeys(object2) {
  return baseGetAllKeys(object2, keys, getSymbols$1);
}
function getAllKeysIn(object2) {
  return baseGetAllKeys(object2, keysIn, getSymbolsIn$1);
}
var DataView$1 = getNative(root$2, "DataView");
var DataView$2 = DataView$1;
var Promise$1 = getNative(root$2, "Promise");
var Promise$2 = Promise$1;
var Set$1 = getNative(root$2, "Set");
var Set$2 = Set$1;
var mapTag$5 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$5 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$3 = "[object DataView]";
var dataViewCtorString = toSource(DataView$2), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
var getTag = baseGetTag;
if (DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$3 || Map$2 && getTag(new Map$2()) != mapTag$5 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$5 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
  getTag = function(value2) {
    var result = baseGetTag(value2), Ctor = result == objectTag$2 ? value2.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$3;
        case mapCtorString:
          return mapTag$5;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$5;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var getTag$1 = getTag;
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function initCloneArray(array2) {
  var length = array2.length, result = new array2.constructor(length);
  if (length && typeof array2[0] == "string" && hasOwnProperty$4.call(array2, "index")) {
    result.index = array2.index;
    result.input = array2.input;
  }
  return result;
}
var Uint8Array$1 = root$2.Uint8Array;
var Uint8Array$2 = Uint8Array$1;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(object2, tag, isDeep) {
  var Ctor = object2.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object2);
    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object2);
    case dataViewTag$2:
      return cloneDataView(object2, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object2, isDeep);
    case mapTag$4:
      return new Ctor();
    case numberTag$2:
    case stringTag$2:
      return new Ctor(object2);
    case regexpTag$2:
      return cloneRegExp(object2);
    case setTag$4:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object2);
  }
}
function initCloneObject(object2) {
  return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate$1(getPrototype$1(object2)) : {};
}
var mapTag$3 = "[object Map]";
function baseIsMap(value2) {
  return isObjectLike(value2) && getTag$1(value2) == mapTag$3;
}
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
var isMap$1 = isMap;
var setTag$3 = "[object Set]";
function baseIsSet(value2) {
  return isObjectLike(value2) && getTag$1(value2) == setTag$3;
}
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet$1 = isSet;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$2] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$2] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone(value2, bitmask, customizer, key, object2, stack2) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result = object2 ? customizer(value2, key, object2, stack2) : customizer(value2);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject(value2)) {
    return value2;
  }
  var isArr = isArray$1(value2);
  if (isArr) {
    result = initCloneArray(value2);
    if (!isDeep) {
      return copyArray(value2, result);
    }
  } else {
    var tag = getTag$1(value2), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value2)) {
      return cloneBuffer(value2, isDeep);
    }
    if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object2) {
      result = isFlat || isFunc ? {} : initCloneObject(value2);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value2, baseAssignIn(result, value2)) : copySymbols(value2, baseAssign(result, value2));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object2 ? value2 : {};
      }
      result = initCloneByTag(value2, tag, isDeep);
    }
  }
  stack2 || (stack2 = new Stack());
  var stacked = stack2.get(value2);
  if (stacked) {
    return stacked;
  }
  stack2.set(value2, result);
  if (isSet$1(value2)) {
    value2.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack2));
    });
  } else if (isMap$1(value2)) {
    value2.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value2, stack2));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? void 0 : keysFunc(value2);
  arrayEach(props || value2, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value2[key2];
    }
    assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value2, stack2));
  });
  return result;
}
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value2) {
  return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value2) {
  this.__data__.set(value2, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value2) {
  return this.__data__.has(value2);
}
function SetCache(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (predicate(array2[index2], index2, array2)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache, key) {
  return cache.has(key);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array2, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array2.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack2.get(array2);
  var othStacked = stack2.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array2;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack2.set(array2, other);
  stack2.set(other, array2);
  while (++index2 < arrLength) {
    var arrValue = array2[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack2) : customizer(arrValue, othValue, index2, array2, other, stack2);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
      result = false;
      break;
    }
  }
  stack2["delete"](array2);
  stack2["delete"](other);
  return result;
}
function mapToArray(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value2, key) {
    result[++index2] = [key, value2];
  });
  return result;
}
function setToArray(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value2) {
    result[++index2] = value2;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag$1 = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack2) {
  switch (tag) {
    case dataViewTag:
      if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
        return false;
      }
      object2 = object2.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object2), new Uint8Array$2(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object2, +other);
    case errorTag:
      return object2.name == other.name && object2.message == other.message;
    case regexpTag:
    case stringTag:
      return object2 == other + "";
    case mapTag$1:
      var convert = mapToArray;
    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object2.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack2.get(object2);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack2.set(object2, other);
      var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack2);
      stack2["delete"](object2);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object2) == symbolValueOf.call(other);
      }
  }
  return false;
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function equalObjects(object2, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$3.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack2.get(object2);
  var othStacked = stack2.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object2;
  }
  var result = true;
  stack2.set(object2, other);
  stack2.set(other, object2);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object2[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack2) : customizer(objValue, othValue, key, object2, other, stack2);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object2.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack2["delete"](object2);
  stack2["delete"](other);
  return result;
}
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack2) {
  var objIsArr = isArray$1(object2), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag$1(object2), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object2)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack2 || (stack2 = new Stack());
    return objIsArr || isTypedArray$1(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack2);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$2.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
      stack2 || (stack2 = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack2 || (stack2 = new Stack());
  return equalObjects(object2, other, bitmask, customizer, equalFunc, stack2);
}
function baseIsEqual(value2, other, bitmask, customizer, stack2) {
  if (value2 === other) {
    return true;
  }
  if (value2 == null || other == null || !isObjectLike(value2) && !isObjectLike(other)) {
    return value2 !== value2 && other !== other;
  }
  return baseIsEqualDeep(value2, other, bitmask, customizer, baseIsEqual, stack2);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object2, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object2 == null) {
    return !length;
  }
  object2 = Object(object2);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object2[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object2)) {
        return false;
      }
    } else {
      var stack2 = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object2, source, stack2);
      }
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value2) {
  return value2 === value2 && !isObject(value2);
}
function getMatchData(object2) {
  var result = keys(object2), length = result.length;
  while (length--) {
    var key = result[length], value2 = object2[key];
    result[length] = [key, value2, isStrictComparable(value2)];
  }
  return result;
}
function matchesStrictComparable(key, srcValue) {
  return function(object2) {
    if (object2 == null) {
      return false;
    }
    return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
  };
}
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object2) {
    return object2 === source || baseIsMatch(object2, source, matchData);
  };
}
function baseHasIn(object2, key) {
  return object2 != null && key in Object(object2);
}
function hasPath(object2, path2, hasFunc) {
  path2 = castPath(path2, object2);
  var index2 = -1, length = path2.length, result = false;
  while (++index2 < length) {
    var key = toKey(path2[index2]);
    if (!(result = object2 != null && hasFunc(object2, key))) {
      break;
    }
    object2 = object2[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object2 == null ? 0 : object2.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object2) || isArguments$1(object2));
}
function hasIn(object2, path2) {
  return object2 != null && hasPath(object2, path2, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path2, srcValue) {
  if (isKey(path2) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path2), srcValue);
  }
  return function(object2) {
    var objValue = get$3(object2, path2);
    return objValue === void 0 && objValue === srcValue ? hasIn(object2, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(key) {
  return function(object2) {
    return object2 == null ? void 0 : object2[key];
  };
}
function basePropertyDeep(path2) {
  return function(object2) {
    return baseGet(object2, path2);
  };
}
function property(path2) {
  return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
}
function baseIteratee(value2) {
  if (typeof value2 == "function") {
    return value2;
  }
  if (value2 == null) {
    return identity$6;
  }
  if (typeof value2 == "object") {
    return isArray$1(value2) ? baseMatchesProperty(value2[0], value2[1]) : baseMatches(value2);
  }
  return property(value2);
}
function arrayAggregator(array2, setter, iteratee, accumulator) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    var value2 = array2[index2];
    setter(accumulator, value2, iteratee(value2), array2);
  }
  return accumulator;
}
function createBaseFor(fromRight) {
  return function(object2, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object2;
  };
}
var baseFor = createBaseFor();
var baseFor$1 = baseFor;
function baseForOwn(object2, iteratee) {
  return object2 && baseFor$1(object2, iteratee, keys);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach = createBaseEach(baseForOwn);
var baseEach$1 = baseEach;
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach$1(collection, function(value2, key, collection2) {
    setter(accumulator, value2, iteratee(value2), collection2);
  });
  return accumulator;
}
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray$1(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee(iteratee), accumulator);
  };
}
var now$1 = function() {
  return root$2.Date.now();
};
var now$2 = now$1;
var FUNC_ERROR_TEXT = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
function debounce(func, wait, options2) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options2)) {
    leading = !!options2.leading;
    maxing = "maxWait" in options2;
    maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options2 ? !!options2.trailing : trailing;
  }
  function invokeFunc(time2) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time2;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time2) {
    lastInvokeTime = time2;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time2) : result;
  }
  function remainingWait(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time2 = now$2();
    if (shouldInvoke(time2)) {
      return trailingEdge(time2);
    }
    timerId = setTimeout(timerExpired, remainingWait(time2));
  }
  function trailingEdge(time2) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time2);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$2());
  }
  function debounced() {
    var time2 = now$2(), isInvoking = shouldInvoke(time2);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time2;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function assignMergeValue(object2, key, value2) {
  if (value2 !== void 0 && !eq(object2[key], value2) || value2 === void 0 && !(key in object2)) {
    baseAssignValue(object2, key, value2);
  }
}
function isArrayLikeObject(value2) {
  return isObjectLike(value2) && isArrayLike(value2);
}
function safeGet(object2, key) {
  if (key === "constructor" && typeof object2[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object2[key];
}
function toPlainObject(value2) {
  return copyObject(value2, keysIn(value2));
}
function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack2) {
  var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
  if (stacked) {
    assignMergeValue(object2, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack2) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$1(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$1(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
      newValue = objValue;
      if (isArguments$1(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack2.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
    stack2["delete"](srcValue);
  }
  assignMergeValue(object2, key, newValue);
}
function baseMerge(object2, source, srcIndex, customizer, stack2) {
  if (object2 === source) {
    return;
  }
  baseFor$1(source, function(srcValue, key) {
    stack2 || (stack2 = new Stack());
    if (isObject(srcValue)) {
      baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack2);
    } else {
      var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack2) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object2, key, newValue);
    }
  }, keysIn);
}
function arrayIncludesWith(array2, value2, comparator) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (comparator(value2, array2[index2])) {
      return true;
    }
  }
  return false;
}
function last(array2) {
  var length = array2 == null ? 0 : array2.length;
  return length ? array2[length - 1] : void 0;
}
function baseMap(collection, iteratee) {
  var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach$1(collection, function(value2, key, collection2) {
    result[++index2] = iteratee(value2, key, collection2);
  });
  return result;
}
function map$1(collection, iteratee) {
  var func = isArray$1(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee));
}
var INFINITY$1 = 1 / 0;
function flatMapDeep(collection, iteratee) {
  return baseFlatten(map$1(collection, iteratee), INFINITY$1);
}
function fromPairs(pairs) {
  var index2 = -1, length = pairs == null ? 0 : pairs.length, result = {};
  while (++index2 < length) {
    var pair = pairs[index2];
    result[pair[0]] = pair[1];
  }
  return result;
}
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
var groupBy = createAggregator(function(result, value2, key) {
  if (hasOwnProperty$1.call(result, key)) {
    result[key].push(value2);
  } else {
    baseAssignValue(result, key, [value2]);
  }
});
var lodashGroupBy = groupBy;
var mapTag = "[object Map]", setTag = "[object Set]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function isEmpty(value2) {
  if (value2 == null) {
    return true;
  }
  if (isArrayLike(value2) && (isArray$1(value2) || typeof value2 == "string" || typeof value2.splice == "function" || isBuffer$1(value2) || isTypedArray$1(value2) || isArguments$1(value2))) {
    return !value2.length;
  }
  var tag = getTag$1(value2);
  if (tag == mapTag || tag == setTag) {
    return !value2.size;
  }
  if (isPrototype(value2)) {
    return !baseKeys(value2).length;
  }
  for (var key in value2) {
    if (hasOwnProperty.call(value2, key)) {
      return false;
    }
  }
  return true;
}
function isEqual(value2, other) {
  return baseIsEqual(value2, other);
}
var kebabCase = createCompounder(function(result, word, index2) {
  return result + (index2 ? "-" : "") + word.toLowerCase();
});
var lodashKebabCase = kebabCase;
var merge = createAssigner(function(object2, source, srcIndex) {
  baseMerge(object2, source, srcIndex);
});
var lodashMerge = merge;
function baseSome(collection, predicate) {
  var result;
  baseEach$1(collection, function(value2, index2, collection2) {
    result = predicate(value2, index2, collection2);
    return !result;
  });
  return !!result;
}
function some(collection, predicate, guard) {
  var func = isArray$1(collection) ? arraySome : baseSome;
  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee(predicate));
}
var INFINITY = 1 / 0;
var createSet = !(Set$2 && 1 / setToArray(new Set$2([, -0]))[1] == INFINITY) ? noop$3 : function(values) {
  return new Set$2(values);
};
var createSet$1 = createSet;
var LARGE_ARRAY_SIZE = 200;
function baseUniq(array2, iteratee, comparator) {
  var index2 = -1, includes = arrayIncludes, length = array2.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set2 = iteratee ? null : createSet$1(array2);
    if (set2) {
      return setToArray(set2);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index2 < length) {
      var value2 = array2[index2], computed = iteratee ? iteratee(value2) : value2;
      value2 = comparator || value2 !== 0 ? value2 : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value2);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value2);
      }
    }
  return result;
}
var unionBy = baseRest(function(arrays) {
  var iteratee = last(arrays);
  if (isArrayLikeObject(iteratee)) {
    iteratee = void 0;
  }
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), baseIteratee(iteratee));
});
var lodashUnionBy = unionBy;
function uniq(array2) {
  return array2 && array2.length ? baseUniq(array2) : [];
}
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
    name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
}
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name) {
  var fullname = namespace(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none$2() {
}
function selector(selector2) {
  return selector2 == null ? none$2 : function() {
    return this.querySelector(selector2);
  };
}
function selection_select(select2) {
  if (typeof select2 !== "function")
    select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select2.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function array$3(x2) {
  return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
}
function empty$1() {
  return [];
}
function selectorAll(selector2) {
  return selector2 == null ? empty$1 : function() {
    return this.querySelectorAll(selector2);
  };
}
function arrayAll(select2) {
  return function() {
    return array$3(select2.apply(this, arguments));
  };
}
function selection_selectAll(select2) {
  if (typeof select2 === "function")
    select2 = arrayAll(select2);
  else
    select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select2.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection$1(subgroups, parents);
}
function matcher(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function childMatcher(selector2) {
  return function(node) {
    return node.matches(selector2);
  };
}
var find$1 = Array.prototype.find;
function childFind(match2) {
  return function() {
    return find$1.call(this.children, match2);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match2) {
  return this.select(match2 == null ? childFirst : childFind(typeof match2 === "function" ? match2 : childMatcher(match2)));
}
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match2) {
  return function() {
    return filter.call(this.children, match2);
  };
}
function selection_selectChildren(match2) {
  return this.selectAll(match2 == null ? children : childrenFilter(typeof match2 === "function" ? match2 : childMatcher(match2)));
}
function selection_filter(match2) {
  if (typeof match2 !== "function")
    match2 = matcher(match2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match2.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function sparse(update) {
  return new Array(update.length);
}
function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$7(x2) {
  return function() {
    return x2;
  };
}
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function selection_data(value2, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value2 !== "function")
    value2 = constant$7(value2);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value2.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection$1(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}
function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}
function selection_merge(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge2[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection$1(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}
function selection_sort(compare) {
  if (!compare)
    compare = ascending$1;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection$1(sortgroups, this._parents).order();
}
function ascending$1(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
function selection_nodes() {
  return Array.from(this);
}
function selection_node() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node)
        return node;
    }
  }
  return null;
}
function selection_size() {
  let size = 0;
  for (const node of this)
    ++size;
  return size;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}
function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1(name, value2) {
  return function() {
    this.setAttribute(name, value2);
  };
}
function attrConstantNS$1(fullname, value2) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value2);
  };
}
function attrFunction$1(name, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v);
  };
}
function attrFunctionNS$1(fullname, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function selection_attr(name, value2) {
  var fullname = namespace(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value2 == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value2 === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value2));
}
function defaultView(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}
function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant$1(name, value2, priority) {
  return function() {
    this.style.setProperty(name, value2, priority);
  };
}
function styleFunction$1(name, value2, priority) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v, priority);
  };
}
function selection_style(name, value2, priority) {
  return arguments.length > 1 ? this.each((value2 == null ? styleRemove$1 : typeof value2 === "function" ? styleFunction$1 : styleConstant$1)(name, value2, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value2) {
  return function() {
    this[name] = value2;
  };
}
function propertyFunction(name, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null)
      delete this[name];
    else
      this[name] = v;
  };
}
function selection_property(name, value2) {
  return arguments.length > 1 ? this.each((value2 == null ? propertyRemove : typeof value2 === "function" ? propertyFunction : propertyConstant)(name, value2)) : this.node()[name];
}
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value2) {
  return function() {
    (value2.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name, value2) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value2 === "function" ? classedFunction : value2 ? classedTrue : classedFalse)(names, value2));
}
function textRemove() {
  this.textContent = "";
}
function textConstant$1(value2) {
  return function() {
    this.textContent = value2;
  };
}
function textFunction$1(value2) {
  return function() {
    var v = value2.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function selection_text(value2) {
  return arguments.length ? this.each(value2 == null ? textRemove : (typeof value2 === "function" ? textFunction$1 : textConstant$1)(value2)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value2) {
  return function() {
    this.innerHTML = value2;
  };
}
function htmlFunction(value2) {
  return function() {
    var v = value2.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function selection_html(value2) {
  return arguments.length ? this.each(value2 == null ? htmlRemove : (typeof value2 === "function" ? htmlFunction : htmlConstant)(value2)) : this.node().innerHTML;
}
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name) {
  var create2 = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name, before) {
  var create2 = typeof name === "function" ? name : creator(name), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value2) {
  return arguments.length ? this.property("__data__", value2) : this.node().__data__;
}
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames$2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove(typename) {
  return function() {
    var on2 = this.__on;
    if (!on2)
      return;
    for (var j = 0, i = -1, m = on2.length, o; j < m; ++j) {
      if (o = on2[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on2[++i] = o;
      }
    }
    if (++i)
      on2.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value2, options2) {
  return function() {
    var on2 = this.__on, o, listener = contextListener(value2);
    if (on2)
      for (var j = 0, m = on2.length; j < m; ++j) {
        if ((o = on2[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options2);
          o.value = value2;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options2);
    o = { type: typename.type, name: typename.name, value: value2, listener, options: options2 };
    if (!on2)
      this.__on = [o];
    else
      on2.push(o);
  };
}
function selection_on(typename, value2, options2) {
  var typenames = parseTypenames$2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on2 = this.node().__on;
    if (on2)
      for (var j = 0, m = on2.length, o; j < m; ++j) {
        for (i = 0, o = on2[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on2 = value2 ? onAdd : onRemove;
  for (i = 0; i < n; ++i)
    this.each(on2(typenames[i], value2, options2));
  return this;
}
function dispatchEvent(node, type2, params) {
  var window2 = defaultView(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type2, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function selection_dispatch(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}
function* selection_iterator() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        yield node;
    }
  }
}
var root = [null];
function Selection$1(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection$1([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};
function select(selector2) {
  return typeof selector2 === "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root);
}
function sourceEvent(event) {
  let sourceEvent2;
  while (sourceEvent2 = event.sourceEvent)
    event = sourceEvent2;
  return event;
}
function pointer(event, node) {
  event = sourceEvent(event);
  if (node === void 0)
    node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point2 = svg.createSVGPoint();
      point2.x = event.clientX, point2.y = event.clientY;
      point2 = point2.matrixTransform(node.getScreenCTM().inverse());
      return [point2.x, point2.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
var Tools;
(function(Tools2) {
  Tools2.debounce = debounce;
  Tools2.clone = cloneDeep;
  Tools2.merge = lodashMerge;
  Tools2.unionBy = lodashUnionBy;
  Tools2.removeArrayDuplicates = uniq;
  Tools2.clamp = clamp;
  Tools2.flatten = flatten$1;
  Tools2.groupBy = lodashGroupBy;
  Tools2.camelCase = lodashCamelCase;
  Tools2.isEmpty = isEmpty;
  Tools2.isEqual = isEqual;
  Tools2.flatMapDeep = flatMapDeep;
  Tools2.kebabCase = lodashKebabCase;
  Tools2.fromPairs = fromPairs;
  Tools2.some = some;
  function debounceWithD3MousePosition(fn, delay, holder) {
    var timer2 = null;
    return function() {
      var context = this;
      var args = arguments;
      context.mousePosition = pointer(args[0], holder);
      clearTimeout(timer2);
      timer2 = setTimeout(function() {
        fn.apply(context, args);
      }, delay);
    };
  }
  Tools2.debounceWithD3MousePosition = debounceWithD3MousePosition;
  function mergeDefaultChartOptions(defaultOptions, providedOptions) {
    var _a2, _b;
    var clonedDefaultOptions = Tools2.clone(defaultOptions);
    var providedAxesNames = Object.keys(providedOptions.axes || {});
    if ((_b = (_a2 = providedOptions) === null || _a2 === void 0 ? void 0 : _a2.toolbar) === null || _b === void 0 ? void 0 : _b.controls) {
      delete clonedDefaultOptions.toolbar.controls;
    }
    if (providedAxesNames.length === 0) {
      delete clonedDefaultOptions.axes;
    }
    for (var axisName in clonedDefaultOptions.axes) {
      if (providedAxesNames.includes(axisName)) {
        var providedAxisOptions = providedOptions.axes[axisName];
        if (providedAxisOptions["primary"] || providedAxisOptions["secondary"]) {
          console.warn("`primary` & `secondary` are no longer needed for axis configurations. Read more here https://carbon-design-system.github.io/carbon-charts/?path=/story/docs-tutorials--tabular-data-format");
        }
        var identifier = providedAxisOptions["mapsTo"];
        if (identifier === void 0 || identifier === null) {
          var scaleType = providedAxisOptions["scaleType"];
          if (scaleType === void 0 || scaleType === null) {
            providedAxisOptions["mapsTo"] = "value";
          } else if (scaleType === ScaleTypes.TIME) {
            providedAxisOptions["mapsTo"] = "date";
          } else if (scaleType === ScaleTypes.LABELS) {
            providedAxisOptions["mapsTo"] = "key";
          }
        }
      } else {
        delete clonedDefaultOptions.axes[axisName];
      }
    }
    updateLegendAdditionalItems(clonedDefaultOptions, providedOptions);
    return Tools2.merge(clonedDefaultOptions, providedOptions);
  }
  Tools2.mergeDefaultChartOptions = mergeDefaultChartOptions;
  function getDimensions(el) {
    return {
      width: parseFloat(el.style.width.replace("px", "") || el.offsetWidth),
      height: parseFloat(el.style.height.replace("px", "") || el.offsetHeight)
    };
  }
  Tools2.getDimensions = getDimensions;
  function getTranslationValues(elementRef) {
    if (!elementRef) {
      return;
    }
    var translateRegex = /translate\([0-9]+\.?[0-9]*,[0-9]+\.?[0-9]*\)/;
    var transformStr = elementRef.getAttribute("transform").match(translateRegex);
    if (!transformStr) {
      return null;
    }
    if (transformStr[0]) {
      var transforms = transformStr[0].replace(/translate\(/, "").replace(/\)/, "").split(",");
      return {
        tx: transforms[0],
        ty: transforms[1]
      };
    }
    return null;
  }
  Tools2.getTranslationValues = getTranslationValues;
  function getTranformOffsets(string) {
    var regExp = /\(([^)]+)\)/;
    var match2 = regExp.exec(string)[1];
    var xyString = match2.split(",");
    return {
      x: parseFloat(xyString[0]),
      y: parseFloat(xyString[1])
    };
  }
  Tools2.getTranformOffsets = getTranformOffsets;
  function formatWidthHeightValues(value2) {
    var stringValue = value2.toString();
    if (stringValue.match(/[a-z]/i)) {
      return stringValue;
    }
    return stringValue + "px";
  }
  Tools2.formatWidthHeightValues = formatWidthHeightValues;
  function capitalizeFirstLetter(string) {
    return string[0].toUpperCase() + string.slice(1);
  }
  Tools2.capitalizeFirstLetter = capitalizeFirstLetter;
  function convertValueToPercentage(item, fullData, key) {
    if (key === void 0) {
      key = "value";
    }
    var percentage = item / fullData.reduce(function(accum, val) {
      return accum + val[key];
    }, 0) * 100;
    return percentage % 1 !== 0 ? parseFloat(percentage.toFixed(1)) : percentage;
  }
  Tools2.convertValueToPercentage = convertValueToPercentage;
  function truncateLabel(fullText, truncationType, numCharacter) {
    if (numCharacter > fullText.length) {
      return fullText;
    }
    if (truncationType === TruncationTypes.MID_LINE) {
      return fullText.substr(0, numCharacter / 2) + "..." + fullText.substr(-numCharacter / 2);
    } else if (truncationType === TruncationTypes.FRONT_LINE) {
      return "..." + fullText.substr(-numCharacter);
    } else if (truncationType === TruncationTypes.END_LINE) {
      return fullText.substr(0, numCharacter) + "...";
    }
  }
  Tools2.truncateLabel = truncateLabel;
  function updateLegendAdditionalItems(defaultOptions, providedOptions) {
    var defaultAdditionalItems = Tools2.getProperty(defaultOptions, "legend", "additionalItems");
    var userProvidedAdditionalItems = Tools2.getProperty(providedOptions, "legend", "additionalItems");
    if (defaultAdditionalItems && userProvidedAdditionalItems) {
      var providedTypes_1 = userProvidedAdditionalItems.map(function(item) {
        return item.type;
      });
      var defaultTypes_1 = defaultAdditionalItems.map(function(item) {
        return item.type;
      });
      var updatedDefaultItems = defaultLegendAdditionalItems.filter(function(item) {
        return defaultTypes_1.includes(item.type) && !providedTypes_1.includes(item.type);
      });
      defaultOptions.legend.additionalItems = updatedDefaultItems;
      providedOptions.legend.additionalItems = Tools2.unionBy(updatedDefaultItems, userProvidedAdditionalItems, "name");
    }
  }
  Tools2.updateLegendAdditionalItems = updateLegendAdditionalItems;
  function arrayDifferences(oldArray, newArray) {
    var difference = {
      missing: [],
      added: []
    };
    oldArray.forEach(function(element) {
      if (newArray.indexOf(element) === -1) {
        difference.missing.push(element);
      }
    });
    newArray.forEach(function(element) {
      if (oldArray.indexOf(element) === -1) {
        difference.added.push(element);
      }
    });
    return difference;
  }
  Tools2.arrayDifferences = arrayDifferences;
  function getDuplicateValues(arr) {
    var values = [];
    var duplicateValues = [];
    arr.forEach(function(value2) {
      if (values.indexOf(value2) !== -1 && duplicateValues.indexOf(value2) === -1) {
        duplicateValues.push(value2);
      }
      values.push(value2);
    });
    return duplicateValues;
  }
  Tools2.getDuplicateValues = getDuplicateValues;
  function moveToFront(element) {
    return element.each(function() {
      this.parentNode.appendChild(this);
    });
  }
  Tools2.moveToFront = moveToFront;
  Tools2.getProperty = function(object2) {
    var propPath = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      propPath[_i - 1] = arguments[_i];
    }
    var position = object2;
    if (position) {
      for (var _a2 = 0, propPath_1 = propPath; _a2 < propPath_1.length; _a2++) {
        var prop = propPath_1[_a2];
        if (position[prop] !== null && position[prop] !== void 0) {
          position = position[prop];
        } else {
          return null;
        }
      }
      return position;
    }
    return null;
  };
  Tools2.flipSVGCoordinatesBasedOnOrientation = function(verticalCoordinates, orientation) {
    if (orientation === CartesianOrientations.HORIZONTAL) {
      return {
        y0: verticalCoordinates.x0,
        y1: verticalCoordinates.x1,
        x0: verticalCoordinates.y0,
        x1: verticalCoordinates.y1
      };
    }
    return verticalCoordinates;
  };
  Tools2.generateSVGPathString = function(verticalCoordinates, orientation) {
    var _a2 = Tools2.flipSVGCoordinatesBasedOnOrientation(verticalCoordinates, orientation), x0 = _a2.x0, x1 = _a2.x1, y0 = _a2.y0, y1 = _a2.y1;
    return "M" + x0 + "," + y0 + "L" + x0 + "," + y1 + "L" + x1 + "," + y1 + "L" + x1 + "," + y0 + "L" + x0 + "," + y0;
  };
  function flipDomainAndRangeBasedOnOrientation(domain, range2, orientation) {
    return orientation === CartesianOrientations.VERTICAL ? [domain, range2] : [range2, domain];
  }
  Tools2.flipDomainAndRangeBasedOnOrientation = flipDomainAndRangeBasedOnOrientation;
  Tools2.compareNumeric = function(a, b) {
    return Number(a) === Number(b);
  };
})(Tools || (Tools = {}));
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var enUS = { exports: {} };
var formatDistance$1 = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = formatDistance2;
  var formatDistanceLocale2 = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  };
  function formatDistance2(token, count2, options2) {
    options2 = options2 || {};
    var result;
    if (typeof formatDistanceLocale2[token] === "string") {
      result = formatDistanceLocale2[token];
    } else if (count2 === 1) {
      result = formatDistanceLocale2[token].one;
    } else {
      result = formatDistanceLocale2[token].other.replace("{{count}}", count2);
    }
    if (options2.addSuffix) {
      if (options2.comparison > 0) {
        return "in " + result;
      } else {
        return result + " ago";
      }
    }
    return result;
  }
  module2.exports = exports2.default;
})(formatDistance$1, formatDistance$1.exports);
var formatLong$2 = { exports: {} };
var buildFormatLongFn$1 = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = buildFormatLongFn2;
  function buildFormatLongFn2(args) {
    return function(dirtyOptions) {
      var options2 = dirtyOptions || {};
      var width = options2.width ? String(options2.width) : args.defaultWidth;
      var format2 = args.formats[width] || args.formats[args.defaultWidth];
      return format2;
    };
  }
  module2.exports = exports2.default;
})(buildFormatLongFn$1, buildFormatLongFn$1.exports);
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = void 0;
  var _index = _interopRequireDefault(buildFormatLongFn$1.exports);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var dateFormats2 = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  };
  var timeFormats2 = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  };
  var dateTimeFormats2 = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  };
  var formatLong2 = {
    date: (0, _index.default)({
      formats: dateFormats2,
      defaultWidth: "full"
    }),
    time: (0, _index.default)({
      formats: timeFormats2,
      defaultWidth: "full"
    }),
    dateTime: (0, _index.default)({
      formats: dateTimeFormats2,
      defaultWidth: "full"
    })
  };
  var _default = formatLong2;
  exports2.default = _default;
  module2.exports = exports2.default;
})(formatLong$2, formatLong$2.exports);
var formatRelative$1 = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = formatRelative2;
  var formatRelativeLocale2 = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  };
  function formatRelative2(token, _date, _baseDate, _options) {
    return formatRelativeLocale2[token];
  }
  module2.exports = exports2.default;
})(formatRelative$1, formatRelative$1.exports);
var localize$2 = { exports: {} };
var buildLocalizeFn$1 = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = buildLocalizeFn2;
  function buildLocalizeFn2(args) {
    return function(dirtyIndex, dirtyOptions) {
      var options2 = dirtyOptions || {};
      var context = options2.context ? String(options2.context) : "standalone";
      var valuesArray;
      if (context === "formatting" && args.formattingValues) {
        var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        var width = options2.width ? String(options2.width) : defaultWidth;
        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        var _defaultWidth = args.defaultWidth;
        var _width = options2.width ? String(options2.width) : args.defaultWidth;
        valuesArray = args.values[_width] || args.values[_defaultWidth];
      }
      var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
      return valuesArray[index2];
    };
  }
  module2.exports = exports2.default;
})(buildLocalizeFn$1, buildLocalizeFn$1.exports);
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = void 0;
  var _index = _interopRequireDefault(buildLocalizeFn$1.exports);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var eraValues2 = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  };
  var quarterValues2 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  };
  var monthValues2 = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  };
  var dayValues2 = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
  };
  var dayPeriodValues2 = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  };
  var formattingDayPeriodValues2 = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  };
  function ordinalNumber2(dirtyNumber, _dirtyOptions) {
    var number3 = Number(dirtyNumber);
    var rem100 = number3 % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number3 + "st";
        case 2:
          return number3 + "nd";
        case 3:
          return number3 + "rd";
      }
    }
    return number3 + "th";
  }
  var localize2 = {
    ordinalNumber: ordinalNumber2,
    era: (0, _index.default)({
      values: eraValues2,
      defaultWidth: "wide"
    }),
    quarter: (0, _index.default)({
      values: quarterValues2,
      defaultWidth: "wide",
      argumentCallback: function(quarter) {
        return Number(quarter) - 1;
      }
    }),
    month: (0, _index.default)({
      values: monthValues2,
      defaultWidth: "wide"
    }),
    day: (0, _index.default)({
      values: dayValues2,
      defaultWidth: "wide"
    }),
    dayPeriod: (0, _index.default)({
      values: dayPeriodValues2,
      defaultWidth: "wide",
      formattingValues: formattingDayPeriodValues2,
      defaultFormattingWidth: "wide"
    })
  };
  var _default = localize2;
  exports2.default = _default;
  module2.exports = exports2.default;
})(localize$2, localize$2.exports);
var match$2 = { exports: {} };
var buildMatchPatternFn$1 = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = buildMatchPatternFn2;
  function buildMatchPatternFn2(args) {
    return function(dirtyString, dirtyOptions) {
      var string = String(dirtyString);
      var options2 = dirtyOptions || {};
      var matchResult = string.match(args.matchPattern);
      if (!matchResult) {
        return null;
      }
      var matchedString = matchResult[0];
      var parseResult = string.match(args.parsePattern);
      if (!parseResult) {
        return null;
      }
      var value2 = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value2 = options2.valueCallback ? options2.valueCallback(value2) : value2;
      return {
        value: value2,
        rest: string.slice(matchedString.length)
      };
    };
  }
  module2.exports = exports2.default;
})(buildMatchPatternFn$1, buildMatchPatternFn$1.exports);
var buildMatchFn$1 = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = buildMatchFn2;
  function buildMatchFn2(args) {
    return function(dirtyString, dirtyOptions) {
      var string = String(dirtyString);
      var options2 = dirtyOptions || {};
      var width = options2.width;
      var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
      var matchResult = string.match(matchPattern);
      if (!matchResult) {
        return null;
      }
      var matchedString = matchResult[0];
      var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
      var value2;
      if (Object.prototype.toString.call(parsePatterns) === "[object Array]") {
        value2 = findIndex2(parsePatterns, function(pattern) {
          return pattern.test(string);
        });
      } else {
        value2 = findKey2(parsePatterns, function(pattern) {
          return pattern.test(string);
        });
      }
      value2 = args.valueCallback ? args.valueCallback(value2) : value2;
      value2 = options2.valueCallback ? options2.valueCallback(value2) : value2;
      return {
        value: value2,
        rest: string.slice(matchedString.length)
      };
    };
  }
  function findKey2(object2, predicate) {
    for (var key in object2) {
      if (object2.hasOwnProperty(key) && predicate(object2[key])) {
        return key;
      }
    }
  }
  function findIndex2(array2, predicate) {
    for (var key = 0; key < array2.length; key++) {
      if (predicate(array2[key])) {
        return key;
      }
    }
  }
  module2.exports = exports2.default;
})(buildMatchFn$1, buildMatchFn$1.exports);
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = void 0;
  var _index = _interopRequireDefault(buildMatchPatternFn$1.exports);
  var _index2 = _interopRequireDefault(buildMatchFn$1.exports);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var matchOrdinalNumberPattern2 = /^(\d+)(th|st|nd|rd)?/i;
  var parseOrdinalNumberPattern2 = /\d+/i;
  var matchEraPatterns2 = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  var parseEraPatterns2 = {
    any: [/^b/i, /^(a|c)/i]
  };
  var matchQuarterPatterns2 = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  var parseQuarterPatterns2 = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  var matchMonthPatterns2 = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  var parseMonthPatterns2 = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  };
  var matchDayPatterns2 = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  var parseDayPatterns2 = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  var matchDayPeriodPatterns2 = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  var parseDayPeriodPatterns2 = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  var match2 = {
    ordinalNumber: (0, _index.default)({
      matchPattern: matchOrdinalNumberPattern2,
      parsePattern: parseOrdinalNumberPattern2,
      valueCallback: function(value2) {
        return parseInt(value2, 10);
      }
    }),
    era: (0, _index2.default)({
      matchPatterns: matchEraPatterns2,
      defaultMatchWidth: "wide",
      parsePatterns: parseEraPatterns2,
      defaultParseWidth: "any"
    }),
    quarter: (0, _index2.default)({
      matchPatterns: matchQuarterPatterns2,
      defaultMatchWidth: "wide",
      parsePatterns: parseQuarterPatterns2,
      defaultParseWidth: "any",
      valueCallback: function(index2) {
        return index2 + 1;
      }
    }),
    month: (0, _index2.default)({
      matchPatterns: matchMonthPatterns2,
      defaultMatchWidth: "wide",
      parsePatterns: parseMonthPatterns2,
      defaultParseWidth: "any"
    }),
    day: (0, _index2.default)({
      matchPatterns: matchDayPatterns2,
      defaultMatchWidth: "wide",
      parsePatterns: parseDayPatterns2,
      defaultParseWidth: "any"
    }),
    dayPeriod: (0, _index2.default)({
      matchPatterns: matchDayPeriodPatterns2,
      defaultMatchWidth: "any",
      parsePatterns: parseDayPeriodPatterns2,
      defaultParseWidth: "any"
    })
  };
  var _default = match2;
  exports2.default = _default;
  module2.exports = exports2.default;
})(match$2, match$2.exports);
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = void 0;
  var _index = _interopRequireDefault(formatDistance$1.exports);
  var _index2 = _interopRequireDefault(formatLong$2.exports);
  var _index3 = _interopRequireDefault(formatRelative$1.exports);
  var _index4 = _interopRequireDefault(localize$2.exports);
  var _index5 = _interopRequireDefault(match$2.exports);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var locale2 = {
    code: "en-US",
    formatDistance: _index.default,
    formatLong: _index2.default,
    formatRelative: _index3.default,
    localize: _index4.default,
    match: _index5.default,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  };
  var _default = locale2;
  exports2.default = _default;
  module2.exports = exports2.default;
})(enUS, enUS.exports);
var enUSLocaleObject = /* @__PURE__ */ getDefaultExportFromCjs(enUS.exports);
var __spreadArrays$k = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var standardTruncationOptions = {
  type: TruncationTypes.END_LINE,
  threshold: 16,
  numCharacter: 14
};
var legend = {
  enabled: true,
  position: LegendPositions.BOTTOM,
  clickable: true,
  truncation: standardTruncationOptions,
  alignment: Alignments.LEFT,
  order: null,
  additionalItems: []
};
var grid = {
  x: {
    enabled: true,
    numberOfTicks: 15,
    alignWithAxisTicks: false
  },
  y: {
    enabled: true,
    numberOfTicks: 5,
    alignWithAxisTicks: false
  }
};
var ruler = {
  enabled: true
};
var baseTooltip = {
  enabled: true,
  showTotal: true,
  truncation: standardTruncationOptions,
  groupLabel: "Group"
};
var axes = {
  top: {
    visible: true,
    includeZero: true,
    truncation: standardTruncationOptions
  },
  bottom: {
    visible: true,
    includeZero: true,
    truncation: standardTruncationOptions
  },
  left: {
    visible: true,
    includeZero: true,
    truncation: standardTruncationOptions
  },
  right: {
    visible: true,
    includeZero: true,
    truncation: standardTruncationOptions
  }
};
var timeScale = {
  addSpaceOnEdges: 1,
  showDayName: false,
  localeObject: enUSLocaleObject,
  timeIntervalFormats: {
    "15seconds": { primary: "MMM d, pp", secondary: "pp" },
    minute: { primary: "MMM d, p", secondary: "p" },
    "30minutes": { primary: "MMM d, p", secondary: "p" },
    hourly: { primary: "MMM d, hh a", secondary: "hh a" },
    daily: { primary: "MMM d", secondary: "d" },
    weekly: { primary: "eee, MMM d", secondary: "eee" },
    monthly: { primary: "MMM yyyy", secondary: "MMM" },
    quarterly: { primary: "QQQ ''yy", secondary: "QQQ" },
    yearly: { primary: "yyyy", secondary: "yyyy" }
  }
};
var isFullScreenEnabled = typeof document !== "undefined" && (document["fullscreenEnabled"] || document["webkitFullscreenEnabled"] || document["mozFullScreenEnabled"] || document["msFullscreenEnabled"]);
var chart = {
  width: null,
  height: null,
  resizable: true,
  tooltip: baseTooltip,
  legend,
  style: {
    prefix: "cc"
  },
  data: {
    groupMapsTo: "group",
    loading: false,
    selectedGroups: []
  },
  color: {
    scale: null,
    pairing: {
      numberOfVariants: null,
      option: 1
    },
    gradient: {
      enabled: false
    }
  },
  toolbar: {
    enabled: true,
    numberOfIcons: 3,
    controls: __spreadArrays$k([
      {
        type: ToolbarControlTypes.SHOW_AS_DATATABLE
      }
    ], isFullScreenEnabled ? [
      {
        type: ToolbarControlTypes.MAKE_FULLSCREEN
      }
    ] : [], [
      {
        type: ToolbarControlTypes.EXPORT_CSV
      },
      {
        type: ToolbarControlTypes.EXPORT_PNG
      },
      {
        type: ToolbarControlTypes.EXPORT_JPG
      }
    ])
  }
};
var axisChart = Tools.merge({}, chart, {
  axes,
  timeScale,
  grid,
  ruler,
  zoomBar: {
    zoomRatio: 0.4,
    minZoomRatio: 0.01,
    top: {
      enabled: false,
      type: ZoomBarTypes.GRAPH_VIEW
    }
  }
});
var baseBarChart = Tools.merge({}, axisChart, {
  bars: {
    maxWidth: 16,
    spacingFactor: 0.25
  },
  timeScale: Tools.merge(timeScale, {
    addSpaceOnEdges: 1
  })
});
var simpleBarChart = Tools.merge({}, baseBarChart, {});
var groupedBarChart = Tools.merge({}, baseBarChart, {});
var stackedBarChart = Tools.merge({}, baseBarChart, {
  bars: Tools.merge({}, baseBarChart.bars, {
    dividerSize: 1.5
  })
});
var boxplotChart = Tools.merge({}, baseBarChart, {});
var scatterChart = Tools.merge({}, axisChart, {
  points: {
    radius: 4,
    fillOpacity: 0.3,
    filled: true,
    enabled: true
  }
});
var lollipopChart = scatterChart;
var lineChart = Tools.merge({}, scatterChart, {
  points: {
    radius: 3,
    filled: false,
    enabled: true
  }
});
var areaChart = Tools.merge({}, lineChart, {
  timeScale: Tools.merge(timeScale, {
    addSpaceOnEdges: 0
  })
});
var stackedAreaChart = areaChart;
var bubbleChart = Tools.merge({}, axisChart, {
  bubble: {
    radiusMapsTo: "radius",
    radiusLabel: "Radius",
    radiusRange: function(chartSize, data) {
      var smallerChartDimension = Math.min(chartSize.width, chartSize.height);
      return [
        smallerChartDimension * 3 / 400,
        smallerChartDimension * 25 / 400
      ];
    },
    fillOpacity: 0.2,
    enabled: true
  },
  points: {
    filled: true
  },
  legend: {
    additionalItems: [
      {
        type: LegendItemType.RADIUS,
        name: "Radius"
      }
    ]
  }
});
var bulletChart = Tools.merge({}, axisChart, {
  bullet: {
    performanceAreaTitles: ["Poor", "Satisfactory", "Great"]
  },
  grid: {
    x: {
      enabled: false
    },
    y: {
      enabled: false
    }
  },
  legend: {
    additionalItems: [
      {
        type: LegendItemType.AREA,
        name: "Poor area"
      },
      {
        type: LegendItemType.AREA,
        name: "Satisfactory area"
      },
      {
        type: LegendItemType.AREA,
        name: "Great area"
      },
      {
        type: LegendItemType.QUARTILE,
        name: "Quartiles"
      }
    ]
  }
});
var histogramChart = Tools.merge({}, baseBarChart, {
  bars: {
    dividerSize: 1.5
  },
  timeScale: Tools.merge(timeScale, {
    addSpaceOnEdges: 0
  })
});
var wordCloudChart = Tools.merge({}, chart, {
  tooltip: Tools.merge({}, baseTooltip, {
    wordLabel: "Word",
    valueLabel: "Value"
  }),
  wordCloud: {
    fontSizeMapsTo: "value",
    fontSizeRange: function(chartSize, data) {
      var smallerChartDimension = Math.min(chartSize.width, chartSize.height);
      return [
        smallerChartDimension * 20 / 400,
        smallerChartDimension * 75 / 400
      ];
    },
    wordMapsTo: "word"
  }
});
var pieChart = Tools.merge({}, chart, {
  pie: {
    labels: {
      formatter: null,
      enabled: true
    },
    alignment: Alignments.LEFT,
    sortFunction: null,
    valueMapsTo: "value"
  }
});
var gaugeChart = Tools.merge({}, chart, {
  legend: {
    enabled: false
  },
  gauge: {
    type: GaugeTypes.SEMI,
    arcWidth: 16,
    deltaArrow: {
      size: function(radius) {
        return radius / 8;
      },
      enabled: true
    },
    showPercentageSymbol: true,
    status: null,
    numberSpacing: 10,
    deltaFontSize: function(radius) {
      return radius / 8;
    },
    valueFontSize: function(radius) {
      return radius / 2.5;
    },
    numberFormatter: function(number3) {
      return number3.toFixed(2) % 1 !== 0 ? number3.toFixed(2).toLocaleString() : number3.toFixed().toLocaleString();
    },
    alignment: Alignments.LEFT
  }
});
var donutChart = Tools.merge({}, pieChart, {
  donut: {
    center: {
      numberFontSize: function(radius) {
        return Math.min(radius / 100 * 24, 24) + "px";
      },
      titleFontSize: function(radius) {
        return Math.min(radius / 100 * 15, 15) + "px";
      },
      titleYPosition: function(radius) {
        return Math.min(radius / 80 * 20, 20);
      },
      numberFormatter: function(number3) {
        return Math.floor(number3).toLocaleString();
      }
    },
    alignment: Alignments.LEFT
  }
});
var meterChart = Tools.merge({}, chart, {
  legend: {
    enabled: false,
    clickable: false
  },
  meter: {
    showLabels: true,
    proportional: null,
    statusBar: {
      percentageIndicator: {
        enabled: true
      }
    }
  }
});
var proportionalMeterChart = Tools.merge({}, meterChart, {
  legend: {
    enabled: true
  }
});
var radarChart = Tools.merge({}, chart, {
  radar: {
    axes: {
      angle: "key",
      value: "value"
    },
    alignment: Alignments.LEFT
  },
  tooltip: {
    gridline: {
      enabled: true
    },
    valueFormatter: function(value2) {
      return value2 !== null && value2 !== void 0 ? value2 : "N/A";
    }
  }
});
var comboChart = Tools.merge({}, baseBarChart, {
  comboChartTypes: []
});
var treeChart = Tools.merge({
  tree: {
    type: TreeTypes.TREE
  }
}, chart, {});
var treemapChart = Tools.merge({}, chart, {
  data: Tools.merge(chart.data, {
    groupMapsTo: "name"
  })
});
var circlePackChart = Tools.merge({}, chart, circlePack, {
  data: Tools.merge(chart.data, {
    groupMapsTo: "name"
  })
});
var alluvialChart = Tools.merge({}, chart, {
  alluvial: {
    data: Tools.merge(chart.data, {
      groupMapsTo: "source"
    }),
    nodePadding: 24,
    monochrome: false,
    nodes: []
  }
});
var heatmapChart = Tools.merge({}, chart, {
  axes,
  heatmap: {
    divider: {
      state: DividerStatus.AUTO
    },
    colorLegend: {
      type: "linear"
    }
  }
});
var options = {
  chart,
  axisChart,
  simpleBarChart,
  groupedBarChart,
  stackedBarChart,
  boxplotChart,
  bubbleChart,
  bulletChart,
  histogramChart,
  lineChart,
  areaChart,
  stackedAreaChart,
  scatterChart,
  lollipopChart,
  pieChart,
  donutChart,
  meterChart,
  proportionalMeterChart,
  radarChart,
  gaugeChart,
  comboChart,
  treeChart,
  treemapChart,
  circlePackChart,
  wordCloudChart,
  alluvialChart,
  heatmapChart
};
var Configuration = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  grid,
  ruler,
  baseTooltip,
  timeScale,
  options,
  area: area$1,
  axis: axis$1,
  canvasZoomSettings,
  circlePack,
  color: color$1,
  boxplot,
  histogram,
  legend: legend$1,
  lines,
  meter,
  pie: pie$1,
  radar,
  alluvial,
  heatmap,
  spacers,
  tooltips,
  transitions,
  toolbar,
  zoomBar,
  defaultLegendAdditionalItems
});
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function bisector(f) {
  let delta = f;
  let compare1 = f;
  let compare2 = f;
  if (f.length !== 2) {
    delta = (d, x2) => f(d) - x2;
    compare1 = ascending;
    compare2 = (d, x2) => ascending(f(d), x2);
  }
  function left2(a, x2, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x2) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a, x2, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x2) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a, x2, lo = 0, hi = a.length) {
    const i = left2(a, x2, lo, hi - 1);
    return i > lo && delta(a[i - 1], x2) > -delta(a[i], x2) ? i - 1 : i;
  }
  return { left: left2, center: center2, right: right2 };
}
function number$3(x2) {
  return x2 === null ? NaN : +x2;
}
function* numbers(values, valueof) {
  if (valueof === void 0) {
    for (let value2 of values) {
      if (value2 != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index2, values)) != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  }
}
const ascendingBisect = bisector(ascending);
const bisectRight = ascendingBisect.right;
bisector(number$3).center;
var bisect = bisectRight;
function count$1(values, valueof) {
  let count2 = 0;
  if (valueof === void 0) {
    for (let value2 of values) {
      if (value2 != null && (value2 = +value2) >= value2) {
        ++count2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index2, values)) != null && (value2 = +value2) >= value2) {
        ++count2;
      }
    }
  }
  return count2;
}
function extent(values, valueof) {
  let min2;
  let max2;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null) {
        if (min2 === void 0) {
          if (value2 >= value2)
            min2 = max2 = value2;
        } else {
          if (min2 > value2)
            min2 = value2;
          if (max2 < value2)
            max2 = value2;
        }
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index2, values)) != null) {
        if (min2 === void 0) {
          if (value2 >= value2)
            min2 = max2 = value2;
        } else {
          if (min2 > value2)
            min2 = value2;
          if (max2 < value2)
            max2 = value2;
        }
      }
    }
  }
  return [min2, max2];
}
class InternMap extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null)
      for (const [key2, value2] of entries)
        this.set(key2, value2);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value2) {
    return super.set(intern_set(this, key), value2);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
}
function intern_get({ _intern, _key }, value2) {
  const key = _key(value2);
  return _intern.has(key) ? _intern.get(key) : value2;
}
function intern_set({ _intern, _key }, value2) {
  const key = _key(value2);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value2);
  return value2;
}
function intern_delete({ _intern, _key }, value2) {
  const key = _key(value2);
  if (_intern.has(key)) {
    value2 = _intern.get(key);
    _intern.delete(key);
  }
  return value2;
}
function keyof(value2) {
  return value2 !== null && typeof value2 === "object" ? value2.valueOf() : value2;
}
function identity$5(x2) {
  return x2;
}
function compareDefined(compare = ascending) {
  if (compare === ascending)
    return ascendingDefined;
  if (typeof compare !== "function")
    throw new TypeError("compare is not a function");
  return (a, b) => {
    const x2 = compare(a, b);
    if (x2 || x2 === 0)
      return x2;
    return (compare(b, b) === 0) - (compare(a, a) === 0);
  };
}
function ascendingDefined(a, b) {
  return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
}
var array$2 = Array.prototype;
var slice$2 = array$2.slice;
function constant$6(x2) {
  return () => x2;
}
var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function ticks(start2, stop, count2) {
  var reverse, i = -1, n, ticks2, step;
  stop = +stop, start2 = +start2, count2 = +count2;
  if (start2 === stop && count2 > 0)
    return [start2];
  if (reverse = stop < start2)
    n = start2, start2 = stop, stop = n;
  if ((step = tickIncrement(start2, stop, count2)) === 0 || !isFinite(step))
    return [];
  if (step > 0) {
    let r0 = Math.round(start2 / step), r1 = Math.round(stop / step);
    if (r0 * step < start2)
      ++r0;
    if (r1 * step > stop)
      --r1;
    ticks2 = new Array(n = r1 - r0 + 1);
    while (++i < n)
      ticks2[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.round(start2 * step), r1 = Math.round(stop * step);
    if (r0 / step < start2)
      ++r0;
    if (r1 / step > stop)
      --r1;
    ticks2 = new Array(n = r1 - r0 + 1);
    while (++i < n)
      ticks2[i] = (r0 + i) / step;
  }
  if (reverse)
    ticks2.reverse();
  return ticks2;
}
function tickIncrement(start2, stop, count2) {
  var step = (stop - start2) / Math.max(0, count2), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}
function tickStep(start2, stop, count2) {
  var step0 = Math.abs(stop - start2) / Math.max(0, count2), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
  if (error >= e10)
    step1 *= 10;
  else if (error >= e5)
    step1 *= 5;
  else if (error >= e2)
    step1 *= 2;
  return stop < start2 ? -step1 : step1;
}
function nice$1(start2, stop, count2) {
  let prestep;
  while (true) {
    const step = tickIncrement(start2, stop, count2);
    if (step === prestep || step === 0 || !isFinite(step)) {
      return [start2, stop];
    } else if (step > 0) {
      start2 = Math.floor(start2 / step) * step;
      stop = Math.ceil(stop / step) * step;
    } else if (step < 0) {
      start2 = Math.ceil(start2 * step) / step;
      stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}
function thresholdSturges(values) {
  return Math.ceil(Math.log(count$1(values)) / Math.LN2) + 1;
}
function bin() {
  var value2 = identity$5, domain = extent, threshold = thresholdSturges;
  function histogram2(data) {
    if (!Array.isArray(data))
      data = Array.from(data);
    var i, n = data.length, x2, values = new Array(n);
    for (i = 0; i < n; ++i) {
      values[i] = value2(data[i], i, data);
    }
    var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold(values, x0, x1);
    if (!Array.isArray(tz)) {
      const max2 = x1, tn = +tz;
      if (domain === extent)
        [x0, x1] = nice$1(x0, x1, tn);
      tz = ticks(x0, x1, tn);
      if (tz[tz.length - 1] >= x1) {
        if (max2 >= x1 && domain === extent) {
          const step = tickIncrement(x0, x1, tn);
          if (isFinite(step)) {
            if (step > 0) {
              x1 = (Math.floor(x1 / step) + 1) * step;
            } else if (step < 0) {
              x1 = (Math.ceil(x1 * -step) + 1) / -step;
            }
          }
        } else {
          tz.pop();
        }
      }
    }
    var m = tz.length;
    while (tz[0] <= x0)
      tz.shift(), --m;
    while (tz[m - 1] > x1)
      tz.pop(), --m;
    var bins = new Array(m + 1), bin2;
    for (i = 0; i <= m; ++i) {
      bin2 = bins[i] = [];
      bin2.x0 = i > 0 ? tz[i - 1] : x0;
      bin2.x1 = i < m ? tz[i] : x1;
    }
    for (i = 0; i < n; ++i) {
      x2 = values[i];
      if (x2 != null && x0 <= x2 && x2 <= x1) {
        bins[bisect(tz, x2, 0, m)].push(data[i]);
      }
    }
    return bins;
  }
  histogram2.value = function(_) {
    return arguments.length ? (value2 = typeof _ === "function" ? _ : constant$6(_), histogram2) : value2;
  };
  histogram2.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant$6([_[0], _[1]]), histogram2) : domain;
  };
  histogram2.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$6(slice$2.call(_)) : constant$6(_), histogram2) : threshold;
  };
  return histogram2;
}
function max$3(values, valueof) {
  let max2;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
        max2 = value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index2, values)) != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
        max2 = value2;
      }
    }
  }
  return max2;
}
function min$3(values, valueof) {
  let min2;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
        min2 = value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index2, values)) != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
        min2 = value2;
      }
    }
  }
  return min2;
}
function quickselect(array2, k, left2 = 0, right2 = array2.length - 1, compare) {
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      const n = right2 - left2 + 1;
      const m = k - left2 + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left2, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right2, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array2, k, newLeft, newRight, compare);
    }
    const t = array2[k];
    let i = left2;
    let j = right2;
    swap(array2, left2, k);
    if (compare(array2[right2], t) > 0)
      swap(array2, left2, right2);
    while (i < j) {
      swap(array2, i, j), ++i, --j;
      while (compare(array2[i], t) < 0)
        ++i;
      while (compare(array2[j], t) > 0)
        --j;
    }
    if (compare(array2[left2], t) === 0)
      swap(array2, left2, j);
    else
      ++j, swap(array2, j, right2);
    if (j <= k)
      left2 = j + 1;
    if (k <= j)
      right2 = j - 1;
  }
  return array2;
}
function swap(array2, i, j) {
  const t = array2[i];
  array2[i] = array2[j];
  array2[j] = t;
}
function quantile(values, p, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n = values.length))
    return;
  if ((p = +p) <= 0 || n < 2)
    return min$3(values);
  if (p >= 1)
    return max$3(values);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max$3(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min$3(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function range(start2, stop, step) {
  start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range2 = new Array(n);
  while (++i < n) {
    range2[i] = start2 + i * step;
  }
  return range2;
}
function initRange(domain, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range2).domain(domain);
      break;
  }
  return this;
}
const implicit = Symbol("implicit");
function ordinal() {
  var index2 = new InternMap(), domain = [], range2 = [], unknown = implicit;
  function scale(d) {
    let i = index2.get(d);
    if (i === void 0) {
      if (unknown !== implicit)
        return unknown;
      index2.set(d, i = domain.push(d) - 1);
    }
    return range2[i % range2.length];
  }
  scale.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index2 = new InternMap();
    for (const value2 of _) {
      if (index2.has(value2))
        continue;
      index2.set(value2, domain.push(value2) - 1);
    }
    return scale;
  };
  scale.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), scale) : range2.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range2).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}
function band() {
  var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale.unknown;
  function rescale() {
    var n = domain().length, reverse = r1 < r0, start2 = reverse ? r1 : r0, stop = reverse ? r0 : r1;
    step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round)
      step = Math.floor(step);
    start2 += (stop - start2 - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round)
      start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
    var values = range(n).map(function(i) {
      return start2 + step * i;
    });
    return ordinalRange(reverse ? values.reverse() : values);
  }
  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };
  scale.bandwidth = function() {
    return bandwidth;
  };
  scale.step = function() {
    return step;
  };
  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };
  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };
  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };
  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };
  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };
  scale.copy = function() {
    return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"), reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"), reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"), reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"), reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"), reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a = this.opacity;
  a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}
function hex(value2) {
  value2 = Math.max(0, Math.min(255, Math.round(value2) || 0));
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0)
    h = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s = NaN;
  else if (s <= 0)
    h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s = max2 - min2, l = (max2 + min2) / 2;
  if (s) {
    if (r === max2)
      h = (g - b) / s + (g < b) * 6;
    else if (g === max2)
      h = (b - r) / s + 2;
    else
      h = (r - g) / s + 4;
    s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
  }
}));
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
var constant$5 = (x2) => () => x2;
function linear$1(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y2) {
  return a = Math.pow(a, y2), b = Math.pow(b, y2) - a, y2 = 1 / y2, function(t) {
    return Math.pow(a + t * b, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y2) : constant$5(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear$1(a, d) : constant$5(isNaN(a) ? b : a);
}
var interpolateRgb = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb$1(start2, end) {
    var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb$1.gamma = rgbGamma;
  return rgb$1;
}(1);
function numberArray(a, b) {
  if (!b)
    b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x2 = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x2[i] = interpolate$1(a[i], b[i]);
  for (; i < nb; ++i)
    c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c[i] = x2[i](t);
    return c;
  };
}
function date$1(a, b) {
  var d = new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}
function interpolateNumber(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}
function object(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k in b) {
    if (k in a) {
      i[k] = interpolate$1(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i)
      c[k] = i[k](t);
    return c;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function interpolateString(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: interpolateNumber(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}
function interpolate$1(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant$5(b) : (t === "number" ? interpolateNumber : t === "string" ? (c = color(b)) ? (b = c, interpolateRgb) : interpolateString : b instanceof color ? interpolateRgb : b instanceof Date ? date$1 : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a, b);
}
function interpolateRound(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}
var degrees = 180 / Math.PI;
var identity$4 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b))
    a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d)
    c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d))
    c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c)
    a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}
var svgNode;
function parseCss(value2) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value2 + "");
  return m.isIdentity ? identity$4 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value2) {
  if (value2 == null)
    return identity$4;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value2);
  if (!(value2 = svgNode.transform.baseVal.consolidate()))
    return identity$4;
  value2 = value2.matrix;
  return decompose(value2.a, value2.b, value2.c, value2.d, value2.e, value2.f);
}
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180)
        b += 360;
      else if (b - a > 180)
        a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
function quantize$1(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i)
    samples[i] = interpolator(i / (n - 1));
  return samples;
}
function constants(x2) {
  return function() {
    return x2;
  };
}
function number$2(x2) {
  return +x2;
}
var unit = [0, 1];
function identity$3(x2) {
  return x2;
}
function normalize(a, b) {
  return (b -= a = +a) ? function(x2) {
    return (x2 - a) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a, b) {
  var t;
  if (a > b)
    t = a, a = b, b = t;
  return function(x2) {
    return Math.max(a, Math.min(b, x2));
  };
}
function bimap(domain, range2, interpolate2) {
  var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate2(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate2(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap(domain, range2, interpolate2) {
  var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate2(range2[i], range2[i + 1]);
  }
  return function(x2) {
    var i2 = bisect(domain, x2, 1, j) - 1;
    return r[i2](d[i2](x2));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range2 = unit, interpolate2 = interpolate$1, transform, untransform, unknown, clamp2 = identity$3, piecewise, output, input;
  function rescale() {
    var n = Math.min(domain.length, range2.length);
    if (clamp2 !== identity$3)
      clamp2 = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise(domain.map(transform), range2, interpolate2)))(transform(clamp2(x2)));
  }
  scale.invert = function(y2) {
    return clamp2(untransform((input || (input = piecewise(range2, domain.map(transform), interpolateNumber)))(y2)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number$2), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
  };
  scale.rangeRound = function(_) {
    return range2 = Array.from(_), interpolate2 = interpolateRound, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp2 = _ ? true : identity$3, rescale()) : clamp2 !== identity$3;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate2 = _, rescale()) : interpolate2;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity$3, identity$3);
}
function formatDecimal(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p) {
  if ((i = (x2 = p ? x2.toExponential(p - 1) : x2.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x2.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i + 1)
  ];
}
function exponent(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value2, width) {
    var i = value2.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width)
        g = Math.max(1, width - length);
      t.push(value2.substring(i -= g, i + g));
      if ((length += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value2) {
    return value2.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match2 = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match2;
  return new FormatSpecifier({
    fill: match2[1],
    align: match2[2],
    sign: match2[3],
    symbol: match2[4],
    zero: match2[5],
    width: match2[6],
    comma: match2[7],
    precision: match2[8] && match2[8].slice(1),
    trim: match2[9],
    type: match2[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s) {
  out:
    for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}
var prefixExponent;
function formatPrefixAuto(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d)
    return x2 + "";
  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p + i - 1))[0];
}
function formatRounded(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d)
    return x2 + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
var formatTypes = {
  "%": (x2, p) => (x2 * 100).toFixed(p),
  "b": (x2) => Math.round(x2).toString(2),
  "c": (x2) => x2 + "",
  "d": formatDecimal,
  "e": (x2, p) => x2.toExponential(p),
  "f": (x2, p) => x2.toFixed(p),
  "g": (x2, p) => x2.toPrecision(p),
  "o": (x2) => Math.round(x2).toString(8),
  "p": (x2, p) => formatRounded(x2 * 100, p),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
  "x": (x2) => Math.round(x2).toString(16)
};
function identity$2(x2) {
  return x2;
}
var map = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale$1(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$2 : formatGroup(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$2 : formatNumerals(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes[type2])
      precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero2 || fill === "0" && align === "=")
      zero2 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value2) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
      if (type2 === "c") {
        valueSuffix = formatType(value2) + valueSuffix;
        value2 = "";
      } else {
        value2 = +value2;
        var valueNegative = value2 < 0 || 1 / value2 < 0;
        value2 = isNaN(value2) ? nan : formatType(Math.abs(value2), precision);
        if (trim)
          value2 = formatTrim(value2);
        if (valueNegative && +value2 === 0 && sign2 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value2.length;
          while (++i < n) {
            if (c = value2.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value2.slice(i + 1) : value2.slice(i)) + valueSuffix;
              value2 = value2.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2)
        value2 = group(value2, Infinity);
      var length = valuePrefix.length + value2.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2)
        value2 = group(padding + value2, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value2 = valuePrefix + value2 + valueSuffix + padding;
          break;
        case "=":
          value2 = valuePrefix + padding + value2 + valueSuffix;
          break;
        case "^":
          value2 = padding.slice(0, length = padding.length >> 1) + valuePrefix + value2 + valueSuffix + padding.slice(length);
          break;
        default:
          value2 = padding + valuePrefix + value2 + valueSuffix;
          break;
      }
      return numerals(value2);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value2) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value2) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value3) {
      return f(k * value3) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale$2;
var format$1;
var formatPrefix;
defaultLocale$2({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale$2(definition) {
  locale$2 = formatLocale$1(definition);
  format$1 = locale$2.format;
  formatPrefix = locale$2.formatPrefix;
  return locale$2;
}
function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}
function precisionPrefix(step, value2) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value2) / 3))) * 3 - exponent(Math.abs(step)));
}
function precisionRound(step, max2) {
  step = Math.abs(step), max2 = Math.abs(max2) - step;
  return Math.max(0, exponent(max2) - exponent(step)) + 1;
}
function tickFormat(start2, stop, count2, specifier) {
  var step = tickStep(start2, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value2 = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value2)))
        specifier.precision = precision;
      return formatPrefix(specifier, value2);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format$1(specifier);
}
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count2) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start2 = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count2);
      if (step === prestep) {
        d[i0] = start2;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}
function nice(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }
  domain[i0] = interval2.floor(x0);
  domain[i1] = interval2.ceil(x1);
  return domain;
}
function transformLog(x2) {
  return Math.log(x2);
}
function transformExp(x2) {
  return Math.exp(x2);
}
function transformLogn(x2) {
  return -Math.log(-x2);
}
function transformExpn(x2) {
  return -Math.exp(-x2);
}
function pow10(x2) {
  return isFinite(x2) ? +("1e" + x2) : x2 < 0 ? 0 : x2;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x2) => Math.pow(base, x2);
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x2) => Math.log(x2) / base);
}
function reflect(f) {
  return (x2, k) => -f(-x2, k);
}
function loggish(transform) {
  const scale = transform(transformLog, transformExp);
  const domain = scale.domain;
  let base = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }
  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };
  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.ticks = (count2) => {
    const d = domain();
    let u = d[0];
    let v = d[d.length - 1];
    const r = v < u;
    if (r)
      [u, v] = [v, u];
    let i = logs(u);
    let j = logs(v);
    let k;
    let t;
    const n = count2 == null ? 10 : +count2;
    let z = [];
    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0)
        for (; i <= j; ++i) {
          for (k = 1; k < base; ++k) {
            t = i < 0 ? k / pows(-i) : k * pows(i);
            if (t < u)
              continue;
            if (t > v)
              break;
            z.push(t);
          }
        }
      else
        for (; i <= j; ++i) {
          for (k = base - 1; k >= 1; --k) {
            t = i > 0 ? k / pows(-i) : k * pows(i);
            if (t < u)
              continue;
            if (t > v)
              break;
            z.push(t);
          }
        }
      if (z.length * 2 < n)
        z = ticks(u, v, n);
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };
  scale.tickFormat = (count2, specifier) => {
    if (count2 == null)
      count2 = 10;
    if (specifier == null)
      specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null)
        specifier.trim = true;
      specifier = format$1(specifier);
    }
    if (count2 === Infinity)
      return specifier;
    const k = Math.max(1, base * count2 / scale.ticks().length);
    return (d) => {
      let i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5)
        i *= base;
      return i <= k ? specifier(d) : "";
    };
  };
  scale.nice = () => {
    return domain(nice(domain(), {
      floor: (x2) => pows(Math.floor(logs(x2))),
      ceil: (x2) => pows(Math.ceil(logs(x2)))
    }));
  };
  return scale;
}
function log() {
  const scale = loggish(transformer()).domain([1, 10]);
  scale.copy = () => copy(scale, log()).base(scale.base());
  initRange.apply(scale, arguments);
  return scale;
}
function quantize() {
  var x0 = 0, x1 = 1, n = 1, domain = [0.5], range2 = [0, 1], unknown;
  function scale(x2) {
    return x2 != null && x2 <= x2 ? range2[bisect(domain, x2, 0, n)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n)
      domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }
  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };
  scale.range = function(_) {
    return arguments.length ? (n = (range2 = Array.from(_)).length - 1, rescale()) : range2.slice();
  };
  scale.invertExtent = function(y2) {
    var i = range2.indexOf(y2);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };
  scale.thresholds = function() {
    return domain.slice();
  };
  scale.copy = function() {
    return quantize().domain([x0, x1]).range(range2).unknown(unknown);
  };
  return initRange.apply(linearish(scale), arguments);
}
var t0 = new Date(), t1 = new Date();
function newInterval(floori, offseti, count2, field) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? new Date() : new Date(+date2)), date2;
  }
  interval2.floor = function(date2) {
    return floori(date2 = new Date(+date2)), date2;
  };
  interval2.ceil = function(date2) {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = function(date2) {
    var d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = function(date2, step) {
    return offseti(date2 = new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval2.range = function(start2, stop, step) {
    var range2 = [], previous;
    start2 = interval2.ceil(start2);
    step = step == null ? 1 : Math.floor(step);
    if (!(start2 < stop) || !(step > 0))
      return range2;
    do
      range2.push(previous = new Date(+start2)), offseti(start2, step), floori(start2);
    while (previous < start2 && start2 < stop);
    return range2;
  };
  interval2.filter = function(test) {
    return newInterval(function(date2) {
      if (date2 >= date2)
        while (floori(date2), !test(date2))
          date2.setTime(date2 - 1);
    }, function(date2, step) {
      if (date2 >= date2) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
      }
    });
  };
  if (count2) {
    interval2.count = function(start2, end) {
      t0.setTime(+start2), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count2(t0, t1));
    };
    interval2.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field ? function(d) {
        return field(d) % step === 0;
      } : function(d) {
        return interval2.count(0, d) % step === 0;
      });
    };
  }
  return interval2;
}
var millisecond = newInterval(function() {
}, function(date2, step) {
  date2.setTime(+date2 + step);
}, function(start2, end) {
  return end - start2;
});
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0))
    return null;
  if (!(k > 1))
    return millisecond;
  return newInterval(function(date2) {
    date2.setTime(Math.floor(date2 / k) * k);
  }, function(date2, step) {
    date2.setTime(+date2 + step * k);
  }, function(start2, end) {
    return (end - start2) / k;
  });
};
var millisecond$1 = millisecond;
const durationSecond = 1e3;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;
var second = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds());
}, function(date2, step) {
  date2.setTime(+date2 + step * durationSecond);
}, function(start2, end) {
  return (end - start2) / durationSecond;
}, function(date2) {
  return date2.getUTCSeconds();
});
var utcSecond = second;
var minute = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute);
}, function(start2, end) {
  return (end - start2) / durationMinute;
}, function(date2) {
  return date2.getMinutes();
});
var timeMinute = minute;
var hour = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour);
}, function(start2, end) {
  return (end - start2) / durationHour;
}, function(date2) {
  return date2.getHours();
});
var timeHour = hour;
var day = newInterval((date2) => date2.setHours(0, 0, 0, 0), (date2, step) => date2.setDate(date2.getDate() + step), (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay, (date2) => date2.getDate() - 1);
var timeDay = day;
function weekday(i) {
  return newInterval(function(date2) {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setDate(date2.getDate() + step * 7);
  }, function(start2, end) {
    return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var sunday = weekday(0);
var monday = weekday(1);
weekday(2);
weekday(3);
var thursday = weekday(4);
weekday(5);
weekday(6);
var month = newInterval(function(date2) {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setMonth(date2.getMonth() + step);
}, function(start2, end) {
  return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
}, function(date2) {
  return date2.getMonth();
});
var timeMonth = month;
var year = newInterval(function(date2) {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setFullYear(date2.getFullYear() + step);
}, function(start2, end) {
  return end.getFullYear() - start2.getFullYear();
}, function(date2) {
  return date2.getFullYear();
});
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
    date2.setFullYear(Math.floor(date2.getFullYear() / k) * k);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setFullYear(date2.getFullYear() + step * k);
  });
};
var timeYear = year;
var utcMinute = newInterval(function(date2) {
  date2.setUTCSeconds(0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute);
}, function(start2, end) {
  return (end - start2) / durationMinute;
}, function(date2) {
  return date2.getUTCMinutes();
});
var utcMinute$1 = utcMinute;
var utcHour = newInterval(function(date2) {
  date2.setUTCMinutes(0, 0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour);
}, function(start2, end) {
  return (end - start2) / durationHour;
}, function(date2) {
  return date2.getUTCHours();
});
var utcHour$1 = utcHour;
var utcDay = newInterval(function(date2) {
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCDate(date2.getUTCDate() + step);
}, function(start2, end) {
  return (end - start2) / durationDay;
}, function(date2) {
  return date2.getUTCDate() - 1;
});
var utcDay$1 = utcDay;
function utcWeekday(i) {
  return newInterval(function(date2) {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, function(start2, end) {
    return (end - start2) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
utcWeekday(2);
utcWeekday(3);
var utcThursday = utcWeekday(4);
utcWeekday(5);
utcWeekday(6);
var utcMonth = newInterval(function(date2) {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, function(start2, end) {
  return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
}, function(date2) {
  return date2.getUTCMonth();
});
var utcMonth$1 = utcMonth;
var utcYear = newInterval(function(date2) {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, function(start2, end) {
  return end.getUTCFullYear() - start2.getUTCFullYear();
}, function(date2) {
  return date2.getUTCFullYear();
});
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k) * k);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k);
  });
};
var utcYear$1 = utcYear;
function ticker(year2, month2, week, day2, hour2, minute2) {
  const tickIntervals = [
    [utcSecond, 1, durationSecond],
    [utcSecond, 5, 5 * durationSecond],
    [utcSecond, 15, 15 * durationSecond],
    [utcSecond, 30, 30 * durationSecond],
    [minute2, 1, durationMinute],
    [minute2, 5, 5 * durationMinute],
    [minute2, 15, 15 * durationMinute],
    [minute2, 30, 30 * durationMinute],
    [hour2, 1, durationHour],
    [hour2, 3, 3 * durationHour],
    [hour2, 6, 6 * durationHour],
    [hour2, 12, 12 * durationHour],
    [day2, 1, durationDay],
    [day2, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month2, 1, durationMonth],
    [month2, 3, 3 * durationMonth],
    [year2, 1, durationYear]
  ];
  function ticks2(start2, stop, count2) {
    const reverse = stop < start2;
    if (reverse)
      [start2, stop] = [stop, start2];
    const interval2 = count2 && typeof count2.range === "function" ? count2 : tickInterval(start2, stop, count2);
    const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
    return reverse ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start2, stop, count2) {
    const target = Math.abs(stop - start2) / count2;
    const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i === tickIntervals.length)
      return year2.every(tickStep(start2 / durationYear, stop / durationYear, count2));
    if (i === 0)
      return millisecond$1.every(Math.max(tickStep(start2, stop, count2), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }
  return [ticks2, tickInterval];
}
ticker(utcYear$1, utcMonth$1, utcSunday, utcDay$1, utcHour$1, utcMinute$1);
const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, sunday, timeDay, timeHour, timeMinute);
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y2, m, d) {
  return { y: y2, m, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale2) {
  var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string = [], i = -1, j = 0, n = specifier.length, c, pad2, format2;
      if (!(date2 instanceof Date))
        date2 = new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad2 = pads[c = specifier.charAt(++i)]) != null)
            c = specifier.charAt(++i);
          else
            pad2 = c === "e" ? " " : "0";
          if (format2 = formats2[c])
            c = format2(date2, pad2);
          string.push(c);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day2;
      if (i != string.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day2 = week.getUTCDay();
          week = day2 > 4 || day2 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay$1.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day2 = week.getDay();
          week = day2 > 4 || day2 === 0 ? monday.ceil(week) : monday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day2 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m = string.length, c, parse;
    while (i < n) {
      if (j >= m)
        return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || (j = parse(d, string, j)) < 0)
          return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value2, fill, width) {
  var sign2 = value2 < 0 ? "-" : "", string = (sign2 ? -value2 : value2) + "", length = string.length;
  return sign2 + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}
function requote(s) {
  return s.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(thursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad(monday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay$1.count(utcYear$1(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear$1(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear$1(d), d) + (utcYear$1(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear$1(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}
var locale$1;
var timeFormat;
defaultLocale$1({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale$1(definition) {
  locale$1 = formatLocale(definition);
  timeFormat = locale$1.format;
  return locale$1;
}
function date(t) {
  return new Date(t);
}
function number$1(t) {
  return t instanceof Date ? +t : +new Date(+t);
}
function calendar(ticks2, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format2) {
  var scale = continuous(), invert = scale.invert, domain = scale.domain;
  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute2(date2) < date2 ? formatSecond : hour2(date2) < date2 ? formatMinute : day2(date2) < date2 ? formatHour : month2(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year2(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  scale.invert = function(y2) {
    return new Date(invert(y2));
  };
  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number$1)) : domain().map(date);
  };
  scale.ticks = function(interval2) {
    var d = domain();
    return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
  };
  scale.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat2 : format2(specifier);
  };
  scale.nice = function(interval2) {
    var d = domain();
    if (!interval2 || typeof interval2.range !== "function")
      interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain(nice(d, interval2)) : scale;
  };
  scale.copy = function() {
    return copy(scale, calendar(ticks2, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format2));
  };
  return scale;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, sunday, timeDay, timeHour, timeMinute, utcSecond, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
const pi$2 = Math.PI, tau$2 = 2 * pi$2, epsilon$3 = 1e-6, tauEpsilon$1 = tau$2 - epsilon$3;
function Path$1() {
  this._x0 = this._y0 = this._x1 = this._y1 = null;
  this._ = "";
}
function path$1() {
  return new Path$1();
}
Path$1.prototype = path$1.prototype = {
  constructor: Path$1,
  moveTo: function(x2, y2) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x2, y2) {
    this._ += "L" + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  quadraticCurveTo: function(x1, y1, x2, y2) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else if (!(l01_2 > epsilon$3))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$3) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else {
      var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon$3) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }
      this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw2 = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    } else if (Math.abs(this._x1 - x0) > epsilon$3 || Math.abs(this._y1 - y0) > epsilon$3) {
      this._ += "L" + x0 + "," + y0;
    }
    if (!r)
      return;
    if (da < 0)
      da = da % tau$2 + tau$2;
    if (da > tauEpsilon$1) {
      this._ += "A" + r + "," + r + ",0,1," + cw2 + "," + (x2 - dx) + "," + (y2 - dy) + "A" + r + "," + r + ",0,1," + cw2 + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    } else if (da > epsilon$3) {
      this._ += "A" + r + "," + r + ",0," + +(da >= pi$2) + "," + cw2 + "," + (this._x1 = x2 + r * Math.cos(a1)) + "," + (this._y1 = y2 + r * Math.sin(a1));
    }
  },
  rect: function(x2, y2, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2) + "h" + +w + "v" + +h + "h" + -w + "Z";
  },
  toString: function() {
    return this._;
  }
};
function constant$4(x2) {
  return function constant2() {
    return x2;
  };
}
const abs$1 = Math.abs;
const atan2 = Math.atan2;
const cos = Math.cos;
const max$2 = Math.max;
const min$2 = Math.min;
const sin = Math.sin;
const sqrt = Math.sqrt;
const epsilon$2 = 1e-12;
const pi$1 = Math.PI;
const halfPi = pi$1 / 2;
const tau$1 = 2 * pi$1;
function acos(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi$1 : Math.acos(x2);
}
function asin(x2) {
  return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
}
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;
  if (t * t < epsilon$2)
    return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}
function cornerTangents(x0, y0, x1, y1, r1, rc, cw2) {
  var x01 = x0 - x1, y01 = y0 - y1, lo = (cw2 ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max$2(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant$4(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null;
  function arc2() {
    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs$1(a1 - a0), cw2 = a1 > a0;
    if (!context)
      context = buffer = path$1();
    if (r1 < r0)
      r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon$2))
      context.moveTo(0, 0);
    else if (da > tau$1 - epsilon$2) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw2);
      if (r0 > epsilon$2) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw2);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon$2 && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min$2(abs$1(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
      if (rp > epsilon$2) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon$2)
          p0 *= cw2 ? 1 : -1, a00 += p0, a10 -= p0;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon$2)
          p1 *= cw2 ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon$2) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;
        if (da < pi$1 && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
          var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min$2(rc, (r0 - lc) / (kc - 1));
          rc1 = min$2(rc, (r1 - lc) / (kc + 1));
        }
      }
      if (!(da1 > epsilon$2))
        context.moveTo(x01, y01);
      else if (rc1 > epsilon$2) {
        t02 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw2);
        t12 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw2);
        context.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc1 < rc)
          context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw2);
        else {
          context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw2);
          context.arc(0, 0, r1, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), !cw2);
          context.arc(t12.cx, t12.cy, rc1, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw2);
        }
      } else
        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw2);
      if (!(r0 > epsilon$2) || !(da0 > epsilon$2))
        context.lineTo(x10, y10);
      else if (rc0 > epsilon$2) {
        t02 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw2);
        t12 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw2);
        context.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc0 < rc)
          context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw2);
        else {
          context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw2);
          context.arc(0, 0, r0, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), cw2);
          context.arc(t12.cx, t12.cy, rc0, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw2);
        }
      } else
        context.arc(0, 0, r0, a10, a00, cw2);
    }
    context.closePath();
    if (buffer)
      return context = null, buffer + "" || null;
  }
  arc2.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$1 / 2;
    return [cos(a) * r, sin(a) * r];
  };
  arc2.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$4(+_), arc2) : innerRadius;
  };
  arc2.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$4(+_), arc2) : outerRadius;
  };
  arc2.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$4(+_), arc2) : cornerRadius;
  };
  arc2.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$4(+_), arc2) : padRadius;
  };
  arc2.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$4(+_), arc2) : startAngle;
  };
  arc2.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$4(+_), arc2) : endAngle;
  };
  arc2.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$4(+_), arc2) : padAngle;
  };
  arc2.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, arc2) : context;
  };
  return arc2;
}
var slice$1 = Array.prototype.slice;
function array$1(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function curveLinear(context) {
  return new Linear(context);
}
function x$1(p) {
  return p[0];
}
function y$1(p) {
  return p[1];
}
function line(x2, y2) {
  var defined = constant$4(true), context = null, curve = curveLinear, output = null;
  x2 = typeof x2 === "function" ? x2 : x2 === void 0 ? x$1 : constant$4(x2);
  y2 = typeof y2 === "function" ? y2 : y2 === void 0 ? y$1 : constant$4(y2);
  function line2(data) {
    var i, n = (data = array$1(data)).length, d, defined0 = false, buffer;
    if (context == null)
      output = curve(buffer = path$1());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x2(d, i, data), +y2(d, i, data));
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  line2.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant$4(+_), line2) : x2;
  };
  line2.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant$4(+_), line2) : y2;
  };
  line2.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$4(!!_), line2) : defined;
  };
  line2.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line2) : curve;
  };
  line2.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line2) : context;
  };
  return line2;
}
function area(x0, y0, y1) {
  var x1 = null, defined = constant$4(true), context = null, curve = curveLinear, output = null;
  x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x$1 : constant$4(+x0);
  y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant$4(0) : constant$4(+y0);
  y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y$1 : constant$4(+y1);
  function area2(data) {
    var i, j, k, n = (data = array$1(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null)
      output = curve(buffer = path$1());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }
  area2.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$4(+_), x1 = null, area2) : x0;
  };
  area2.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$4(+_), area2) : x0;
  };
  area2.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$4(+_), area2) : x1;
  };
  area2.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$4(+_), y1 = null, area2) : y0;
  };
  area2.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$4(+_), area2) : y0;
  };
  area2.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$4(+_), area2) : y1;
  };
  area2.lineX0 = area2.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };
  area2.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };
  area2.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };
  area2.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$4(!!_), area2) : defined;
  };
  area2.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area2) : curve;
  };
  area2.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area2) : context;
  };
  return area2;
}
function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}
function identity$1(d) {
  return d;
}
function pie() {
  var value2 = identity$1, sortValues = descending, sort = null, startAngle = constant$4(0), endAngle = constant$4(tau$1), padAngle = constant$4(0);
  function pie2(data) {
    var i, n = (data = array$1(data)).length, j, k, sum2 = 0, index2 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau$1, Math.max(-tau$1, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
    for (i = 0; i < n; ++i) {
      if ((v = arcs[index2[i] = i] = +value2(data[i], i, data)) > 0) {
        sum2 += v;
      }
    }
    if (sortValues != null)
      index2.sort(function(i2, j2) {
        return sortValues(arcs[i2], arcs[j2]);
      });
    else if (sort != null)
      index2.sort(function(i2, j2) {
        return sort(data[i2], data[j2]);
      });
    for (i = 0, k = sum2 ? (da - n * pa) / sum2 : 0; i < n; ++i, a0 = a1) {
      j = index2[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }
    return arcs;
  }
  pie2.value = function(_) {
    return arguments.length ? (value2 = typeof _ === "function" ? _ : constant$4(+_), pie2) : value2;
  };
  pie2.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie2) : sortValues;
  };
  pie2.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie2) : sort;
  };
  pie2.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$4(+_), pie2) : startAngle;
  };
  pie2.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$4(+_), pie2) : endAngle;
  };
  pie2.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$4(+_), pie2) : padAngle;
  };
  return pie2;
}
var curveRadialLinear = curveRadial(curveLinear);
function Radial(curve) {
  this._curve = curve;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};
function curveRadial(curve) {
  function radial(context) {
    return new Radial(curve(context));
  }
  radial._curve = curve;
  return radial;
}
function lineRadial(l) {
  var c = l.curve;
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  l.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };
  return l;
}
function lineRadial$1() {
  return lineRadial(line().curve(curveRadialLinear));
}
class Bump {
  constructor(context, x2) {
    this._context = context;
    this._x = x2;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line)
          this._context.lineTo(x2, y2);
        else
          this._context.moveTo(x2, y2);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        if (this._x)
          this._context.bezierCurveTo(this._x0 = (this._x0 + x2) / 2, this._y0, this._x0, y2, x2, y2);
        else
          this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y2) / 2, x2, this._y0, x2, y2);
        break;
      }
    }
    this._x0 = x2, this._y0 = y2;
  }
}
function bumpX(context) {
  return new Bump(context, true);
}
function linkSource$1(d) {
  return d.source;
}
function linkTarget$1(d) {
  return d.target;
}
function link$1(curve) {
  let source = linkSource$1;
  let target = linkTarget$1;
  let x2 = x$1;
  let y2 = y$1;
  let context = null;
  let output = null;
  function link2() {
    let buffer;
    const argv = slice$1.call(arguments);
    const s = source.apply(this, argv);
    const t = target.apply(this, argv);
    if (context == null)
      output = curve(buffer = path$1());
    output.lineStart();
    argv[0] = s, output.point(+x2.apply(this, argv), +y2.apply(this, argv));
    argv[0] = t, output.point(+x2.apply(this, argv), +y2.apply(this, argv));
    output.lineEnd();
    if (buffer)
      return output = null, buffer + "" || null;
  }
  link2.source = function(_) {
    return arguments.length ? (source = _, link2) : source;
  };
  link2.target = function(_) {
    return arguments.length ? (target = _, link2) : target;
  };
  link2.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant$4(+_), link2) : x2;
  };
  link2.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant$4(+_), link2) : y2;
  };
  link2.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link2) : context;
  };
  return link2;
}
function linkHorizontal$1() {
  return link$1(bumpX);
}
function noop$2() {
}
function point$3(that, x2, y2) {
  that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x2) / 6, (that._y0 + 4 * that._y1 + y2) / 6);
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point$3(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point$3(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasis(context) {
  return new Basis(context);
}
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y2;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y2;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y2;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
        break;
      default:
        point$3(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasisClosed(context) {
  return new BasisClosed(context);
}
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
        this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
        break;
      case 3:
        this._point = 4;
      default:
        point$3(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasisOpen(context) {
  return new BasisOpen(context);
}
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, j = x2.length - 1;
    if (j > 0) {
      var x0 = x2[0], y0 = y2[0], dx = x2[j] - x0, dy = y2[j] - y0, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(this._beta * x2[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y2[i] + (1 - this._beta) * (y0 + t * dy));
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
var curveBundle = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);
function point$2(that, x2, y2) {
  that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x2), that._y2 + that._k * (that._y1 - y2), that._x2, that._y2);
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point$2(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        this._x1 = x2, this._y1 = y2;
        break;
      case 2:
        this._point = 3;
      default:
        point$2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var curveCardinal = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point$2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var curveCardinalClosed = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point$2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var curveCardinalOpen = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);
function point$1(that, x2, y2) {
  var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon$2) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon$2) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m;
    y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m;
  }
  that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point$1(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var curveCatmullRom = function custom5(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point$1(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var curveCatmullRomClosed = function custom6(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point$1(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var curveCatmullRomOpen = function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point)
      this._context.lineTo(x2, y2);
    else
      this._point = 1, this._context.moveTo(x2, y2);
  }
};
function curveLinearClosed(context) {
  return new LinearClosed(context);
}
function sign(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point(that, t02, t12) {
  var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t02, x1 - dx, y1 - dx * t12, x1, y1);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    var t12 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point(this, slope2(this, t12 = slope3(this, x2, y2)), t12);
        break;
      default:
        point(this, this._t0, t12 = slope3(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t12;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
  MonotoneX.prototype.point.call(this, y2, x2);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, n = x2.length;
    if (n) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        var px = controlPoints(x2), py = controlPoints(y2);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints(x2) {
  var i, n = x2.length - 1, m, a = new Array(n), b = new Array(n), r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n - 1; ++i)
    a[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
  for (i = 1; i < n; ++i)
    m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i)
    a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x2[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b[i] = 2 * x2[i + 1] - a[i + 1];
  return [a, b];
}
function curveNatural(context) {
  return new Natural(context);
}
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          var x1 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};
function curveStep(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}
function none$1(series, order) {
  if (!((n = series.length) > 1))
    return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}
function none(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0)
    o[n] = n;
  return o;
}
function stackValue(d, key) {
  return d[key];
}
function stackSeries(key) {
  const series = [];
  series.key = key;
  return series;
}
function stack() {
  var keys2 = constant$4([]), order = none, offset = none$1, value2 = stackValue;
  function stack2(data) {
    var sz = Array.from(keys2.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
    for (const d of data) {
      for (i = 0, ++j; i < n; ++i) {
        (sz[i][j] = [0, +value2(d, sz[i].key, j, data)]).data = d;
      }
    }
    for (i = 0, oz = array$1(order(sz)); i < n; ++i) {
      sz[oz[i]].index = i;
    }
    offset(sz, oz);
    return sz;
  }
  stack2.keys = function(_) {
    return arguments.length ? (keys2 = typeof _ === "function" ? _ : constant$4(Array.from(_)), stack2) : keys2;
  };
  stack2.value = function(_) {
    return arguments.length ? (value2 = typeof _ === "function" ? _ : constant$4(+_), stack2) : value2;
  };
  stack2.order = function(_) {
    return arguments.length ? (order = _ == null ? none : typeof _ === "function" ? _ : constant$4(Array.from(_)), stack2) : order;
  };
  stack2.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none$1 : _, stack2) : offset;
  };
  return stack2;
}
function stackOffsetDiverging(series, order) {
  if (!((n = series.length) > 0))
    return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
}
var __assign$3 = globalThis && globalThis.__assign || function() {
  __assign$3 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$3.apply(this, arguments);
};
var ChartModel = function() {
  function ChartModel2(services) {
    this.state = {
      options: {}
    };
    this.colorScale = {};
    this.colorClassNames = {};
    this.services = services;
  }
  ChartModel2.prototype.getAllDataFromDomain = function(groups) {
    if (!this.getData()) {
      return null;
    }
    var options2 = this.getOptions();
    var allData = this.getData();
    var dataGroups = this.getDataGroups();
    var groupMapsTo = Tools.getProperty(options2, "data").groupMapsTo;
    var axesOptions = Tools.getProperty(options2, "axes");
    if (groups) {
      allData = allData.filter(function(item) {
        return groups.includes(item[groupMapsTo]);
      });
    }
    if (axesOptions) {
      Object.keys(axesOptions).forEach(function(axis2) {
        var mapsTo = axesOptions[axis2].mapsTo;
        var scaleType = axesOptions[axis2].scaleType;
        if (scaleType === ScaleTypes.LINEAR || scaleType === ScaleTypes.LOG) {
          allData = allData.map(function(datum2) {
            var _a3;
            return __assign$3(__assign$3({}, datum2), (_a3 = {}, _a3[mapsTo] = datum2[mapsTo] === null ? datum2[mapsTo] : Number(datum2[mapsTo]), _a3));
          });
        }
        if (mapsTo && axesOptions[axis2].domain) {
          if (scaleType === ScaleTypes.LABELS) {
            allData = allData.filter(function(datum2) {
              return axesOptions[axis2].domain.includes(datum2[mapsTo]);
            });
          } else {
            var _a2 = axesOptions[axis2].domain, start_1 = _a2[0], end_1 = _a2[1];
            allData = allData.filter(function(datum2) {
              return !(mapsTo in datum2) || datum2[mapsTo] >= start_1 && datum2[mapsTo] <= end_1;
            });
          }
        }
      });
    }
    return allData.filter(function(datum2) {
      return dataGroups.find(function(group) {
        return group.name === datum2[groupMapsTo];
      });
    });
  };
  ChartModel2.prototype.getDisplayData = function(groups) {
    if (!this.get("data")) {
      return null;
    }
    var ACTIVE = legend$1.items.status.ACTIVE;
    var dataGroups = this.getDataGroups(groups);
    var groupMapsTo = this.getOptions().data.groupMapsTo;
    var allDataFromDomain = this.getAllDataFromDomain(groups);
    return allDataFromDomain.filter(function(datum2) {
      return dataGroups.find(function(dataGroup) {
        return dataGroup.name === datum2[groupMapsTo] && dataGroup.status === ACTIVE;
      });
    });
  };
  ChartModel2.prototype.getData = function() {
    return this.get("data");
  };
  ChartModel2.prototype.isDataEmpty = function() {
    return !this.getData().length;
  };
  ChartModel2.prototype.setData = function(newData) {
    var sanitizedData = this.sanitize(Tools.clone(newData));
    var dataGroups = this.generateDataGroups(sanitizedData);
    this.set({
      data: sanitizedData,
      dataGroups
    });
    return sanitizedData;
  };
  ChartModel2.prototype.getDataGroups = function(groups) {
    var isDataLoading = Tools.getProperty(this.getOptions(), "data", "loading");
    if (isDataLoading) {
      return [];
    }
    if (groups) {
      return this.get("dataGroups").filter(function(dataGroup) {
        return groups.includes(dataGroup.name);
      });
    }
    return this.get("dataGroups");
  };
  ChartModel2.prototype.getActiveDataGroups = function(groups) {
    var ACTIVE = legend$1.items.status.ACTIVE;
    return this.getDataGroups(groups).filter(function(dataGroup) {
      return dataGroup.status === ACTIVE;
    });
  };
  ChartModel2.prototype.getDataGroupNames = function(groups) {
    var dataGroups = this.getDataGroups(groups);
    return dataGroups.map(function(dataGroup) {
      return dataGroup.name;
    });
  };
  ChartModel2.prototype.getActiveDataGroupNames = function(groups) {
    var activeDataGroups = this.getActiveDataGroups(groups);
    return activeDataGroups.map(function(dataGroup) {
      return dataGroup.name;
    });
  };
  ChartModel2.prototype.aggregateBinDataByGroup = function(bin2) {
    return Tools.groupBy(bin2, "group");
  };
  ChartModel2.prototype.getBinConfigurations = function() {
    var _this = this;
    var data = this.getDisplayData();
    var options2 = this.getOptions();
    var mainXPos = this.services.cartesianScales.getMainXAxisPosition();
    var domainIdentifier = this.services.cartesianScales.getDomainIdentifier();
    var axisOptions = options2.axes[mainXPos];
    var groupMapsTo = options2.data.groupMapsTo;
    var _a2 = axisOptions.bins, axisBins = _a2 === void 0 ? histogram.defaultBins : _a2;
    var areBinsDefined = Array.isArray(axisBins);
    var bins = bin().value(function(d) {
      return d[domainIdentifier];
    }).thresholds(axisBins)(data);
    if (!areBinsDefined) {
      var binsWidth = bins[0].x1 - bins[0].x0;
      bins[bins.length - 1].x1 = +bins[bins.length - 1].x0 + binsWidth;
    } else {
      bins[bins.length - 1].x1 = axisBins[axisBins.length - 1];
    }
    var binsDomain = areBinsDefined ? [axisBins[0], axisBins[axisBins.length - 1]] : [bins[0].x0, bins[bins.length - 1].x1];
    var groupsKeys = Array.from(new Set(data.map(function(d) {
      return d[groupMapsTo];
    })));
    var histogramData = [];
    bins.forEach(function(bin2) {
      var key = bin2.x0 + "-" + bin2.x1;
      var aggregateDataByGroup = _this.aggregateBinDataByGroup(bin2);
      groupsKeys.forEach(function(group) {
        histogramData.push({
          group,
          key,
          value: aggregateDataByGroup[group] || 0,
          bin: bin2.x0
        });
      });
    });
    return {
      bins,
      binsDomain
    };
  };
  ChartModel2.prototype.getBinnedStackedData = function() {
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var dataGroupNames = this.getActiveDataGroupNames();
    var bins = this.getBinConfigurations().bins;
    var dataValuesGroupedByKeys = this.getDataValuesGroupedByKeys({
      bins
    });
    return stack().keys(dataGroupNames)(dataValuesGroupedByKeys).map(function(series, i) {
      return Object.keys(series).filter(function(key) {
        return !isNaN(key);
      }).map(function(key) {
        var element = series[key];
        element[groupMapsTo] = dataGroupNames[i];
        return element;
      });
    });
  };
  ChartModel2.prototype.getGroupedData = function(groups) {
    var displayData = this.getDisplayData(groups);
    var groupedData = {};
    var groupMapsTo = this.getOptions().data.groupMapsTo;
    displayData.map(function(datum2) {
      var group = datum2[groupMapsTo];
      if (groupedData[group] !== null && groupedData[group] !== void 0) {
        groupedData[group].push(datum2);
      } else {
        groupedData[group] = [datum2];
      }
    });
    return Object.keys(groupedData).map(function(groupName) {
      return {
        name: groupName,
        data: groupedData[groupName]
      };
    });
  };
  ChartModel2.prototype.getStackKeys = function(_a2) {
    var _this = this;
    var _b = _a2 === void 0 ? { bins: null, groups: null } : _a2, _c = _b.bins, bins = _c === void 0 ? null : _c, _d = _b.groups, groups = _d === void 0 ? null : _d;
    var options2 = this.getOptions();
    var displayData = this.getDisplayData(groups);
    var stackKeys;
    if (bins) {
      stackKeys = bins.map(function(bin2) {
        return bin2.x0 + "-" + bin2.x1;
      });
    } else {
      stackKeys = Tools.removeArrayDuplicates(displayData.map(function(datum2) {
        var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(datum2);
        return datum2[domainIdentifier] && typeof datum2[domainIdentifier].toString === "function" ? datum2[domainIdentifier].toString() : datum2[domainIdentifier];
      }));
    }
    var axisPosition = this.services.cartesianScales.domainAxisPosition;
    var scaleType = options2.axes[axisPosition].scaleType;
    if (scaleType === ScaleTypes.TIME) {
      stackKeys.sort(function(a, b) {
        var dateA = new Date(a);
        var dateB = new Date(b);
        return dateA - dateB;
      });
    } else if (scaleType === ScaleTypes.LOG || scaleType === ScaleTypes.LINEAR) {
      stackKeys.sort(function(a, b) {
        return a - b;
      });
    }
    return stackKeys;
  };
  ChartModel2.prototype.getDataValuesGroupedByKeys = function(_a2) {
    var _this = this;
    var _b = _a2.bins, bins = _b === void 0 ? null : _b, _c = _a2.groups, groups = _c === void 0 ? null : _c;
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var displayData = this.getDisplayData(groups);
    var dataGroupNames = this.getDataGroupNames();
    var stackKeys = this.getStackKeys({ bins, groups });
    if (bins) {
      return stackKeys.map(function(key) {
        var _a3 = key.split("-"), binStart = _a3[0], binEnd = _a3[1];
        var correspondingValues = { x0: binStart, x1: binEnd };
        var correspondingBin = bins.find(function(bin2) {
          return bin2.x0.toString() === binStart.toString();
        });
        dataGroupNames.forEach(function(dataGroupName) {
          correspondingValues[dataGroupName] = correspondingBin.filter(function(binItem) {
            return binItem[groupMapsTo] === dataGroupName;
          }).length;
        });
        return correspondingValues;
      });
    }
    return stackKeys.map(function(key) {
      var correspondingValues = { sharedStackKey: key };
      dataGroupNames.forEach(function(dataGroupName) {
        var correspondingDatum = displayData.find(function(datum2) {
          var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(datum2);
          return datum2[groupMapsTo] === dataGroupName && datum2.hasOwnProperty(domainIdentifier) && datum2[domainIdentifier].toString() === key;
        });
        var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(correspondingValues);
        correspondingValues[dataGroupName] = correspondingDatum ? correspondingDatum[rangeIdentifier] : null;
      });
      return correspondingValues;
    });
  };
  ChartModel2.prototype.getStackedData = function(_a2) {
    var _b = _a2.percentage, percentage = _b === void 0 ? false : _b, _c = _a2.groups, groups = _c === void 0 ? null : _c, _d = _a2.divergent, divergent = _d === void 0 ? false : _d;
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var dataGroupNames = this.getActiveDataGroupNames(groups);
    var dataValuesGroupedByKeys = this.getDataValuesGroupedByKeys({
      groups
    });
    if (percentage) {
      var maxByKey_1 = Tools.fromPairs(dataValuesGroupedByKeys.map(function(d) {
        return [d.sharedStackKey, 0];
      }));
      dataValuesGroupedByKeys.forEach(function(d) {
        dataGroupNames.forEach(function(name) {
          maxByKey_1[d.sharedStackKey] += d[name];
        });
      });
      dataValuesGroupedByKeys.forEach(function(d) {
        dataGroupNames.forEach(function(name) {
          if (maxByKey_1[d.sharedStackKey]) {
            d[name] = d[name] / maxByKey_1[d.sharedStackKey] * 100;
          } else {
            d[name] = 0;
          }
        });
      });
    }
    var stackToUse = divergent ? stack().offset(stackOffsetDiverging) : stack();
    return stackToUse.keys(dataGroupNames)(dataValuesGroupedByKeys).map(function(series, i) {
      return Object.keys(series).filter(function(key) {
        return !isNaN(key);
      }).map(function(key) {
        var element = series[key];
        element[groupMapsTo] = dataGroupNames[i];
        return element;
      });
    });
  };
  ChartModel2.prototype.getOptions = function() {
    return this.state.options;
  };
  ChartModel2.prototype.set = function(newState, configs) {
    this.state = Object.assign({}, this.state, newState);
    var newConfig = Object.assign({ skipUpdate: false, animate: true }, configs);
    if (!newConfig.skipUpdate) {
      this.update(newConfig.animate);
    }
  };
  ChartModel2.prototype.get = function(property2) {
    if (property2) {
      return this.state[property2];
    } else {
      return this.state;
    }
  };
  ChartModel2.prototype.setOptions = function(newOptions) {
    var options2 = this.getOptions();
    Tools.updateLegendAdditionalItems(options2, newOptions);
    this.set({
      options: Tools.merge(options2, newOptions)
    });
  };
  ChartModel2.prototype.update = function(animate) {
    if (animate === void 0) {
      animate = true;
    }
    if (!this.getDisplayData()) {
      return;
    }
    this.updateAllDataGroups();
    this.setCustomColorScale();
    this.setColorClassNames();
    this.services.events.dispatchEvent(Events$1.Model.UPDATE, { animate });
  };
  ChartModel2.prototype.toggleDataLabel = function(changedLabel) {
    var _a2 = legend$1.items.status, ACTIVE = _a2.ACTIVE, DISABLED = _a2.DISABLED;
    var dataGroups = this.getDataGroups();
    var hasDeactivatedItems = dataGroups.some(function(group) {
      return group.status === DISABLED;
    });
    var activeItems = dataGroups.filter(function(group) {
      return group.status === ACTIVE;
    });
    if (hasDeactivatedItems) {
      if (activeItems.length === 1 && activeItems[0].name === changedLabel) {
        dataGroups.forEach(function(group, i) {
          dataGroups[i].status = ACTIVE;
        });
      } else {
        var indexToChange = dataGroups.findIndex(function(group) {
          return group.name === changedLabel;
        });
        dataGroups[indexToChange].status = dataGroups[indexToChange].status === DISABLED ? ACTIVE : DISABLED;
      }
    } else {
      dataGroups.forEach(function(group, i) {
        dataGroups[i].status = group.name === changedLabel ? ACTIVE : DISABLED;
      });
    }
    var updatedActiveItems = dataGroups.filter(function(group) {
      return group.status === ACTIVE;
    });
    var options2 = this.getOptions();
    var hasUpdatedDeactivatedItems = dataGroups.some(function(group) {
      return group.status === DISABLED;
    });
    if (hasUpdatedDeactivatedItems) {
      options2.data.selectedGroups = updatedActiveItems.map(function(activeItem) {
        return activeItem.name;
      });
    } else {
      options2.data.selectedGroups = [];
    }
    this.services.events.dispatchEvent(Events$1.Legend.ITEMS_UPDATE, {
      dataGroups
    });
    this.set({
      dataGroups
    });
  };
  ChartModel2.prototype.getIsFilled = function(group, key, data, defaultFilled) {
    var options2 = this.getOptions();
    if (options2.getIsFilled) {
      return options2.getIsFilled(group, key, data, defaultFilled);
    } else {
      return defaultFilled;
    }
  };
  ChartModel2.prototype.getFillColor = function(group, key, data) {
    var options2 = this.getOptions();
    var defaultFillColor = Tools.getProperty(this.colorScale, group);
    if (options2.getFillColor) {
      return options2.getFillColor(group, key, data, defaultFillColor);
    } else {
      return defaultFillColor;
    }
  };
  ChartModel2.prototype.getStrokeColor = function(group, key, data) {
    var options2 = this.getOptions();
    var defaultStrokeColor = Tools.getProperty(this.colorScale, group);
    if (options2.getStrokeColor) {
      return options2.getStrokeColor(group, key, data, defaultStrokeColor);
    } else {
      return defaultStrokeColor;
    }
  };
  ChartModel2.prototype.isUserProvidedColorScaleValid = function() {
    var userProvidedScale = Tools.getProperty(this.getOptions(), "color", "scale");
    var dataGroups = this.getDataGroups();
    if (userProvidedScale == null || Object.keys(userProvidedScale).length == 0) {
      return false;
    }
    return dataGroups.some(function(dataGroup) {
      return Object.keys(userProvidedScale).includes(dataGroup.name);
    });
  };
  ChartModel2.prototype.getColorClassName = function(configs) {
    var colorPairingTag = this.colorClassNames(configs.dataGroupName);
    var className = configs.originalClassName;
    configs.classNameTypes.forEach(function(type2) {
      return className = configs.originalClassName ? className + " " + type2 + "-" + colorPairingTag : type2 + "-" + colorPairingTag;
    });
    return className;
  };
  ChartModel2.prototype.getStatus = function() {
    return null;
  };
  ChartModel2.prototype.getAllDataGroupsNames = function() {
    return this.allDataGroups;
  };
  ChartModel2.prototype.transformToTabularData = function(data) {
    console.warn("We've updated the charting data format to be tabular by default. The current format you're using is deprecated and will be removed in v1.0, read more here https://carbon-design-system.github.io/carbon-charts/?path=/story/docs-tutorials--tabular-data-format");
    var tabularData = [];
    var datasets = data.datasets, labels = data.labels;
    datasets.forEach(function(dataset) {
      dataset.data.forEach(function(datum2, i) {
        var group;
        var datasetLabel = Tools.getProperty(dataset, "label");
        if (datasetLabel === null) {
          var correspondingLabel = Tools.getProperty(labels, i);
          if (correspondingLabel) {
            group = correspondingLabel;
          } else {
            group = "Ungrouped";
          }
        } else {
          group = datasetLabel;
        }
        var updatedDatum = {
          group,
          key: labels[i]
        };
        if (isNaN(datum2)) {
          updatedDatum["value"] = datum2.value;
          updatedDatum["date"] = datum2.date;
        } else {
          updatedDatum["value"] = datum2;
        }
        tabularData.push(updatedDatum);
      });
    });
    return tabularData;
  };
  ChartModel2.prototype.getTabularDataArray = function() {
    return [];
  };
  ChartModel2.prototype.exportToCSV = function() {
    var data = this.getTabularDataArray().map(function(row) {
      return row.map(function(column) {
        return '"' + column + '"';
      });
    });
    var csvString = "", csvData = "";
    data.forEach(function(d, i) {
      csvData = d.join(",");
      csvString += i < data.length ? csvData + "\n" : csvData;
    });
    this.services.files.downloadCSV(csvString, "myChart.csv");
  };
  ChartModel2.prototype.getTabularData = function(data) {
    if (!Array.isArray(data)) {
      return this.transformToTabularData(data);
    }
    return data;
  };
  ChartModel2.prototype.sanitize = function(data) {
    data = this.getTabularData(data);
    return data;
  };
  ChartModel2.prototype.updateAllDataGroups = function() {
    var _this = this;
    if (!this.allDataGroups) {
      this.allDataGroups = this.getDataGroupNames();
    } else {
      this.getDataGroupNames().forEach(function(dataGroupName) {
        if (_this.allDataGroups.indexOf(dataGroupName) === -1) {
          _this.allDataGroups.push(dataGroupName);
        }
      });
    }
  };
  ChartModel2.prototype.generateDataGroups = function(data) {
    var groupMapsTo = this.getOptions().data.groupMapsTo;
    var _a2 = legend$1.items.status, ACTIVE = _a2.ACTIVE, DISABLED = _a2.DISABLED;
    var options2 = this.getOptions();
    var uniqueDataGroups = Tools.removeArrayDuplicates(data.map(function(datum2) {
      return datum2[groupMapsTo];
    }));
    if (options2.data.selectedGroups.length) {
      var hasAllSelectedGroups = options2.data.selectedGroups.every(function(groupName) {
        return uniqueDataGroups.includes(groupName);
      });
      if (!hasAllSelectedGroups) {
        options2.data.selectedGroups = [];
      }
    }
    var getStatus = function(groupName) {
      return !options2.data.selectedGroups.length || options2.data.selectedGroups.includes(groupName) ? ACTIVE : DISABLED;
    };
    return uniqueDataGroups.map(function(groupName) {
      return {
        name: groupName,
        status: getStatus(groupName)
      };
    });
  };
  ChartModel2.prototype.setCustomColorScale = function() {
    var _this = this;
    if (!this.isUserProvidedColorScaleValid()) {
      return;
    }
    var options2 = this.getOptions();
    var userProvidedScale = Tools.getProperty(options2, "color", "scale");
    Object.keys(userProvidedScale).forEach(function(dataGroup) {
      if (!_this.allDataGroups.includes(dataGroup)) {
        console.warn('"' + dataGroup + '" does not exist in data groups.');
      }
    });
    var providedDataGroups = this.allDataGroups.filter(function(dataGroup) {
      return userProvidedScale[dataGroup];
    });
    providedDataGroups.forEach(function(dataGroup) {
      return _this.colorScale[dataGroup] = userProvidedScale[dataGroup];
    });
  };
  ChartModel2.prototype.setColorClassNames = function() {
    var colorPairingOptions = Tools.getProperty(this.getOptions(), "color", "pairing");
    var numberOfVariants = Tools.getProperty(colorPairingOptions, "numberOfVariants");
    if (!numberOfVariants || numberOfVariants < this.allDataGroups.length) {
      numberOfVariants = this.allDataGroups.length;
    }
    var pairingOption = Tools.getProperty(colorPairingOptions, "option");
    var colorPairingCounts = color$1.pairingOptions;
    var numberOfColors = numberOfVariants > 5 ? 14 : numberOfVariants;
    pairingOption = pairingOption <= colorPairingCounts[numberOfColors + "-color"] ? pairingOption : 1;
    var colorPairing = this.allDataGroups.map(function(dataGroup, index2) {
      return numberOfColors + "-" + pairingOption + "-" + (index2 % 14 + 1);
    });
    this.colorClassNames = ordinal().range(colorPairing).domain(this.allDataGroups);
  };
  return ChartModel2;
}();
var Service = function() {
  function Service2(model, services) {
    this.model = model;
    this.services = services;
    this.init();
  }
  Service2.prototype.init = function() {
  };
  Service2.prototype.update = function() {
  };
  Service2.prototype.setModel = function(newObj) {
    this.model = newObj;
  };
  Service2.prototype.setServices = function(newObj) {
    this.services = newObj;
  };
  return Service2;
}();
var settings = {
  prefix: "bx",
  selectorTabbable: "\n    a[href], area[href], input:not([disabled]):not([tabindex='-1']),\n    button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),\n    textarea:not([disabled]):not([tabindex='-1']),\n    iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]\n  ",
  selectorFocusable: "\n    a[href], area[href], input:not([disabled]),\n    button:not([disabled]),select:not([disabled]),\n    textarea:not([disabled]),\n    iframe, object, embed, *[tabindex], *[contenteditable=true]\n  "
};
var settings_1 = settings;
var settings$1 = settings_1;
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return function() {
    function anonymous() {
      this.__entries__ = [];
    }
    var prototypeAccessors = { size: { configurable: true } };
    prototypeAccessors.size.get = function() {
      return this.__entries__.length;
    };
    anonymous.prototype.get = function(key) {
      var index2 = getIndex(this.__entries__, key);
      var entry = this.__entries__[index2];
      return entry && entry[1];
    };
    anonymous.prototype.set = function(key, value2) {
      var index2 = getIndex(this.__entries__, key);
      if (~index2) {
        this.__entries__[index2][1] = value2;
      } else {
        this.__entries__.push([key, value2]);
      }
    };
    anonymous.prototype.delete = function(key) {
      var entries = this.__entries__;
      var index2 = getIndex(entries, key);
      if (~index2) {
        entries.splice(index2, 1);
      }
    };
    anonymous.prototype.has = function(key) {
      return !!~getIndex(this.__entries__, key);
    };
    anonymous.prototype.clear = function() {
      this.__entries__.splice(0);
    };
    anonymous.prototype.forEach = function(callback, ctx) {
      var this$1$1 = this;
      if (ctx === void 0)
        ctx = null;
      for (var i = 0, list = this$1$1.__entries__; i < list.length; i += 1) {
        var entry = list[i];
        callback.call(ctx, entry[1], entry[0]);
      }
    };
    Object.defineProperties(anonymous.prototype, prototypeAccessors);
    return anonymous;
  }();
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
var throttle = function(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
};
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = function() {
  this.connected_ = false;
  this.mutationEventsAdded_ = false;
  this.mutationsObserver_ = null;
  this.observers_ = [];
  this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
  this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
};
ResizeObserverController.prototype.addObserver = function(observer) {
  if (!~this.observers_.indexOf(observer)) {
    this.observers_.push(observer);
  }
  if (!this.connected_) {
    this.connect_();
  }
};
ResizeObserverController.prototype.removeObserver = function(observer) {
  var observers2 = this.observers_;
  var index2 = observers2.indexOf(observer);
  if (~index2) {
    observers2.splice(index2, 1);
  }
  if (!observers2.length && this.connected_) {
    this.disconnect_();
  }
};
ResizeObserverController.prototype.refresh = function() {
  var changesDetected = this.updateObservers_();
  if (changesDetected) {
    this.refresh();
  }
};
ResizeObserverController.prototype.updateObservers_ = function() {
  var activeObservers = this.observers_.filter(function(observer) {
    return observer.gatherActive(), observer.hasActive();
  });
  activeObservers.forEach(function(observer) {
    return observer.broadcastActive();
  });
  return activeObservers.length > 0;
};
ResizeObserverController.prototype.connect_ = function() {
  if (!isBrowser || this.connected_) {
    return;
  }
  document.addEventListener("transitionend", this.onTransitionEnd_);
  window.addEventListener("resize", this.refresh);
  if (mutationObserverSupported) {
    this.mutationsObserver_ = new MutationObserver(this.refresh);
    this.mutationsObserver_.observe(document, {
      attributes: true,
      childList: true,
      characterData: true,
      subtree: true
    });
  } else {
    document.addEventListener("DOMSubtreeModified", this.refresh);
    this.mutationEventsAdded_ = true;
  }
  this.connected_ = true;
};
ResizeObserverController.prototype.disconnect_ = function() {
  if (!isBrowser || !this.connected_) {
    return;
  }
  document.removeEventListener("transitionend", this.onTransitionEnd_);
  window.removeEventListener("resize", this.refresh);
  if (this.mutationsObserver_) {
    this.mutationsObserver_.disconnect();
  }
  if (this.mutationEventsAdded_) {
    document.removeEventListener("DOMSubtreeModified", this.refresh);
  }
  this.mutationsObserver_ = null;
  this.mutationEventsAdded_ = false;
  this.connected_ = false;
};
ResizeObserverController.prototype.onTransitionEnd_ = function(ref) {
  var propertyName = ref.propertyName;
  if (propertyName === void 0)
    propertyName = "";
  var isReflowProperty = transitionKeys.some(function(key) {
    return !!~propertyName.indexOf(key);
  });
  if (isReflowProperty) {
    this.refresh();
  }
};
ResizeObserverController.getInstance = function() {
  if (!this.instance_) {
    this.instance_ = new ResizeObserverController();
  }
  return this.instance_;
};
ResizeObserverController.instance_ = null;
var defineConfigurable = function(target, props) {
  for (var i = 0, list = Object.keys(props); i < list.length; i += 1) {
    var key = list[i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value2) {
  return parseFloat(value2) || 0;
}
function getBordersSize(styles) {
  var positions = [], len = arguments.length - 1;
  while (len-- > 0)
    positions[len] = arguments[len + 1];
  return positions.reduce(function(size, position) {
    var value2 = styles["border-" + position + "-width"];
    return size + toFloat(value2);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var i = 0, list = positions; i < list.length; i += 1) {
    var position = list[i];
    var value2 = styles["padding-" + position];
    paddings[position] = toFloat(value2);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth;
  var clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(ref) {
  var x2 = ref.x;
  var y2 = ref.y;
  var width = ref.width;
  var height = ref.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x2,
    y: y2,
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: height + y2,
    left: x2
  });
  return rect;
}
function createRectInit(x2, y2, width, height) {
  return { x: x2, y: y2, width, height };
}
var ResizeObservation = function(target) {
  this.broadcastWidth = 0;
  this.broadcastHeight = 0;
  this.contentRect_ = createRectInit(0, 0, 0, 0);
  this.target = target;
};
ResizeObservation.prototype.isActive = function() {
  var rect = getContentRect(this.target);
  this.contentRect_ = rect;
  return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
};
ResizeObservation.prototype.broadcastRect = function() {
  var rect = this.contentRect_;
  this.broadcastWidth = rect.width;
  this.broadcastHeight = rect.height;
  return rect;
};
var ResizeObserverEntry = function(target, rectInit) {
  var contentRect = createReadOnlyRect(rectInit);
  defineConfigurable(this, { target, contentRect });
};
var ResizeObserverSPI = function(callback, controller, callbackCtx) {
  this.activeObservations_ = [];
  this.observations_ = new MapShim();
  if (typeof callback !== "function") {
    throw new TypeError("The callback provided as parameter 1 is not a function.");
  }
  this.callback_ = callback;
  this.controller_ = controller;
  this.callbackCtx_ = callbackCtx;
};
ResizeObserverSPI.prototype.observe = function(target) {
  if (!arguments.length) {
    throw new TypeError("1 argument required, but only 0 present.");
  }
  if (typeof Element === "undefined" || !(Element instanceof Object)) {
    return;
  }
  if (!(target instanceof getWindowOf(target).Element)) {
    throw new TypeError('parameter 1 is not of type "Element".');
  }
  var observations = this.observations_;
  if (observations.has(target)) {
    return;
  }
  observations.set(target, new ResizeObservation(target));
  this.controller_.addObserver(this);
  this.controller_.refresh();
};
ResizeObserverSPI.prototype.unobserve = function(target) {
  if (!arguments.length) {
    throw new TypeError("1 argument required, but only 0 present.");
  }
  if (typeof Element === "undefined" || !(Element instanceof Object)) {
    return;
  }
  if (!(target instanceof getWindowOf(target).Element)) {
    throw new TypeError('parameter 1 is not of type "Element".');
  }
  var observations = this.observations_;
  if (!observations.has(target)) {
    return;
  }
  observations.delete(target);
  if (!observations.size) {
    this.controller_.removeObserver(this);
  }
};
ResizeObserverSPI.prototype.disconnect = function() {
  this.clearActive();
  this.observations_.clear();
  this.controller_.removeObserver(this);
};
ResizeObserverSPI.prototype.gatherActive = function() {
  var this$1$1 = this;
  this.clearActive();
  this.observations_.forEach(function(observation) {
    if (observation.isActive()) {
      this$1$1.activeObservations_.push(observation);
    }
  });
};
ResizeObserverSPI.prototype.broadcastActive = function() {
  if (!this.hasActive()) {
    return;
  }
  var ctx = this.callbackCtx_;
  var entries = this.activeObservations_.map(function(observation) {
    return new ResizeObserverEntry(observation.target, observation.broadcastRect());
  });
  this.callback_.call(ctx, entries, ctx);
  this.clearActive();
};
ResizeObserverSPI.prototype.clearActive = function() {
  this.activeObservations_.splice(0);
};
ResizeObserverSPI.prototype.hasActive = function() {
  return this.activeObservations_.length > 0;
};
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver = function(callback) {
  if (!(this instanceof ResizeObserver)) {
    throw new TypeError("Cannot call a class as a function.");
  }
  if (!arguments.length) {
    throw new TypeError("1 argument required, but only 0 present.");
  }
  var controller = ResizeObserverController.getInstance();
  var observer = new ResizeObserverSPI(callback, controller, this);
  observers.set(this, observer);
};
["observe", "unobserve", "disconnect"].forEach(function(method) {
  ResizeObserver.prototype[method] = function() {
    return (ref = observers.get(this))[method].apply(ref, arguments);
    var ref;
  };
});
var index = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver;
}();
var domToImage$1 = { exports: {} };
(function(module2) {
  (function(global2) {
    var util = newUtil();
    var inliner = newInliner();
    var fontFaces = newFontFaces();
    var images = newImages();
    var defaultOptions = {
      imagePlaceholder: void 0,
      cacheBust: false
    };
    var domtoimage = {
      toSvg,
      toPng,
      toJpeg,
      toBlob,
      toPixelData,
      impl: {
        fontFaces,
        images,
        util,
        inliner,
        options: {}
      }
    };
    module2.exports = domtoimage;
    function toSvg(node, options2) {
      options2 = options2 || {};
      copyOptions(options2);
      return Promise.resolve(node).then(function(node2) {
        return cloneNode(node2, options2.filter, true);
      }).then(embedFonts).then(inlineImages).then(applyOptions).then(function(clone) {
        return makeSvgDataUri(clone, options2.width || util.width(node), options2.height || util.height(node));
      });
      function applyOptions(clone) {
        if (options2.bgcolor)
          clone.style.backgroundColor = options2.bgcolor;
        if (options2.width)
          clone.style.width = options2.width + "px";
        if (options2.height)
          clone.style.height = options2.height + "px";
        if (options2.style)
          Object.keys(options2.style).forEach(function(property2) {
            clone.style[property2] = options2.style[property2];
          });
        return clone;
      }
    }
    function toPixelData(node, options2) {
      return draw(node, options2 || {}).then(function(canvas) {
        return canvas.getContext("2d").getImageData(0, 0, util.width(node), util.height(node)).data;
      });
    }
    function toPng(node, options2) {
      return draw(node, options2 || {}).then(function(canvas) {
        return canvas.toDataURL();
      });
    }
    function toJpeg(node, options2) {
      options2 = options2 || {};
      return draw(node, options2).then(function(canvas) {
        return canvas.toDataURL("image/jpeg", options2.quality || 1);
      });
    }
    function toBlob(node, options2) {
      return draw(node, options2 || {}).then(util.canvasToBlob);
    }
    function copyOptions(options2) {
      if (typeof options2.imagePlaceholder === "undefined") {
        domtoimage.impl.options.imagePlaceholder = defaultOptions.imagePlaceholder;
      } else {
        domtoimage.impl.options.imagePlaceholder = options2.imagePlaceholder;
      }
      if (typeof options2.cacheBust === "undefined") {
        domtoimage.impl.options.cacheBust = defaultOptions.cacheBust;
      } else {
        domtoimage.impl.options.cacheBust = options2.cacheBust;
      }
    }
    function draw(domNode, options2) {
      return toSvg(domNode, options2).then(util.makeImage).then(util.delay(100)).then(function(image) {
        var canvas = newCanvas(domNode);
        canvas.getContext("2d").drawImage(image, 0, 0);
        return canvas;
      });
      function newCanvas(domNode2) {
        var canvas = document.createElement("canvas");
        canvas.width = options2.width || util.width(domNode2);
        canvas.height = options2.height || util.height(domNode2);
        if (options2.bgcolor) {
          var ctx = canvas.getContext("2d");
          ctx.fillStyle = options2.bgcolor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        return canvas;
      }
    }
    function cloneNode(node, filter2, root2) {
      if (!root2 && filter2 && !filter2(node))
        return Promise.resolve();
      return Promise.resolve(node).then(makeNodeCopy).then(function(clone) {
        return cloneChildren(node, clone, filter2);
      }).then(function(clone) {
        return processClone(node, clone);
      });
      function makeNodeCopy(node2) {
        if (node2 instanceof HTMLCanvasElement)
          return util.makeImage(node2.toDataURL());
        return node2.cloneNode(false);
      }
      function cloneChildren(original, clone, filter3) {
        var children2 = original.childNodes;
        if (children2.length === 0)
          return Promise.resolve(clone);
        return cloneChildrenInOrder(clone, util.asArray(children2), filter3).then(function() {
          return clone;
        });
        function cloneChildrenInOrder(parent, children3, filter4) {
          var done = Promise.resolve();
          children3.forEach(function(child) {
            done = done.then(function() {
              return cloneNode(child, filter4);
            }).then(function(childClone) {
              if (childClone)
                parent.appendChild(childClone);
            });
          });
          return done;
        }
      }
      function processClone(original, clone) {
        if (!(clone instanceof Element))
          return clone;
        return Promise.resolve().then(cloneStyle).then(clonePseudoElements).then(copyUserInput).then(fixSvg).then(function() {
          return clone;
        });
        function cloneStyle() {
          copyStyle(window.getComputedStyle(original), clone.style);
          function copyStyle(source, target) {
            if (source.cssText)
              target.cssText = source.cssText;
            else
              copyProperties(source, target);
            function copyProperties(source2, target2) {
              util.asArray(source2).forEach(function(name) {
                target2.setProperty(name, source2.getPropertyValue(name), source2.getPropertyPriority(name));
              });
            }
          }
        }
        function clonePseudoElements() {
          [":before", ":after"].forEach(function(element) {
            clonePseudoElement(element);
          });
          function clonePseudoElement(element) {
            var style = window.getComputedStyle(original, element);
            var content = style.getPropertyValue("content");
            if (content === "" || content === "none")
              return;
            var className = util.uid();
            clone.className = clone.className + " " + className;
            var styleElement = document.createElement("style");
            styleElement.appendChild(formatPseudoElementStyle(className, element, style));
            clone.appendChild(styleElement);
            function formatPseudoElementStyle(className2, element2, style2) {
              var selector2 = "." + className2 + ":" + element2;
              var cssText = style2.cssText ? formatCssText(style2) : formatCssProperties(style2);
              return document.createTextNode(selector2 + "{" + cssText + "}");
              function formatCssText(style3) {
                var content2 = style3.getPropertyValue("content");
                return style3.cssText + " content: " + content2 + ";";
              }
              function formatCssProperties(style3) {
                return util.asArray(style3).map(formatProperty).join("; ") + ";";
                function formatProperty(name) {
                  return name + ": " + style3.getPropertyValue(name) + (style3.getPropertyPriority(name) ? " !important" : "");
                }
              }
            }
          }
        }
        function copyUserInput() {
          if (original instanceof HTMLTextAreaElement)
            clone.innerHTML = original.value;
          if (original instanceof HTMLInputElement)
            clone.setAttribute("value", original.value);
        }
        function fixSvg() {
          if (!(clone instanceof SVGElement))
            return;
          clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
          if (!(clone instanceof SVGRectElement))
            return;
          ["width", "height"].forEach(function(attribute) {
            var value2 = clone.getAttribute(attribute);
            if (!value2)
              return;
            clone.style.setProperty(attribute, value2);
          });
        }
      }
    }
    function embedFonts(node) {
      return fontFaces.resolveAll().then(function(cssText) {
        var styleNode = document.createElement("style");
        node.appendChild(styleNode);
        styleNode.appendChild(document.createTextNode(cssText));
        return node;
      });
    }
    function inlineImages(node) {
      return images.inlineAll(node).then(function() {
        return node;
      });
    }
    function makeSvgDataUri(node, width, height) {
      return Promise.resolve(node).then(function(node2) {
        node2.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
        return new XMLSerializer().serializeToString(node2);
      }).then(util.escapeXhtml).then(function(xhtml2) {
        return '<foreignObject x="0" y="0" width="100%" height="100%">' + xhtml2 + "</foreignObject>";
      }).then(function(foreignObject) {
        return '<svg xmlns="http://www.w3.org/2000/svg" width="' + width + '" height="' + height + '">' + foreignObject + "</svg>";
      }).then(function(svg) {
        return "data:image/svg+xml;charset=utf-8," + svg;
      });
    }
    function newUtil() {
      return {
        escape: escape2,
        parseExtension,
        mimeType,
        dataAsUrl,
        isDataUrl,
        canvasToBlob,
        resolveUrl,
        getAndEncode,
        uid: uid(),
        delay,
        asArray,
        escapeXhtml,
        makeImage,
        width,
        height
      };
      function mimes() {
        var WOFF = "application/font-woff";
        var JPEG = "image/jpeg";
        return {
          "woff": WOFF,
          "woff2": WOFF,
          "ttf": "application/font-truetype",
          "eot": "application/vnd.ms-fontobject",
          "png": "image/png",
          "jpg": JPEG,
          "jpeg": JPEG,
          "gif": "image/gif",
          "tiff": "image/tiff",
          "svg": "image/svg+xml"
        };
      }
      function parseExtension(url) {
        var match2 = /\.([^\.\/]*?)$/g.exec(url);
        if (match2)
          return match2[1];
        else
          return "";
      }
      function mimeType(url) {
        var extension = parseExtension(url).toLowerCase();
        return mimes()[extension] || "";
      }
      function isDataUrl(url) {
        return url.search(/^(data:)/) !== -1;
      }
      function toBlob2(canvas) {
        return new Promise(function(resolve) {
          var binaryString = window.atob(canvas.toDataURL().split(",")[1]);
          var length = binaryString.length;
          var binaryArray = new Uint8Array(length);
          for (var i = 0; i < length; i++)
            binaryArray[i] = binaryString.charCodeAt(i);
          resolve(new Blob([binaryArray], {
            type: "image/png"
          }));
        });
      }
      function canvasToBlob(canvas) {
        if (canvas.toBlob)
          return new Promise(function(resolve) {
            canvas.toBlob(resolve);
          });
        return toBlob2(canvas);
      }
      function resolveUrl(url, baseUrl) {
        var doc = document.implementation.createHTMLDocument();
        var base = doc.createElement("base");
        doc.head.appendChild(base);
        var a = doc.createElement("a");
        doc.body.appendChild(a);
        base.href = baseUrl;
        a.href = url;
        return a.href;
      }
      function uid() {
        var index2 = 0;
        return function() {
          return "u" + fourRandomChars() + index2++;
          function fourRandomChars() {
            return ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
          }
        };
      }
      function makeImage(uri) {
        return new Promise(function(resolve, reject) {
          var image = new Image();
          image.onload = function() {
            resolve(image);
          };
          image.onerror = reject;
          image.src = uri;
        });
      }
      function getAndEncode(url) {
        var TIMEOUT = 3e4;
        if (domtoimage.impl.options.cacheBust) {
          url += (/\?/.test(url) ? "&" : "?") + new Date().getTime();
        }
        return new Promise(function(resolve) {
          var request = new XMLHttpRequest();
          request.onreadystatechange = done;
          request.ontimeout = timeout2;
          request.responseType = "blob";
          request.timeout = TIMEOUT;
          request.open("GET", url, true);
          request.send();
          var placeholder;
          if (domtoimage.impl.options.imagePlaceholder) {
            var split = domtoimage.impl.options.imagePlaceholder.split(/,/);
            if (split && split[1]) {
              placeholder = split[1];
            }
          }
          function done() {
            if (request.readyState !== 4)
              return;
            if (request.status !== 200) {
              if (placeholder) {
                resolve(placeholder);
              } else {
                fail("cannot fetch resource: " + url + ", status: " + request.status);
              }
              return;
            }
            var encoder = new FileReader();
            encoder.onloadend = function() {
              var content = encoder.result.split(/,/)[1];
              resolve(content);
            };
            encoder.readAsDataURL(request.response);
          }
          function timeout2() {
            if (placeholder) {
              resolve(placeholder);
            } else {
              fail("timeout of " + TIMEOUT + "ms occured while fetching resource: " + url);
            }
          }
          function fail(message) {
            console.error(message);
            resolve("");
          }
        });
      }
      function dataAsUrl(content, type2) {
        return "data:" + type2 + ";base64," + content;
      }
      function escape2(string) {
        return string.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
      }
      function delay(ms) {
        return function(arg) {
          return new Promise(function(resolve) {
            setTimeout(function() {
              resolve(arg);
            }, ms);
          });
        };
      }
      function asArray(arrayLike) {
        var array2 = [];
        var length = arrayLike.length;
        for (var i = 0; i < length; i++)
          array2.push(arrayLike[i]);
        return array2;
      }
      function escapeXhtml(string) {
        return string.replace(/#/g, "%23").replace(/\n/g, "%0A");
      }
      function width(node) {
        var leftBorder = px(node, "border-left-width");
        var rightBorder = px(node, "border-right-width");
        return node.scrollWidth + leftBorder + rightBorder;
      }
      function height(node) {
        var topBorder = px(node, "border-top-width");
        var bottomBorder = px(node, "border-bottom-width");
        return node.scrollHeight + topBorder + bottomBorder;
      }
      function px(node, styleProperty) {
        var value2 = window.getComputedStyle(node).getPropertyValue(styleProperty);
        return parseFloat(value2.replace("px", ""));
      }
    }
    function newInliner() {
      var URL_REGEX = /url\(['"]?([^'"]+?)['"]?\)/g;
      return {
        inlineAll,
        shouldProcess,
        impl: {
          readUrls,
          inline
        }
      };
      function shouldProcess(string) {
        return string.search(URL_REGEX) !== -1;
      }
      function readUrls(string) {
        var result = [];
        var match2;
        while ((match2 = URL_REGEX.exec(string)) !== null) {
          result.push(match2[1]);
        }
        return result.filter(function(url) {
          return !util.isDataUrl(url);
        });
      }
      function inline(string, url, baseUrl, get2) {
        return Promise.resolve(url).then(function(url2) {
          return baseUrl ? util.resolveUrl(url2, baseUrl) : url2;
        }).then(get2 || util.getAndEncode).then(function(data) {
          return util.dataAsUrl(data, util.mimeType(url));
        }).then(function(dataUrl) {
          return string.replace(urlAsRegex(url), "$1" + dataUrl + "$3");
        });
        function urlAsRegex(url2) {
          return new RegExp(`(url\\(['"]?)(` + util.escape(url2) + `)(['"]?\\))`, "g");
        }
      }
      function inlineAll(string, baseUrl, get2) {
        if (nothingToInline())
          return Promise.resolve(string);
        return Promise.resolve(string).then(readUrls).then(function(urls) {
          var done = Promise.resolve(string);
          urls.forEach(function(url) {
            done = done.then(function(string2) {
              return inline(string2, url, baseUrl, get2);
            });
          });
          return done;
        });
        function nothingToInline() {
          return !shouldProcess(string);
        }
      }
    }
    function newFontFaces() {
      return {
        resolveAll,
        impl: {
          readAll
        }
      };
      function resolveAll() {
        return readAll().then(function(webFonts) {
          return Promise.all(webFonts.map(function(webFont) {
            return webFont.resolve();
          }));
        }).then(function(cssStrings) {
          return cssStrings.join("\n");
        });
      }
      function readAll() {
        return Promise.resolve(util.asArray(document.styleSheets)).then(getCssRules).then(selectWebFontRules).then(function(rules) {
          return rules.map(newWebFont);
        });
        function selectWebFontRules(cssRules) {
          return cssRules.filter(function(rule) {
            return rule.type === CSSRule.FONT_FACE_RULE;
          }).filter(function(rule) {
            return inliner.shouldProcess(rule.style.getPropertyValue("src"));
          });
        }
        function getCssRules(styleSheets) {
          var cssRules = [];
          styleSheets.forEach(function(sheet) {
            try {
              util.asArray(sheet.cssRules || []).forEach(cssRules.push.bind(cssRules));
            } catch (e) {
              console.log("Error while reading CSS rules from " + sheet.href, e.toString());
            }
          });
          return cssRules;
        }
        function newWebFont(webFontRule) {
          return {
            resolve: function resolve() {
              var baseUrl = (webFontRule.parentStyleSheet || {}).href;
              return inliner.inlineAll(webFontRule.cssText, baseUrl);
            },
            src: function() {
              return webFontRule.style.getPropertyValue("src");
            }
          };
        }
      }
    }
    function newImages() {
      return {
        inlineAll,
        impl: {
          newImage
        }
      };
      function newImage(element) {
        return {
          inline
        };
        function inline(get2) {
          if (util.isDataUrl(element.src))
            return Promise.resolve();
          return Promise.resolve(element.src).then(get2 || util.getAndEncode).then(function(data) {
            return util.dataAsUrl(data, util.mimeType(element.src));
          }).then(function(dataUrl) {
            return new Promise(function(resolve, reject) {
              element.onload = resolve;
              element.onerror = reject;
              element.src = dataUrl;
            });
          });
        }
      }
      function inlineAll(node) {
        if (!(node instanceof Element))
          return Promise.resolve(node);
        return inlineBackground(node).then(function() {
          if (node instanceof HTMLImageElement)
            return newImage(node).inline();
          else
            return Promise.all(util.asArray(node.childNodes).map(function(child) {
              return inlineAll(child);
            }));
        });
        function inlineBackground(node2) {
          var background = node2.style.getPropertyValue("background");
          if (!background)
            return Promise.resolve(node2);
          return inliner.inlineAll(background).then(function(inlined) {
            node2.style.setProperty("background", inlined, node2.style.getPropertyPriority("background"));
          }).then(function() {
            return node2;
          });
        }
      }
    }
  })();
})(domToImage$1);
var domToImage = domToImage$1.exports;
var __extends$1y = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CSS_VERIFIER_ELEMENT_CLASSNAME = "DONT_STYLE_ME_css_styles_verifier";
var DOMUtils = function(_super) {
  __extends$1y(DOMUtils2, _super);
  function DOMUtils2(model, services) {
    var _this = _super.call(this, model, services) || this;
    _this.chartID = Math.floor((1 + Math.random()) * 281474976710656).toString(16);
    return _this;
  }
  DOMUtils2.getHTMLElementSize = function(element) {
    return {
      width: element.clientWidth,
      height: element.clientHeight
    };
  };
  DOMUtils2.getSVGElementSize = function(svgSelector, options2) {
    if (options2 === void 0) {
      options2 = {
        useAttrs: false,
        useClientDimensions: false,
        useBBox: false,
        useBoundingRect: false
      };
    }
    if (!svgSelector.attr) {
      svgSelector = select(svgSelector);
    }
    var finalDimensions = {
      width: 0,
      height: 0
    };
    var validateAndSetDimensions = function(dimensions) {
      if (dimensions) {
        Object.keys(finalDimensions).forEach(function(dimensionKey) {
          if (dimensions[dimensionKey]) {
            var dimension = dimensions[dimensionKey];
            var dimensionNumber = parseFloat(dimension);
            if (dimension && dimensionNumber > finalDimensions[dimensionKey] && ("" + dimension).indexOf("%") === -1) {
              finalDimensions[dimensionKey] = dimensionNumber;
            }
          }
        });
      }
    };
    var attrDimensions = {
      width: svgSelector.attr("width"),
      height: svgSelector.attr("height")
    };
    var bbox, bboxDimensions, boundingRect, boundingRectDimensions;
    try {
      bbox = svgSelector.node().getBBox();
      bboxDimensions = {
        width: bbox.width,
        height: bbox.height
      };
    } catch (e) {
    }
    try {
      boundingRect = svgSelector.node().getBoundingClientRect();
      boundingRectDimensions = {
        width: boundingRect.width,
        height: boundingRect.height
      };
    } catch (e) {
    }
    var clientDimensions = {
      width: svgSelector.node().clientWidth,
      height: svgSelector.node().clientHeight
    };
    if (options2) {
      if (options2.useAttrs) {
        validateAndSetDimensions(attrDimensions);
        if (finalDimensions.width > 0 && finalDimensions.height > 0) {
          return finalDimensions;
        }
      }
      if (options2.useClientDimensions) {
        validateAndSetDimensions(clientDimensions);
        if (finalDimensions.width > 0 && finalDimensions.height > 0) {
          return clientDimensions;
        }
      }
      if (options2.useBBox) {
        validateAndSetDimensions(bboxDimensions);
        if (finalDimensions.width > 0 && finalDimensions.height > 0) {
          return bboxDimensions;
        }
      }
      if (options2.useBoundingRect) {
        validateAndSetDimensions(boundingRectDimensions);
        if (finalDimensions.width > 0 && finalDimensions.height > 0) {
          return boundingRectDimensions;
        }
      }
    }
    try {
      var nativeDimensions = {
        width: Tools.getProperty(svgSelector.node(), "width", "baseVal", "value"),
        height: Tools.getProperty(svgSelector.node(), "height", "baseVal", "value")
      };
      validateAndSetDimensions(nativeDimensions);
    } catch (e) {
      validateAndSetDimensions(clientDimensions);
      validateAndSetDimensions(bboxDimensions);
      validateAndSetDimensions(attrDimensions);
    }
    return finalDimensions;
  };
  DOMUtils2.appendOrSelect = function(parent, query) {
    var selection2 = parent.select("" + query);
    if (selection2.empty()) {
      var querySections = query.split("#");
      var elementToAppend = void 0;
      var id2 = void 0;
      if (querySections.length === 2) {
        elementToAppend = querySections[0];
        querySections = querySections[1].split(".");
        id2 = querySections[0];
      } else {
        querySections = query.split(".");
        elementToAppend = querySections[0];
      }
      return parent.append(elementToAppend).attr("id", id2).attr("class", querySections.slice(1).join(" "));
    }
    return selection2;
  };
  DOMUtils2.prototype.init = function() {
    this.styleHolderElement();
    this.addMainContainer();
    this.verifyCSSStylesBeingApplied();
    if (this.model.getOptions().resizable) {
      this.addResizeListener();
    }
    this.addHolderListeners();
    this.handleFullscreenChange();
  };
  DOMUtils2.prototype.getChartID = function() {
    return this.chartID;
  };
  DOMUtils2.prototype.generateElementIDString = function(originalID) {
    return "chart-" + this.chartID + "-" + originalID;
  };
  DOMUtils2.prototype.addMainContainer = function() {
    var options2 = this.model.getOptions();
    var chartsprefix = Tools.getProperty(options2, "style", "prefix");
    var mainContainer = select(this.getHolder()).append("div").classed(settings$1.prefix + "--" + chartsprefix + "--chart-wrapper", true).style("height", "100%").style("width", "100%");
    mainContainer.append("g").attr("class", CSS_VERIFIER_ELEMENT_CLASSNAME);
    this.mainContainer = mainContainer.node();
  };
  DOMUtils2.prototype.update = function() {
    this.styleHolderElement();
  };
  DOMUtils2.prototype.styleHolderElement = function() {
    var holderElement = this.getHolder();
    select(this.getHolder()).classed(settings$1.prefix + "--chart-holder", true);
    var _a2 = this.model.getOptions(), width = _a2.width, height = _a2.height;
    if (width !== this.width) {
      holderElement.style.width = width;
      this.width = width;
    }
    if (height !== this.height) {
      holderElement.style.height = height;
      this.height = height;
    }
  };
  DOMUtils2.prototype.getHolder = function() {
    return this.model.get("holder");
  };
  DOMUtils2.prototype.exportToJPG = function() {
    var self2 = this;
    var holder = this.getHolder();
    var holderSelection = select(holder);
    holderSelection.classed("filled", true);
    domToImage.toJpeg(this.getMainContainer(), {
      bgcolor: typeof window !== "undefined" ? window.getComputedStyle(holder).getPropertyValue("background-color") : void 0,
      quality: 1,
      filter: function(node) {
        if (node.classList && node.classList.contains("bx--cc--toolbar")) {
          return false;
        }
        return true;
      }
    }).then(function(dataUrl) {
      self2.services.files.downloadImage(dataUrl, "myChart.jpg");
      holderSelection.classed("filled", false);
    });
  };
  DOMUtils2.prototype.exportToPNG = function() {
    var self2 = this;
    var holder = this.getHolder();
    var holderSelection = select(holder);
    holderSelection.classed("filled", true);
    domToImage.toPng(this.getMainContainer(), {
      bgcolor: typeof window !== "undefined" ? window.getComputedStyle(holder).getPropertyValue("background-color") : void 0,
      quality: 1,
      filter: function(node) {
        if (node.classList && node.classList.contains("bx--cc--toolbar")) {
          return false;
        }
        return true;
      }
    }).then(function(dataUrl) {
      self2.services.files.downloadImage(dataUrl, "myChart.png");
      holderSelection.classed("filled", false);
    }).catch(function(error) {
      console.error("oops, something went wrong!", error);
    });
  };
  DOMUtils2.prototype.toggleFullscreen = function() {
    var holder = this.getHolder();
    var holderSelection = select(holder);
    var isFullScreen = holderSelection.classed("fullscreen");
    if (isFullScreen && (document.fullscreenElement || document["webkitFullscreenElement"] || document["mozFullScreenElement"] || document["msFullscreenElement"])) {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document["webkitExitFullscreen"]) {
        document["webkitExitFullscreen"]();
      } else if (document["mozCancelFullScreen"]) {
        document["mozCancelFullScreen"]();
      } else if (document["msExitFullscreen"]) {
        document["msExitFullscreen"]();
      }
    } else {
      if (holder.requestFullscreen) {
        holder.requestFullscreen();
      } else if (holder.webkitRequestFullscreen) {
        holder.webkitRequestFullscreen();
      } else if (holder.mozRequestFullScreen) {
        holder.mozRequestFullScreen();
      } else if (holder.msRequestFullscreen) {
        holder.msRequestFullscreen();
      }
    }
  };
  DOMUtils2.prototype.handleFullscreenChange = function() {
    var _this = this;
    document.addEventListener("fullscreenchange", function() {
      var holderSelection = select(_this.getHolder());
      var isFullScreen = holderSelection.classed("fullscreen");
      holderSelection.classed("fullscreen", !isFullScreen);
    });
  };
  DOMUtils2.prototype.verifyCSSStylesBeingApplied = function() {
    var _this = this;
    setTimeout(function() {
      var cssVerifierElement = select(_this.mainContainer).select("g." + CSS_VERIFIER_ELEMENT_CLASSNAME).node();
      var computedStyles = getComputedStyle(cssVerifierElement);
      if (computedStyles.getPropertyValue("overflow") !== "hidden" || computedStyles.getPropertyValue("opacity") !== "0") {
        console.error("Missing CSS styles for Carbon Charts. Please read the Carbon Charts getting started guide.");
      }
    });
  };
  DOMUtils2.prototype.setSVGMaxHeight = function() {
    if (!this.model.getOptions().height) {
      var chartHeight = DOMUtils2.getSVGElementSize(select(this.mainContainer), { useBBox: true }).height;
      var chartSVGSelector = select(this.mainContainer).attr("class");
      var children2 = select(this.mainContainer).selectAll("." + chartSVGSelector + " > svg");
      var childrenHeight_1 = 0;
      children2.nodes().forEach(function(childSVG) {
        childrenHeight_1 += Number(DOMUtils2.getSVGElementSize(select(childSVG), {
          useBBox: true
        }).height);
      });
      childrenHeight_1 <= chartHeight ? select(this.mainContainer).attr("height", childrenHeight_1) : select(this.mainContainer).attr("height", "100%");
    }
  };
  DOMUtils2.prototype.getMainContainer = function() {
    return this.mainContainer;
  };
  DOMUtils2.prototype.addHolderListeners = function() {
    var _this = this;
    var holder = this.getHolder();
    if (!holder) {
      return;
    }
    select(holder).on("mouseover", function() {
      _this.services.events.dispatchEvent(Events$1.Chart.MOUSEOVER);
    }).on("mouseout", function() {
      _this.services.events.dispatchEvent(Events$1.Chart.MOUSEOUT);
    });
  };
  DOMUtils2.prototype.addResizeListener = function() {
    var _this = this;
    var holder = this.getHolder();
    if (!holder) {
      return;
    }
    var containerWidth = holder.clientWidth;
    var containerHeight = holder.clientHeight;
    var resizeCallback = Tools.debounce(function(entries, observer) {
      if (!holder) {
        return;
      }
      if (Math.abs(containerWidth - holder.clientWidth) > 1 || Math.abs(containerHeight - holder.clientHeight) > 1) {
        containerWidth = holder.clientWidth;
        containerHeight = holder.clientHeight;
        _this.services.events.dispatchEvent(Events$1.Chart.RESIZE);
      }
    }, 12.5);
    var resizeObserver = new index(resizeCallback);
    resizeObserver.observe(holder);
  };
  return DOMUtils2;
}(Service);
var __extends$1x = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Events = function(_super) {
  __extends$1x(Events2, _super);
  function Events2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Events2.prototype.init = function() {
    this.documentFragment = document.createDocumentFragment();
  };
  Events2.prototype.addEventListener = function(type2, listener) {
    this.documentFragment.addEventListener(type2, listener);
  };
  Events2.prototype.removeEventListener = function(type2, listener) {
    this.documentFragment.removeEventListener(type2, listener);
  };
  Events2.prototype.dispatchEvent = function(eventType, eventDetail) {
    var newEvent;
    if (eventDetail) {
      newEvent = new CustomEvent(eventType, {
        detail: eventDetail
      });
    } else {
      newEvent = document.createEvent("Event");
      newEvent.initEvent(eventType, false, true);
    }
    this.documentFragment.dispatchEvent(newEvent);
  };
  return Events2;
}(Service);
var __extends$1w = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Files = function(_super) {
  __extends$1w(Files2, _super);
  function Files2(model, services) {
    return _super.call(this, model, services) || this;
  }
  Files2.prototype.downloadCSV = function(content, filename) {
    var anchor = document.createElement("a");
    var mimeType = "text/csv;encoding:utf-8";
    if (navigator["msSaveBlob"]) {
      navigator["msSaveBlob"](new Blob([content], {
        type: mimeType
      }), filename);
    } else if (URL && "download" in anchor) {
      var href = URL.createObjectURL(new Blob([content], {
        type: mimeType
      }));
      anchor.href = href;
      anchor.setAttribute("download", filename);
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);
      URL.revokeObjectURL(href);
    } else {
      location.href = "data:application/octet-stream," + encodeURIComponent(content);
    }
  };
  Files2.prototype.downloadImage = function(uri, name) {
    var link2 = document.createElement("a");
    link2.download = name;
    link2.href = uri;
    document.body.appendChild(link2);
    link2.click();
    document.body.removeChild(link2);
  };
  return Files2;
}(Service);
var __extends$1v = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Transitions = function(_super) {
  __extends$1v(Transitions2, _super);
  function Transitions2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.pendingTransitions = {};
    return _this;
  }
  Transitions2.prototype.init = function() {
    var _this = this;
    this.services.events.addEventListener(Events$1.Model.UPDATE, function() {
      _this.pendingTransitions = {};
    });
  };
  Transitions2.prototype.setupTransition = function(_a2) {
    var _this = this;
    var t = _a2.transition, name = _a2.name, animate = _a2.animate;
    this.pendingTransitions[t._id] = t;
    t.on("end interrupt cancel", function() {
      delete _this.pendingTransitions[t._id];
    });
    if (this.model.getOptions().animations === false || animate === false) {
      return t.duration(0);
    }
    return t.duration(Tools.getProperty(transitions, name, "duration") || transitions.default.duration);
  };
  Transitions2.prototype.getPendingTransitions = function() {
    return this.pendingTransitions;
  };
  return Transitions2;
}(Service);
var __extends$1u = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var GradientUtils = function(_super) {
  __extends$1u(GradientUtils2, _super);
  function GradientUtils2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GradientUtils2.appendOrUpdateLinearGradient = function(configs) {
    var lg = configs.svg.select("defs linearGradient#" + configs.id);
    if (lg.empty()) {
      lg = configs.svg.append("defs").append("linearGradient").attr("id", configs.id).attr("x1", configs.x1).attr("x2", configs.x2).attr("y1", configs.y1).attr("y2", configs.y2);
    }
    lg.selectAll("stop").remove();
    lg.selectAll("stop").data(configs.stops).enter().append("stop").attr("offset", function(d) {
      return d.offset;
    }).style("stop-color", function(d) {
      return d.color;
    }).style("stop-opacity", function(d) {
      return d.opacity;
    });
  };
  GradientUtils2.getOffsetRatio = function(domain) {
    var offsetRatio = (Math.abs(domain[1]) * 100 / Math.abs(domain[0] - domain[1])).toFixed(2) + "%";
    return offsetRatio;
  };
  GradientUtils2.getStops = function(domain, color2) {
    var need3Stops = domain[0] < 0 && domain[1] > 0;
    var stops = [
      {
        offset: "0%",
        color: color2,
        opacity: "0.6"
      },
      {
        offset: "80%",
        color: color2,
        opacity: "0"
      }
    ];
    if (need3Stops) {
      stops = [
        {
          offset: "0%",
          color: color2,
          opacity: "0.6"
        },
        {
          offset: GradientUtils2.getOffsetRatio(domain),
          color: color2,
          opacity: "0"
        },
        {
          offset: "100%",
          color: color2,
          opacity: "0.6"
        }
      ];
    }
    return stops;
  };
  return GradientUtils2;
}(Service);
function toDate(argument) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number3 = Number(dirtyNumber);
  if (isNaN(number3)) {
    return number3;
  }
  return number3 < 0 ? Math.ceil(number3) : Math.floor(number3);
}
function addDays(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  date2.setDate(date2.getDate() + amount);
  return date2;
}
function addMilliseconds(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
var MILLISECONDS_IN_HOUR$1 = 36e5;
function addHours(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR$1);
}
var MILLISECONDS_IN_MINUTE$2 = 6e4;
function getTimezoneOffsetInMilliseconds(dirtyDate) {
  var date2 = new Date(dirtyDate.getTime());
  var baseTimezoneOffset = Math.ceil(date2.getTimezoneOffset());
  date2.setSeconds(0, 0);
  var millisecondsPartOfTimezoneOffset = date2.getTime() % MILLISECONDS_IN_MINUTE$2;
  return baseTimezoneOffset * MILLISECONDS_IN_MINUTE$2 + millisecondsPartOfTimezoneOffset;
}
function startOfDay(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  date2.setHours(0, 0, 0, 0);
  return date2;
}
var MILLISECONDS_IN_DAY$1 = 864e5;
function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY$1);
}
var MILLISECONDS_IN_MINUTE$1 = 6e4;
function addMinutes(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE$1);
}
function getDaysInMonth(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  var year2 = date2.getFullYear();
  var monthIndex = date2.getMonth();
  var lastDayOfMonth = new Date(0);
  lastDayOfMonth.setFullYear(year2, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}
function addMonths(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  var desiredMonth = date2.getMonth() + amount;
  var dateWithDesiredMonth = new Date(0);
  dateWithDesiredMonth.setFullYear(date2.getFullYear(), desiredMonth, 1);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
  date2.setMonth(desiredMonth, Math.min(daysInMonth, date2.getDate()));
  return date2;
}
function addSeconds(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * 1e3);
}
function addYears(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}
function compareAsc(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var diff = dateLeft.getTime() - dateRight.getTime();
  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
  } else {
    return diff;
  }
}
function isValid(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  return !isNaN(date2);
}
function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}
function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() - dateRight.getFullYear();
}
function differenceInDays(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign2 = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarDays(dateLeft, dateRight));
  dateLeft.setDate(dateLeft.getDate() - sign2 * difference);
  var isLastDayNotFull = compareAsc(dateLeft, dateRight) === -sign2;
  var result = sign2 * (difference - isLastDayNotFull);
  return result === 0 ? 0 : result;
}
function differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getTime() - dateRight.getTime();
}
var MILLISECONDS_IN_HOUR = 36e5;
function differenceInHours(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var diff = differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) / MILLISECONDS_IN_HOUR;
  return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
}
var MILLISECONDS_IN_MINUTE = 6e4;
function differenceInMinutes(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var diff = differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) / MILLISECONDS_IN_MINUTE;
  return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
}
function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign2 = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
  dateLeft.setMonth(dateLeft.getMonth() - sign2 * difference);
  var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign2;
  var result = sign2 * (difference - isLastMonthNotFull);
  return result === 0 ? 0 : result;
}
function differenceInSeconds(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var diff = differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) / 1e3;
  return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
}
function differenceInYears(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign2 = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarYears(dateLeft, dateRight));
  dateLeft.setFullYear(dateLeft.getFullYear() - sign2 * difference);
  var isLastYearNotFull = compareAsc(dateLeft, dateRight) === -sign2;
  var result = sign2 * (difference - isLastYearNotFull);
  return result === 0 ? 0 : result;
}
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
function formatDistance(token, count2, options2) {
  options2 = options2 || {};
  var result;
  if (typeof formatDistanceLocale[token] === "string") {
    result = formatDistanceLocale[token];
  } else if (count2 === 1) {
    result = formatDistanceLocale[token].one;
  } else {
    result = formatDistanceLocale[token].other.replace("{{count}}", count2);
  }
  if (options2.addSuffix) {
    if (options2.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
}
function buildFormatLongFn(args) {
  return function(dirtyOptions) {
    var options2 = dirtyOptions || {};
    var width = options2.width ? String(options2.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatLong$1 = formatLong;
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
}
function buildLocalizeFn(args) {
  return function(dirtyIndex, dirtyOptions) {
    var options2 = dirtyOptions || {};
    var context = options2.context ? String(options2.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options2.width ? String(options2.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options2.width ? String(options2.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index2];
  };
}
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
function ordinalNumber(dirtyNumber, _dirtyOptions) {
  var number3 = Number(dirtyNumber);
  var rem100 = number3 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number3 + "st";
      case 2:
        return number3 + "nd";
      case 3:
        return number3 + "rd";
    }
  }
  return number3 + "th";
}
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function(quarter) {
      return Number(quarter) - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
var localize$1 = localize;
function buildMatchPatternFn(args) {
  return function(dirtyString, dirtyOptions) {
    var string = String(dirtyString);
    var options2 = dirtyOptions || {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) {
      return null;
    }
    var value2 = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value2 = options2.valueCallback ? options2.valueCallback(value2) : value2;
    return {
      value: value2,
      rest: string.slice(matchedString.length)
    };
  };
}
function buildMatchFn(args) {
  return function(dirtyString, dirtyOptions) {
    var string = String(dirtyString);
    var options2 = dirtyOptions || {};
    var width = options2.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var value2;
    if (Object.prototype.toString.call(parsePatterns) === "[object Array]") {
      value2 = findIndex(parsePatterns, function(pattern) {
        return pattern.test(string);
      });
    } else {
      value2 = findKey(parsePatterns, function(pattern) {
        return pattern.test(string);
      });
    }
    value2 = args.valueCallback ? args.valueCallback(value2) : value2;
    value2 = options2.valueCallback ? options2.valueCallback(value2) : value2;
    return {
      value: value2,
      rest: string.slice(matchedString.length)
    };
  };
}
function findKey(object2, predicate) {
  for (var key in object2) {
    if (object2.hasOwnProperty(key) && predicate(object2[key])) {
      return key;
    }
  }
}
function findIndex(array2, predicate) {
  for (var key = 0; key < array2.length; key++) {
    if (predicate(array2[key])) {
      return key;
    }
  }
}
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function(value2) {
      return parseInt(value2, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var match$1 = match;
var locale = {
  code: "en-US",
  formatDistance,
  formatLong: formatLong$1,
  formatRelative,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var defaultLocale = locale;
function subMilliseconds(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
function addLeadingZeros(number3, targetLength) {
  var sign2 = number3 < 0 ? "-" : "";
  var output = Math.abs(number3).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign2 + output;
}
var formatters$2 = {
  y: function(date2, token) {
    var signedYear = date2.getUTCFullYear();
    var year2 = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year2 % 100 : year2, token.length);
  },
  M: function(date2, token) {
    var month2 = date2.getUTCMonth();
    return token === "M" ? String(month2 + 1) : addLeadingZeros(month2 + 1, 2);
  },
  d: function(date2, token) {
    return addLeadingZeros(date2.getUTCDate(), token.length);
  },
  a: function(date2, token) {
    var dayPeriodEnumValue = date2.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
      case "aaa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  h: function(date2, token) {
    return addLeadingZeros(date2.getUTCHours() % 12 || 12, token.length);
  },
  H: function(date2, token) {
    return addLeadingZeros(date2.getUTCHours(), token.length);
  },
  m: function(date2, token) {
    return addLeadingZeros(date2.getUTCMinutes(), token.length);
  },
  s: function(date2, token) {
    return addLeadingZeros(date2.getUTCSeconds(), token.length);
  },
  S: function(date2, token) {
    var numberOfDigits = token.length;
    var milliseconds = date2.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var formatters$3 = formatters$2;
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  var timestamp = date2.getTime();
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date2.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
function startOfUTCISOWeek(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var weekStartsOn = 1;
  var date2 = toDate(dirtyDate);
  var day2 = date2.getUTCDay();
  var diff = (day2 < weekStartsOn ? 7 : 0) + day2 - weekStartsOn;
  date2.setUTCDate(date2.getUTCDate() - diff);
  date2.setUTCHours(0, 0, 0, 0);
  return date2;
}
function getUTCISOWeekYear(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  var year2 = date2.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year2 + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year2, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date2.getTime() >= startOfNextYear.getTime()) {
    return year2 + 1;
  } else if (date2.getTime() >= startOfThisYear.getTime()) {
    return year2;
  } else {
    return year2 - 1;
  }
}
function startOfUTCISOWeekYear(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var year2 = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year2, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date2 = startOfUTCISOWeek(fourthOfJanuary);
  return date2;
}
var MILLISECONDS_IN_WEEK$1 = 6048e5;
function getUTCISOWeek(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date2).getTime() - startOfUTCISOWeekYear(date2).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}
function startOfUTCWeek(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var options2 = dirtyOptions || {};
  var locale2 = options2.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options2.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options2.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date2 = toDate(dirtyDate);
  var day2 = date2.getUTCDay();
  var diff = (day2 < weekStartsOn ? 7 : 0) + day2 - weekStartsOn;
  date2.setUTCDate(date2.getUTCDate() - diff);
  date2.setUTCHours(0, 0, 0, 0);
  return date2;
}
function getUTCWeekYear(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate, dirtyOptions);
  var year2 = date2.getUTCFullYear();
  var options2 = dirtyOptions || {};
  var locale2 = options2.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options2.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options2.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year2 + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year2, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);
  if (date2.getTime() >= startOfNextYear.getTime()) {
    return year2 + 1;
  } else if (date2.getTime() >= startOfThisYear.getTime()) {
    return year2;
  } else {
    return year2 - 1;
  }
}
function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var options2 = dirtyOptions || {};
  var locale2 = options2.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options2.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options2.firstWeekContainsDate);
  var year2 = getUTCWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year2, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date2 = startOfUTCWeek(firstWeek, dirtyOptions);
  return date2;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCWeek(dirtyDate, options2) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  var diff = startOfUTCWeek(date2, options2).getTime() - startOfUTCWeekYear(date2, options2).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  G: function(date2, token, localize2) {
    var era = date2.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  y: function(date2, token, localize2) {
    if (token === "yo") {
      var signedYear = date2.getUTCFullYear();
      var year2 = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year2, {
        unit: "year"
      });
    }
    return formatters$3.y(date2, token);
  },
  Y: function(date2, token, localize2, options2) {
    var signedWeekYear = getUTCWeekYear(date2, options2);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  R: function(date2, token) {
    var isoWeekYear = getUTCISOWeekYear(date2);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  u: function(date2, token) {
    var year2 = date2.getUTCFullYear();
    return addLeadingZeros(year2, token.length);
  },
  Q: function(date2, token, localize2) {
    var quarter = Math.ceil((date2.getUTCMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  q: function(date2, token, localize2) {
    var quarter = Math.ceil((date2.getUTCMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  M: function(date2, token, localize2) {
    var month2 = date2.getUTCMonth();
    switch (token) {
      case "M":
      case "MM":
        return formatters$3.M(date2, token);
      case "Mo":
        return localize2.ordinalNumber(month2 + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month2, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month2, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month2, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  L: function(date2, token, localize2) {
    var month2 = date2.getUTCMonth();
    switch (token) {
      case "L":
        return String(month2 + 1);
      case "LL":
        return addLeadingZeros(month2 + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month2 + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month2, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month2, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month2, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  w: function(date2, token, localize2, options2) {
    var week = getUTCWeek(date2, options2);
    if (token === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token.length);
  },
  I: function(date2, token, localize2) {
    var isoWeek = getUTCISOWeek(date2);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  d: function(date2, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date2.getUTCDate(), {
        unit: "date"
      });
    }
    return formatters$3.d(date2, token);
  },
  D: function(date2, token, localize2) {
    var dayOfYear = getUTCDayOfYear(date2);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  E: function(date2, token, localize2) {
    var dayOfWeek = date2.getUTCDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  e: function(date2, token, localize2, options2) {
    var dayOfWeek = date2.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  c: function(date2, token, localize2, options2) {
    var dayOfWeek = date2.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  i: function(date2, token, localize2) {
    var dayOfWeek = date2.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  a: function(date2, token, localize2) {
    var hours = date2.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  b: function(date2, token, localize2) {
    var hours = date2.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  B: function(date2, token, localize2) {
    var hours = date2.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  h: function(date2, token, localize2) {
    if (token === "ho") {
      var hours = date2.getUTCHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return formatters$3.h(date2, token);
  },
  H: function(date2, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date2.getUTCHours(), {
        unit: "hour"
      });
    }
    return formatters$3.H(date2, token);
  },
  K: function(date2, token, localize2) {
    var hours = date2.getUTCHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  k: function(date2, token, localize2) {
    var hours = date2.getUTCHours();
    if (hours === 0)
      hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  m: function(date2, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date2.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return formatters$3.m(date2, token);
  },
  s: function(date2, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date2.getUTCSeconds(), {
        unit: "second"
      });
    }
    return formatters$3.s(date2, token);
  },
  S: function(date2, token) {
    return formatters$3.S(date2, token);
  },
  X: function(date2, token, _localize, options2) {
    var originalDate = options2._originalDate || date2;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  x: function(date2, token, _localize, options2) {
    var originalDate = options2._originalDate || date2;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  O: function(date2, token, _localize, options2) {
    var originalDate = options2._originalDate || date2;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  z: function(date2, token, _localize, options2) {
    var originalDate = options2._originalDate || date2;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  t: function(date2, token, _localize, options2) {
    var originalDate = options2._originalDate || date2;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  T: function(date2, token, _localize, options2) {
    var originalDate = options2._originalDate || date2;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign2 = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign2 + String(hours);
  }
  var delimiter = dirtyDelimiter || "";
  return sign2 + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign2 = offset > 0 ? "-" : "+";
    return sign2 + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign2 = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign2 + hours + delimiter + minutes;
}
var formatters$1 = formatters;
function dateLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
}
function timeLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
}
function dateTimeLongFormatter(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/);
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
}
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters$1 = longFormatters;
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` for formatting years; see: https://git.io/fxCyr");
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` for formatting years; see: https://git.io/fxCyr");
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` for formatting days of the month; see: https://git.io/fxCyr");
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` for formatting days of the month; see: https://git.io/fxCyr");
  }
}
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var formatStr = String(dirtyFormatStr);
  var options2 = dirtyOptions || {};
  var locale2 = options2.locale || defaultLocale;
  var localeFirstWeekContainsDate = locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options2.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options2.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var localeWeekStartsOn = locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options2.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options2.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate2 = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale2.formatLong, formatterOptions);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = formatters$1[firstCharacter];
    if (formatter) {
      if (!options2.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring);
      }
      if (!options2.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring);
      }
      return formatter(utcDate2, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
function subDays(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addDays(dirtyDate, -amount);
}
function subHours(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addHours(dirtyDate, -amount);
}
function subMinutes(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addMinutes(dirtyDate, -amount);
}
function subMonths(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, -amount);
}
function subSeconds(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addSeconds(dirtyDate, -amount);
}
function subYears(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addYears(dirtyDate, -amount);
}
var __extends$1t = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __rest$1 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __spreadArrays$j = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var CartesianScales = function(_super) {
  __extends$1t(CartesianScales2, _super);
  function CartesianScales2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.scaleTypes = {
      top: null,
      right: null,
      bottom: null,
      left: null
    };
    _this.scales = {
      top: null,
      right: null,
      bottom: null,
      left: null
    };
    return _this;
  }
  CartesianScales2.prototype.getDomainAxisPosition = function(_a2) {
    var _b = (_a2 === void 0 ? {} : _a2).datum, datum2 = _b === void 0 ? null : _b;
    var _c;
    if (this.dualAxes && datum2) {
      var options2 = this.model.getOptions();
      var groupMapsTo = options2.data.groupMapsTo;
      var axesOptions = Tools.getProperty(options2, "axes", this.secondaryDomainAxisPosition);
      var dataset = datum2[groupMapsTo];
      if (((_c = axesOptions) === null || _c === void 0 ? void 0 : _c.correspondingDatasets) && axesOptions.correspondingDatasets.includes(dataset)) {
        return this.secondaryDomainAxisPosition;
      }
    }
    return this.domainAxisPosition;
  };
  CartesianScales2.prototype.getRangeAxisPosition = function(_a2) {
    var _b = _a2 === void 0 ? {} : _a2, _c = _b.datum, datum2 = _c === void 0 ? null : _c, _d = _b.groups, groups = _d === void 0 ? null : _d;
    var _e;
    if (this.dualAxes) {
      var options2 = this.model.getOptions();
      var groupMapsTo = options2.data.groupMapsTo;
      var axisOptions = Tools.getProperty(options2, "axes", this.secondaryRangeAxisPosition);
      var dataset = void 0;
      if (datum2 !== null) {
        dataset = datum2[groupMapsTo];
      } else if (groups && groups.length > 0) {
        dataset = groups[0];
      }
      if (((_e = axisOptions) === null || _e === void 0 ? void 0 : _e.correspondingDatasets) && axisOptions.correspondingDatasets.includes(dataset)) {
        return this.secondaryRangeAxisPosition;
      }
    }
    return this.rangeAxisPosition;
  };
  CartesianScales2.prototype.getAxisOptions = function(position) {
    return Tools.getProperty(this.model.getOptions(), "axes", position);
  };
  CartesianScales2.prototype.getDomainAxisOptions = function() {
    var domainAxisPosition = this.getDomainAxisPosition();
    return this.getAxisOptions(domainAxisPosition);
  };
  CartesianScales2.prototype.getRangeAxisOptions = function() {
    var rangeAxisPosition = this.getRangeAxisPosition();
    return this.getAxisOptions(rangeAxisPosition);
  };
  CartesianScales2.prototype.getScaleLabel = function(position) {
    var axisOptions = this.getAxisOptions(position);
    var title = axisOptions.title;
    if (!title) {
      if (position === AxisPositions.BOTTOM || position === AxisPositions.TOP) {
        return "x-value";
      }
      return "y-value";
    }
    return title;
  };
  CartesianScales2.prototype.getDomainLabel = function() {
    return this.getScaleLabel(this.getDomainAxisPosition());
  };
  CartesianScales2.prototype.getRangeLabel = function() {
    return this.getScaleLabel(this.getRangeAxisPosition());
  };
  CartesianScales2.prototype.update = function(animate) {
    var _this = this;
    this.determineAxisDuality();
    this.findDomainAndRangeAxes();
    this.determineOrientation();
    var axisPositions = Object.keys(AxisPositions).map(function(axisPositionKey) {
      return AxisPositions[axisPositionKey];
    });
    axisPositions.forEach(function(axisPosition) {
      _this.scales[axisPosition] = _this.createScale(axisPosition);
    });
  };
  CartesianScales2.prototype.findDomainAndRangeAxes = function() {
    var verticalAxesPositions = this.findVerticalAxesPositions();
    var horizontalAxesPositions = this.findHorizontalAxesPositions();
    var domainAndRangeAxesPositions = this.findDomainAndRangeAxesPositions(verticalAxesPositions, horizontalAxesPositions);
    this.domainAxisPosition = domainAndRangeAxesPositions.primaryDomainAxisPosition;
    this.rangeAxisPosition = domainAndRangeAxesPositions.primaryRangeAxisPosition;
    if (this.isDualAxes()) {
      this.secondaryDomainAxisPosition = domainAndRangeAxesPositions.secondaryDomainAxisPosition;
      this.secondaryRangeAxisPosition = domainAndRangeAxesPositions.secondaryRangeAxisPosition;
    }
  };
  CartesianScales2.prototype.determineOrientation = function() {
    if ((this.rangeAxisPosition === AxisPositions.LEFT || this.rangeAxisPosition === AxisPositions.RIGHT) && (this.domainAxisPosition === AxisPositions.BOTTOM || this.domainAxisPosition === AxisPositions.TOP)) {
      this.orientation = CartesianOrientations.VERTICAL;
    } else {
      this.orientation = CartesianOrientations.HORIZONTAL;
    }
  };
  CartesianScales2.prototype.isDualAxes = function() {
    return this.dualAxes;
  };
  CartesianScales2.prototype.determineAxisDuality = function() {
    var _a2, _b, _c, _d;
    var options2 = this.model.getOptions();
    var axesOptions = Tools.getProperty(options2, "axes");
    if (((_a2 = axesOptions[AxisPositions.LEFT]) === null || _a2 === void 0 ? void 0 : _a2.correspondingDatasets) && axesOptions[AxisPositions.RIGHT] || ((_b = axesOptions[AxisPositions.RIGHT]) === null || _b === void 0 ? void 0 : _b.correspondingDatasets) && axesOptions[AxisPositions.LEFT] || ((_c = axesOptions[AxisPositions.TOP]) === null || _c === void 0 ? void 0 : _c.correspondingDatasets) && axesOptions[AxisPositions.BOTTOM] || ((_d = axesOptions[AxisPositions.BOTTOM]) === null || _d === void 0 ? void 0 : _d.correspondingDatasets) && axesOptions[AxisPositions.TOP]) {
      this.dualAxes = true;
    }
  };
  CartesianScales2.prototype.getCustomDomainValuesByposition = function(axisPosition) {
    var domain = Tools.getProperty(this.model.getOptions(), "axes", axisPosition, "domain");
    if (domain && !Array.isArray(domain)) {
      throw new Error("Domain in " + axisPosition + " axis is not a valid array");
    }
    if (Array.isArray(domain)) {
      if ((this.scaleTypes[axisPosition] === ScaleTypes.LINEAR || this.scaleTypes[axisPosition] === ScaleTypes.TIME) && domain.length !== 2) {
        throw new Error("There can only be 2 elements in domain for scale type: " + this.scaleTypes[axisPosition]);
      }
    }
    return domain;
  };
  CartesianScales2.prototype.getOrientation = function() {
    return this.orientation;
  };
  CartesianScales2.prototype.getScaleByPosition = function(axisPosition) {
    return this.scales[axisPosition];
  };
  CartesianScales2.prototype.getScaleTypeByPosition = function(axisPosition) {
    return this.scaleTypes[axisPosition];
  };
  CartesianScales2.prototype.getDomainAxisScaleType = function() {
    var domainAxisPosition = this.getDomainAxisPosition();
    return this.getScaleTypeByPosition(domainAxisPosition);
  };
  CartesianScales2.prototype.getRangeAxisScaleType = function() {
    var rangeAxisPosition = this.getRangeAxisPosition();
    return this.getScaleTypeByPosition(rangeAxisPosition);
  };
  CartesianScales2.prototype.getDomainScale = function() {
    return this.scales[this.domainAxisPosition];
  };
  CartesianScales2.prototype.getRangeScale = function() {
    return this.scales[this.rangeAxisPosition];
  };
  CartesianScales2.prototype.getMainXAxisPosition = function() {
    var possibleXAxisPositions = [
      AxisPositions.BOTTOM,
      AxisPositions.TOP
    ];
    return [this.domainAxisPosition, this.rangeAxisPosition].find(function(position) {
      return possibleXAxisPositions.indexOf(position) > -1;
    });
  };
  CartesianScales2.prototype.getMainYAxisPosition = function() {
    var possibleYAxisPositions = [
      AxisPositions.LEFT,
      AxisPositions.RIGHT
    ];
    return [this.domainAxisPosition, this.rangeAxisPosition].find(function(position) {
      return possibleYAxisPositions.indexOf(position) > -1;
    });
  };
  CartesianScales2.prototype.getMainXScale = function() {
    return this.scales[this.getMainXAxisPosition()];
  };
  CartesianScales2.prototype.getMainYScale = function() {
    return this.scales[this.getMainYAxisPosition()];
  };
  CartesianScales2.prototype.getValueFromScale = function(scale, scaleType, axisPosition, datum2, index2) {
    var options2 = this.model.getOptions();
    var axesOptions = Tools.getProperty(options2, "axes");
    var axisOptions = axesOptions[axisPosition];
    var mapsTo = axisOptions.mapsTo;
    var value2 = Tools.getProperty(datum2, mapsTo) !== null ? datum2[mapsTo] : datum2;
    var scaledValue;
    switch (scaleType) {
      case ScaleTypes.LABELS:
        scaledValue = scale(value2) + scale.step() / 2;
        break;
      case ScaleTypes.TIME:
        scaledValue = scale(new Date(value2));
        break;
      default:
        scaledValue = scale(value2);
    }
    return scaledValue;
  };
  CartesianScales2.prototype.getBoundedScaledValues = function(datum2, index2) {
    var bounds = this.model.getOptions().bounds;
    var axisPosition = this.getRangeAxisPosition({ datum: datum2 });
    var scale = this.scales[axisPosition];
    var options2 = this.model.getOptions();
    var axesOptions = Tools.getProperty(options2, "axes");
    var axisOptions = axesOptions[axisPosition];
    var mapsTo = axisOptions.mapsTo;
    var value2 = datum2[mapsTo] !== void 0 ? datum2[mapsTo] : datum2;
    var boundedValues = [
      scale(Tools.getProperty(datum2, bounds.upperBoundMapsTo) !== null ? datum2[bounds.upperBoundMapsTo] : value2),
      scale(Tools.getProperty(datum2, bounds.lowerBoundMapsTo) !== null ? datum2[bounds.lowerBoundMapsTo] : value2)
    ];
    return boundedValues;
  };
  CartesianScales2.prototype.getValueThroughAxisPosition = function(axisPosition, datum2, index2) {
    var scaleType = this.scaleTypes[axisPosition];
    var scale = this.scales[axisPosition];
    return this.getValueFromScale(scale, scaleType, axisPosition, datum2, index2);
  };
  CartesianScales2.prototype.getDomainValue = function(d, i) {
    var axisPosition = this.getDomainAxisPosition({ datum: d });
    return this.getValueThroughAxisPosition(axisPosition, d, i);
  };
  CartesianScales2.prototype.getRangeValue = function(d, i) {
    var axisPosition = this.getRangeAxisPosition({ datum: d });
    return this.getValueThroughAxisPosition(axisPosition, d, i);
  };
  CartesianScales2.prototype.getMainXScaleType = function() {
    return this.getScaleTypeByPosition(this.getMainXAxisPosition());
  };
  CartesianScales2.prototype.getMainYScaleType = function() {
    return this.getScaleTypeByPosition(this.getMainYAxisPosition());
  };
  CartesianScales2.prototype.getDomainIdentifier = function(datum2) {
    var options2 = this.model.getOptions();
    return Tools.getProperty(options2, "axes", this.getDomainAxisPosition({ datum: datum2 }), "mapsTo");
  };
  CartesianScales2.prototype.getRangeIdentifier = function(datum2) {
    var options2 = this.model.getOptions();
    return Tools.getProperty(options2, "axes", this.getRangeAxisPosition({ datum: datum2 }), "mapsTo");
  };
  CartesianScales2.prototype.extendsDomain = function(axisPosition, domain) {
    var options2 = this.model.getOptions();
    var axisOptions = Tools.getProperty(options2, "axes", axisPosition);
    if (axisOptions.scaleType === ScaleTypes.TIME) {
      var spaceToAddToEdges = Tools.getProperty(options2, "timeScale", "addSpaceOnEdges");
      return addSpacingToTimeDomain(domain, spaceToAddToEdges);
    } else {
      return addSpacingToContinuousDomain(domain, axis$1.paddingRatio, axisOptions.scaleType);
    }
  };
  CartesianScales2.prototype.findVerticalAxesPositions = function() {
    var options2 = this.model.getOptions();
    var axesOptions = Tools.getProperty(options2, "axes");
    var dualAxes = this.isDualAxes();
    if (Tools.getProperty(axesOptions, AxisPositions.LEFT) === null && Tools.getProperty(axesOptions, AxisPositions.RIGHT) !== null || Tools.getProperty(axesOptions, AxisPositions.RIGHT, "main") === true || dualAxes && Tools.getProperty(axesOptions, AxisPositions.LEFT, "correspondingDatasets")) {
      return {
        primary: AxisPositions.RIGHT,
        secondary: AxisPositions.LEFT
      };
    }
    return { primary: AxisPositions.LEFT, secondary: AxisPositions.RIGHT };
  };
  CartesianScales2.prototype.findHorizontalAxesPositions = function() {
    var options2 = this.model.getOptions();
    var axesOptions = Tools.getProperty(options2, "axes");
    var dualAxes = this.isDualAxes();
    if (Tools.getProperty(axesOptions, AxisPositions.BOTTOM) === null && Tools.getProperty(axesOptions, AxisPositions.TOP) !== null || Tools.getProperty(axesOptions, AxisPositions.TOP, "main") === true || dualAxes && Tools.getProperty(axesOptions, AxisPositions.BOTTOM, "correspondingDatasets")) {
      return {
        primary: AxisPositions.TOP,
        secondary: AxisPositions.BOTTOM
      };
    }
    return { primary: AxisPositions.BOTTOM, secondary: AxisPositions.TOP };
  };
  CartesianScales2.prototype.findDomainAndRangeAxesPositions = function(verticalAxesPositions, horizontalAxesPositions) {
    var options2 = this.model.getOptions();
    var mainVerticalAxisOptions = Tools.getProperty(options2, "axes", verticalAxesPositions.primary);
    var mainHorizontalAxisOptions = Tools.getProperty(options2, "axes", horizontalAxesPositions.primary);
    var mainVerticalScaleType = mainVerticalAxisOptions.scaleType || ScaleTypes.LINEAR;
    var mainHorizontalScaleType = mainHorizontalAxisOptions.scaleType || ScaleTypes.LINEAR;
    var result = {
      primaryDomainAxisPosition: null,
      secondaryDomainAxisPosition: null,
      primaryRangeAxisPosition: null,
      secondaryRangeAxisPosition: null
    };
    result.primaryDomainAxisPosition = horizontalAxesPositions.primary;
    result.primaryRangeAxisPosition = verticalAxesPositions.primary;
    result.secondaryDomainAxisPosition = horizontalAxesPositions.secondary;
    result.secondaryRangeAxisPosition = verticalAxesPositions.secondary;
    if (!(mainHorizontalScaleType === ScaleTypes.LABELS || mainHorizontalScaleType === ScaleTypes.TIME) && mainVerticalScaleType === ScaleTypes.LABELS || mainVerticalScaleType === ScaleTypes.TIME) {
      result.primaryDomainAxisPosition = verticalAxesPositions.primary;
      result.primaryRangeAxisPosition = horizontalAxesPositions.primary;
      result.secondaryDomainAxisPosition = verticalAxesPositions.secondary;
      result.secondaryRangeAxisPosition = horizontalAxesPositions.secondary;
    }
    return result;
  };
  CartesianScales2.prototype.getScaleDomain = function(axisPosition) {
    var options2 = this.model.getOptions();
    var axisOptions = Tools.getProperty(options2, "axes", axisPosition);
    var bounds = Tools.getProperty(options2, "bounds");
    var includeZero = axisOptions.includeZero;
    var scaleType = Tools.getProperty(axisOptions, "scaleType") || ScaleTypes.LINEAR;
    if (this.model.isDataEmpty()) {
      return [];
    }
    if (axisOptions.binned) {
      var bins = this.model.getBinConfigurations().bins;
      return [0, max$3(bins, function(d) {
        return d.length;
      })];
    } else if (axisOptions.limitDomainToBins) {
      var bins = this.model.getBinConfigurations().bins;
      var stackKeys = this.model.getStackKeys({ bins });
      return [
        stackKeys[0].split("-")[0],
        stackKeys[stackKeys.length - 1].split("-")[1]
      ];
    }
    var displayData = this.model.getDisplayData();
    var extendLinearDomainBy = axisOptions.extendLinearDomainBy, mapsTo = axisOptions.mapsTo, percentage = axisOptions.percentage, thresholds = axisOptions.thresholds;
    var _a2 = axis$1.ratio, ratioReference = _a2.reference, ratioCompareTo = _a2.compareTo;
    if (axisOptions.domain) {
      if (scaleType === ScaleTypes.LABELS) {
        return axisOptions.domain;
      } else if (scaleType === ScaleTypes.TIME) {
        axisOptions.domain = axisOptions.domain.map(function(d) {
          return d.getTime === void 0 ? new Date(d) : d;
        });
      }
      return this.extendsDomain(axisPosition, axisOptions.domain);
    }
    if (percentage) {
      return [0, 100];
    }
    if (axisOptions && scaleType === ScaleTypes.LABELS) {
      return Tools.removeArrayDuplicates(displayData.map(function(d) {
        return d[mapsTo];
      }));
    }
    var domain;
    var allDataValues;
    var dataGroupNames = this.model.getDataGroupNames();
    if (scaleType === ScaleTypes.LABELS_RATIO) {
      return displayData.map(function(datum2) {
        return datum2[ratioReference] + "/" + datum2[ratioCompareTo];
      });
    } else if (scaleType === ScaleTypes.TIME) {
      allDataValues = displayData.map(function(datum2) {
        return +new Date(datum2[mapsTo]);
      });
    } else if (bounds && options2.axes) {
      allDataValues = [];
      displayData.forEach(function(datum2) {
        allDataValues.push(datum2[mapsTo]);
        if (datum2[bounds.upperBoundMapsTo]) {
          allDataValues.push(datum2[bounds.upperBoundMapsTo]);
        }
        if (datum2[bounds.lowerBoundMapsTo]) {
          allDataValues.push(datum2[bounds.lowerBoundMapsTo]);
        }
      });
    } else if (axisOptions.stacked === true && dataGroupNames && axisPosition === this.getRangeAxisPosition()) {
      var groupMapsTo_1 = options2.data.groupMapsTo;
      var dataValuesGroupedByKeys = this.model.getDataValuesGroupedByKeys({
        groups: dataGroupNames
      });
      var nonStackedGroupsData = displayData.filter(function(datum2) {
        return !dataGroupNames.includes(datum2[groupMapsTo_1]);
      });
      var stackedValues_1 = [];
      dataValuesGroupedByKeys.forEach(function(dataValues) {
        dataValues.sharedStackKey;
        var numericalValues = __rest$1(dataValues, ["sharedStackKey"]);
        var positiveSum = 0, negativeSum = 0;
        Object.values(numericalValues).forEach(function(value2) {
          if (!isNaN(value2)) {
            if (value2 < 0) {
              negativeSum += value2;
            } else {
              positiveSum += value2;
            }
          }
        });
        stackedValues_1.push([negativeSum, positiveSum]);
      });
      allDataValues = __spreadArrays$j(Tools.flatten(stackedValues_1), nonStackedGroupsData.map(function(datum2) {
        return datum2[mapsTo];
      }));
    } else {
      allDataValues = [];
      displayData.forEach(function(datum2) {
        var value2 = datum2[mapsTo];
        if (Array.isArray(value2) && value2.length === 2) {
          allDataValues.push(value2[0]);
          allDataValues.push(value2[1]);
        } else {
          if (extendLinearDomainBy) {
            allDataValues.push(Math.max(datum2[mapsTo], datum2[extendLinearDomainBy]));
          }
          allDataValues.push(value2);
        }
      });
    }
    if (scaleType !== ScaleTypes.TIME && scaleType !== ScaleTypes.LOG && includeZero) {
      allDataValues.push(0);
    }
    if (thresholds && thresholds.length > 0) {
      thresholds.forEach(function(threshold) {
        var thresholdValue = Tools.getProperty(threshold, "value");
        if (thresholdValue !== null)
          allDataValues.push(thresholdValue);
      });
    }
    domain = extent(allDataValues);
    domain = this.extendsDomain(axisPosition, domain);
    return domain;
  };
  CartesianScales2.prototype.createScale = function(axisPosition) {
    var options2 = this.model.getOptions();
    var axisOptions = Tools.getProperty(options2, "axes", axisPosition);
    if (!axisOptions) {
      return null;
    }
    var scaleType = Tools.getProperty(axisOptions, "scaleType") || ScaleTypes.LINEAR;
    this.scaleTypes[axisPosition] = scaleType;
    var scale;
    if (scaleType === ScaleTypes.TIME) {
      scale = time();
    } else if (scaleType === ScaleTypes.LOG) {
      scale = log().base(axisOptions.base || 10);
    } else if (scaleType === ScaleTypes.LABELS || scaleType === ScaleTypes.LABELS_RATIO) {
      scale = band();
    } else {
      scale = linear();
    }
    scale.domain(this.getScaleDomain(axisPosition));
    return scale;
  };
  CartesianScales2.prototype.getHighestDomainThreshold = function() {
    var axesOptions = Tools.getProperty(this.model.getOptions(), "axes");
    var domainAxisPosition = this.getDomainAxisPosition();
    var thresholds = axesOptions[domainAxisPosition].thresholds;
    if (!Array.isArray(thresholds) || Array.isArray(thresholds) && !thresholds.length) {
      return null;
    }
    var domainScale = this.getDomainScale();
    var highestThreshold = thresholds.sort(function(a, b) {
      return b.value - a.value;
    })[0];
    var scaleType = this.getScaleTypeByPosition(domainAxisPosition);
    if (scaleType === ScaleTypes.TIME && (typeof highestThreshold.value === "string" || highestThreshold.value.getTime === void 0)) {
      highestThreshold.value = new Date(highestThreshold.value);
    }
    return {
      threshold: highestThreshold,
      scaleValue: domainScale(highestThreshold.value)
    };
  };
  CartesianScales2.prototype.getHighestRangeThreshold = function() {
    var axesOptions = Tools.getProperty(this.model.getOptions(), "axes");
    var rangeAxisPosition = this.getRangeAxisPosition();
    var thresholds = axesOptions[rangeAxisPosition].thresholds;
    if (!Array.isArray(thresholds) || Array.isArray(thresholds) && !thresholds.length) {
      return null;
    }
    var rangeScale = this.getRangeScale();
    var highestThreshold = thresholds.sort(function(a, b) {
      return b.value - a.value;
    })[0];
    return {
      threshold: highestThreshold,
      scaleValue: rangeScale(highestThreshold.value)
    };
  };
  return CartesianScales2;
}(Service);
function addSpacingToTimeDomain(domain, spaceToAddToEdges) {
  var startDate = new Date(domain[0]);
  var endDate = new Date(domain[1]);
  if (differenceInYears(endDate, startDate) > 1) {
    return [
      subYears(startDate, spaceToAddToEdges),
      addYears(endDate, spaceToAddToEdges)
    ];
  }
  if (differenceInMonths(endDate, startDate) > 1) {
    return [
      subMonths(startDate, spaceToAddToEdges),
      addMonths(endDate, spaceToAddToEdges)
    ];
  }
  if (differenceInDays(endDate, startDate) > 1) {
    return [
      subDays(startDate, spaceToAddToEdges),
      addDays(endDate, spaceToAddToEdges)
    ];
  }
  if (differenceInHours(endDate, startDate) > 1) {
    return [
      subHours(startDate, spaceToAddToEdges),
      addHours(endDate, spaceToAddToEdges)
    ];
  }
  if (differenceInMinutes(endDate, startDate) > 30) {
    return [
      subMinutes(startDate, spaceToAddToEdges * 30),
      addMinutes(endDate, spaceToAddToEdges * 30)
    ];
  }
  if (differenceInMinutes(endDate, startDate) > 1) {
    return [
      subMinutes(startDate, spaceToAddToEdges),
      addMinutes(endDate, spaceToAddToEdges)
    ];
  }
  if (differenceInSeconds(endDate, startDate) > 15) {
    return [
      subSeconds(startDate, spaceToAddToEdges * 15),
      addSeconds(endDate, spaceToAddToEdges * 15)
    ];
  }
  if (differenceInSeconds(endDate, startDate) > 1) {
    return [
      subSeconds(startDate, spaceToAddToEdges),
      addSeconds(endDate, spaceToAddToEdges)
    ];
  }
  return [startDate, endDate];
}
function addSpacingToContinuousDomain(_a2, paddingRatio, scaleType) {
  var lower2 = _a2[0], upper = _a2[1];
  var domainLength = upper - lower2;
  var padding = domainLength * paddingRatio;
  var newUpper = upper <= 0 && upper + padding > 0 ? 0 : upper + padding;
  var newLower = lower2 >= 0 && lower2 - padding < 0 ? 0 : lower2 - padding;
  if (scaleType === ScaleTypes.LOG && newLower <= 0) {
    if (lower2 <= 0) {
      throw Error("Data must have values greater than 0 if log scale type is used.");
    }
    newLower = lower2;
  }
  return [newLower, newUpper];
}
var __extends$1s = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Curves = function(_super) {
  __extends$1s(Curves2, _super);
  function Curves2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.curveTypes = {
      curveLinear,
      curveLinearClosed,
      curveBasis,
      curveBasisClosed,
      curveBasisOpen,
      curveBundle,
      curveCardinal,
      curveCardinalClosed,
      curveCardinalOpen,
      curveCatmullRom,
      curveCatmullRomClosed,
      curveCatmullRomOpen,
      curveMonotoneX: monotoneX,
      curveMonotoneY: monotoneY,
      curveNatural,
      curveStep,
      curveStepAfter: stepAfter,
      curveStepBefore: stepBefore
    };
    return _this;
  }
  Curves2.prototype.getD3Curve = function() {
    var curveName = "curveLinear";
    var curveOptions = this.model.getOptions().curve;
    if (curveOptions) {
      if (typeof curveOptions === "string") {
        curveName = curveOptions;
      } else {
        curveName = curveOptions.name;
      }
    }
    if (this.curveTypes[curveName]) {
      var curve_1 = this.curveTypes[curveName];
      if (curveOptions) {
        Object.keys(curveOptions).forEach(function(optionName) {
          if (curve_1[optionName]) {
            curve_1 = curve_1[optionName](curveOptions[optionName]);
          }
        });
      }
      return curve_1;
    }
    console.warn("The curve type '" + curveName + "' is invalid, using 'curveLinear' instead");
    return this.curveTypes["curveLinear"];
  };
  return Curves2;
}(Service);
var __extends$1r = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Zoom = function(_super) {
  __extends$1r(Zoom2, _super);
  function Zoom2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Zoom2.prototype.isZoomBarEnabled = function() {
    if (!this.services.cartesianScales) {
      return false;
    }
    if (!Tools.getProperty(this.model.getOptions(), "zoomBar", "top", "enabled")) {
      return false;
    }
    this.services.cartesianScales.findDomainAndRangeAxes();
    var mainXAxisPosition = this.services.cartesianScales.getMainXAxisPosition();
    var mainXScaleType = Tools.getProperty(this.model.getOptions(), "axes", mainXAxisPosition, "scaleType");
    return mainXAxisPosition === AxisPositions.BOTTOM && mainXScaleType === ScaleTypes.TIME;
  };
  Zoom2.prototype.getZoomBarData = function() {
    var customZoomBarData = this.model.getZoomBarData();
    if (customZoomBarData && customZoomBarData.length > 1) {
      return customZoomBarData;
    } else {
      return this.model.getDisplayData();
    }
  };
  Zoom2.prototype.getDefaultZoomBarDomain = function(zoomBarData) {
    var allZoomBarData = zoomBarData || this.services.zoom.getZoomBarData();
    var cartesianScales = this.services.cartesianScales;
    var mainXAxisPosition = cartesianScales.getMainXAxisPosition();
    var domainIdentifier = cartesianScales.getDomainIdentifier();
    var customDomain = Tools.getProperty(this.model.getOptions(), "axes", mainXAxisPosition, "domain");
    if (Array.isArray(customDomain) && customDomain.length === 2) {
      return customDomain;
    }
    return cartesianScales.extendsDomain(mainXAxisPosition, extent(allZoomBarData, function(d) {
      return d[domainIdentifier];
    }));
  };
  Zoom2.prototype.handleDomainChange = function(newDomain, configs) {
    if (configs === void 0) {
      configs = { dispatchEvent: true };
    }
    this.model.set({ zoomDomain: newDomain }, { animate: false });
    if (configs.dispatchEvent) {
      this.services.events.dispatchEvent(Events$1.ZoomDomain.CHANGE, {
        newDomain
      });
    }
  };
  Zoom2.prototype.getZoomRatio = function() {
    return Tools.getProperty(this.model.getOptions(), "zoomBar", "zoomRatio");
  };
  Zoom2.prototype.filterDataForRangeAxis = function(displayData, configs) {
    var zoomDomain = this.model.get("zoomDomain");
    var mergedConfigs = Object.assign({ stacked: false }, configs);
    var shouldUpdateRangeAxis = Tools.getProperty(this.model.getOptions(), "zoomBar", "updateRangeAxis");
    if (this.isZoomBarEnabled() && shouldUpdateRangeAxis && zoomDomain) {
      var domainIdentifier_1 = mergedConfigs.stacked ? "sharedStackKey" : this.services.cartesianScales.getDomainIdentifier();
      var filteredData = displayData.filter(function(datum2) {
        return new Date(datum2[domainIdentifier_1]) >= zoomDomain[0] && new Date(datum2[domainIdentifier_1]) <= zoomDomain[1];
      });
      if (filteredData.length > 0) {
        return filteredData;
      }
    }
    return displayData;
  };
  Zoom2.prototype.zoomIn = function(zoomRatio) {
    if (zoomRatio === void 0) {
      zoomRatio = this.getZoomRatio();
    }
    var currentZoomDomain = this.model.get("zoomDomain");
    var handleWidth = zoomBar.handleWidth;
    var xScale = this.services.cartesianScales.getMainXScale().copy();
    xScale.domain(this.getDefaultZoomBarDomain());
    var currentX0 = xScale(currentZoomDomain[0]);
    var currentX1 = xScale(currentZoomDomain[1]);
    if (currentX1 - currentX0 < handleWidth + 1) {
      return;
    }
    var fullRange = xScale.range();
    var gap = currentX1 - currentX0;
    var diff = Math.min((fullRange[1] - fullRange[0]) / 2 * (zoomRatio / 2), gap / 2);
    var newX0 = currentX0 + diff;
    var newX1 = currentX1 - diff;
    if (newX0 >= newX1) {
      newX0 = currentX0 + gap / 2 - handleWidth / 2;
      newX1 = currentX1 - gap / 2 + handleWidth / 2;
    }
    var newDomain = [xScale.invert(newX0), xScale.invert(newX1)];
    if (currentZoomDomain[0].valueOf() !== newDomain[0].valueOf() || currentZoomDomain[1].valueOf() !== newDomain[1].valueOf()) {
      this.handleDomainChange(newDomain);
    }
  };
  Zoom2.prototype.zoomOut = function(zoomRatio) {
    if (zoomRatio === void 0) {
      zoomRatio = this.getZoomRatio();
    }
    var currentZoomDomain = this.model.get("zoomDomain");
    var xScale = this.services.cartesianScales.getMainXScale().copy();
    xScale.domain(this.getDefaultZoomBarDomain());
    var currentX0 = xScale(currentZoomDomain[0]);
    var currentX1 = xScale(currentZoomDomain[1]);
    var fullRange = xScale.range();
    var diff = (fullRange[1] - fullRange[0]) / 2 * (zoomRatio / 2);
    var newX0 = Math.max(currentX0 - diff, fullRange[0]);
    var newX1 = Math.min(currentX1 + diff, fullRange[1]);
    var newDomain = [xScale.invert(newX0), xScale.invert(newX1)];
    if (currentZoomDomain[0].valueOf() !== newDomain[0].valueOf() || currentZoomDomain[1].valueOf() !== newDomain[1].valueOf()) {
      this.handleDomainChange(newDomain);
    }
  };
  Zoom2.prototype.resetZoomDomain = function() {
    var currentZoomDomain = this.model.get("zoomDomain");
    var newDomain = this.getDefaultZoomBarDomain();
    if (currentZoomDomain[0].valueOf() !== newDomain[0].valueOf() || currentZoomDomain[1].valueOf() !== newDomain[1].valueOf()) {
      this.handleDomainChange(newDomain);
    }
  };
  Zoom2.prototype.isMinZoomDomain = function() {
    var currentZoomDomain = this.model.get("zoomDomain");
    var maxZoomDomain = this.getDefaultZoomBarDomain();
    if (!currentZoomDomain || !maxZoomDomain) {
      return false;
    }
    var currentZoomDomainPeriod = currentZoomDomain[1].valueOf() - currentZoomDomain[0].valueOf();
    var maxZoomDomainPeriod = maxZoomDomain[1].valueOf() - maxZoomDomain[0].valueOf();
    var minZoomRatio = Tools.getProperty(this.model.getOptions(), "zoomBar", "minZoomRatio");
    if (currentZoomDomainPeriod / maxZoomDomainPeriod < minZoomRatio) {
      return true;
    }
    return false;
  };
  Zoom2.prototype.isMaxZoomDomain = function() {
    var currentZoomDomain = this.model.get("zoomDomain");
    var maxZoomDomain = this.getDefaultZoomBarDomain();
    if (currentZoomDomain && maxZoomDomain && currentZoomDomain[0].valueOf() === maxZoomDomain[0].valueOf() && currentZoomDomain[1].valueOf() === maxZoomDomain[1].valueOf()) {
      return true;
    }
    return false;
  };
  Zoom2.prototype.isEmptyState = function() {
    return this.getZoomBarData().length === 0;
  };
  Zoom2.prototype.isZoomBarLoading = function(position) {
    return Tools.getProperty(this.model.getOptions(), "zoomBar", position, "loading");
  };
  Zoom2.prototype.isZoomBarLocked = function(position) {
    return Tools.getProperty(this.model.getOptions(), "zoomBar", position, "locked");
  };
  return Zoom2;
}(Service);
var __extends$1q = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CanvasZoom = function(_super) {
  __extends$1q(CanvasZoom2, _super);
  function CanvasZoom2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CanvasZoom2.prototype.zoomIn = function(focal, canvasElements, zoomSettings) {
    var x2;
    var y2;
    var zoomLevel;
    var settings2 = zoomSettings ? zoomSettings : canvasZoomSettings;
    if (focal) {
      x2 = focal.x;
      y2 = focal.y;
      zoomLevel = 2;
    }
    var _a2 = DOMUtils.getSVGElementSize(this.services.domUtils.getHolder(), {
      useClientDimensions: true
    }), width = _a2.width, height = _a2.height;
    canvasElements.transition().duration(settings2.duration).ease(settings2.ease).attr("transform", "translate(" + width / 2 + ", " + height / 2 + ") scale(" + zoomLevel + ") translate(" + -x2 + "," + -y2 + ")");
    this.services.events.dispatchEvent(Events$1.CanvasZoom.CANVAS_ZOOM_IN, {
      element: select(focal)
    });
  };
  CanvasZoom2.prototype.zoomOut = function(canvasElements, zoomSettings) {
    var settings2 = zoomSettings ? zoomSettings : canvasZoomSettings;
    canvasElements.transition().duration(settings2.duration).ease(settings2.ease).attr("transform", "");
    this.services.events.dispatchEvent(Events$1.CanvasZoom.CANVAS_ZOOM_OUT);
  };
  return CanvasZoom2;
}(Service);
var Component = function() {
  function Component2(model, services, configs) {
    this.renderType = RenderTypes.HTML;
    this.configs = {};
    this.model = model;
    this.services = services;
    if (configs) {
      this.configs = configs;
      if (this.configs.id) {
        var chartprefix = Tools.getProperty(this.model.getOptions(), "style", "prefix");
        this.id = chartprefix + "--" + this.configs.id;
      }
    }
    if (!this.parent) {
      this.setParent(select(this.services.domUtils.getMainContainer()));
    }
  }
  Component2.prototype.init = function() {
  };
  Component2.prototype.render = function(animate) {
    console.error("render() method is not implemented");
  };
  Component2.prototype.destroy = function() {
  };
  Component2.prototype.setModel = function(newObj) {
    this.model = newObj;
  };
  Component2.prototype.setServices = function(newObj) {
    this.services = newObj;
  };
  Component2.prototype.setParent = function(parent) {
    var oldParent = this.parent;
    this.parent = parent;
    if (oldParent && oldParent.node() === parent.node()) {
      return;
    }
    if (this.type) {
      var chartprefix = Tools.getProperty(this.model.getOptions(), "style", "prefix");
      this.parent.classed(settings$1.prefix + "--" + chartprefix + "--" + this.type, true);
      if (oldParent) {
        oldParent.classed(settings$1.prefix + "--" + chartprefix + "--" + this.type, false);
      }
    }
  };
  Component2.prototype.getParent = function() {
    return this.parent;
  };
  Component2.prototype.getComponentContainer = function(configs) {
    if (configs === void 0) {
      configs = { withinChartClip: false };
    }
    if (this.type) {
      var chartprefix = Tools.getProperty(this.model.getOptions(), "style", "prefix");
      var idSelector = this.id ? "#" + this.id : "";
      var container = DOMUtils.appendOrSelect(this.parent, (this.renderType === RenderTypes.SVG ? "svg" : "div") + idSelector + "." + settings$1.prefix + "--" + chartprefix + "--" + this.type);
      if (configs.withinChartClip) {
        var chartClipId = this.model.get("chartClipId");
        if (chartClipId) {
          var chartClipSelection = select("#" + chartClipId);
          var chartClipRectSelection = chartClipSelection.select("rect");
          if (chartClipRectSelection.size() !== 0 && parseFloat(chartClipRectSelection.attr("height")) > 0) {
            container.attr("clip-path", "url(#" + chartClipId + ")");
          }
        }
      }
      return container.attr("width", "100%").attr("height", "100%");
    }
    return this.parent;
  };
  Component2.prototype.getOptions = function() {
    if (this.configs.options) {
      var options2 = Tools.merge({}, this.model.getOptions(), this.configs.options);
      return options2;
    }
    return this.model.getOptions();
  };
  return Component2;
}();
var __extends$1p = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Legend = function(_super) {
  __extends$1p(Legend2, _super);
  function Legend2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "legend";
    _this.renderType = RenderTypes.HTML;
    return _this;
  }
  Legend2.prototype.render = function() {
    var _this = this;
    var options2 = this.getOptions();
    var legendOptions = Tools.getProperty(options2, "legend");
    var alignment = Tools.getProperty(legendOptions, "alignment");
    var legendOrientation = Tools.getProperty(options2, "legend", "orientation");
    var dataGroups = this.model.getDataGroups();
    var DISABLED = legend$1.items.status.DISABLED;
    var hasDeactivatedItems = dataGroups.some(function(dataGroup) {
      return dataGroup.status === DISABLED;
    });
    var userProvidedOrder = Tools.getProperty(legendOptions, "order");
    var svg = this.getComponentContainer().classed("center-aligned", alignment === Alignments.CENTER).classed("right-aligned", alignment === Alignments.RIGHT).classed(legendOrientation, true).classed("has-deactivated-items", hasDeactivatedItems).attr("role", Roles.GROUP).attr("aria-label", "Data groups").attr("data-name", "legend-items");
    if (userProvidedOrder) {
      dataGroups = this.sortDataGroups(dataGroups, userProvidedOrder);
    }
    var legendItems = svg.selectAll("div.legend-item").data(dataGroups, function(dataGroup) {
      return dataGroup.name;
    });
    var addedLegendItems = legendItems.enter().append("div").attr("class", "legend-item");
    addedLegendItems.merge(svg.selectAll("div.legend-item")).classed("active", function(d, i) {
      return d.status === legend$1.items.status.ACTIVE;
    });
    var legendClickable = Tools.getProperty(this.getOptions(), "legend", "clickable");
    svg.classed("clickable", legendClickable && dataGroups.length > 1);
    var checkboxRadius = legend$1.checkbox.radius;
    var addedCheckboxes = addedLegendItems.append("div").classed("checkbox", true);
    var allCheckboxes = addedCheckboxes.merge(legendItems.select("div.checkbox")).attr("role", Roles.CHECKBOX).attr("tabindex", legendClickable ? 0 : -1).attr("aria-labelledby", function(d, i) {
      return _this.services.domUtils.generateElementIDString("legend-datagroup-" + i + "-title");
    }).attr("aria-checked", function(_a2) {
      var status = _a2.status;
      return status === legend$1.items.status.ACTIVE;
    }).attr("width", checkboxRadius * 2).attr("height", checkboxRadius * 2).attr("class", function(d, i) {
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.BACKGROUND],
        dataGroupName: d.name,
        originalClassName: "checkbox"
      });
    }).style("background", function(d) {
      return d.status === legend$1.items.status.ACTIVE ? _this.model.getFillColor(d.name) || _this.model.getStrokeColor(d.name) : null;
    }).classed("active", function(d, i) {
      return d.status === legend$1.items.status.ACTIVE;
    });
    addedCheckboxes.append("svg").attr("focusable", false).attr("preserveAspectRatio", "xMidYMid meet").attr("xmlns", "http://www.w3.org/2000/svg").attr("width", "11").attr("height", "11").attr("viewBox", "0 0 31 28").attr("aria-hidden", true).style("will-change", "transform").append("path").attr("d", "M13 21.2l-7.1-7.1-1.4 1.4 7.1 7.1L13 24 27.1 9.9l-1.4-1.5z");
    addedLegendItems.append("p").merge(legendItems.select("p"));
    var additionalItemsOption = Tools.getProperty(options2, "legend", "additionalItems");
    if (additionalItemsOption && dataGroups.length) {
      var self_1 = this;
      var additionalItems = svg.selectAll("div.additional-item").data(additionalItemsOption);
      additionalItems.exit().remove();
      var addedAdditionalItems = additionalItems.enter().append("div").merge(additionalItems).classed("legend-item", true).classed("additional", true).attr("aria-labelledby", function(d, i) {
        return _this.services.domUtils.generateElementIDString("legend-datagroup-" + (allCheckboxes.size() + i) + "-title");
      });
      addedAdditionalItems.selectAll("*").remove();
      var previousType_1;
      var indexOfItem_1 = 1;
      addedAdditionalItems.append("svg").classed("icon", true).each(function(d, i) {
        var additionalItem = select(this);
        if (!previousType_1 || previousType_1 != d.type) {
          previousType_1 = d.type;
          indexOfItem_1 = 1;
        } else {
          indexOfItem_1++;
        }
        self_1.addAdditionalItem(additionalItem, d, indexOfItem_1);
      });
      addedAdditionalItems.append("p").merge(addedAdditionalItems.select("p"));
      this.truncateLegendText();
    }
    legendItems.exit().on("mouseover", null).on("click", null).on("mouseout", null).remove();
    if (legendClickable && addedLegendItems.size() > 1) {
      this.addEventListeners();
    }
  };
  Legend2.prototype.sortDataGroups = function(dataGroups, legendOrder) {
    dataGroups.sort(function(dataA, dataB) {
      return legendOrder.indexOf(dataA.name) - legendOrder.indexOf(dataB.name);
    });
    if (legendOrder.length < dataGroups.length) {
      var definedOrderIndex = dataGroups.length - legendOrder.length;
      var definedOrder = dataGroups.slice(definedOrderIndex);
      return definedOrder.concat(dataGroups.slice(0, definedOrderIndex));
    }
    return dataGroups;
  };
  Legend2.prototype.addAdditionalItem = function(additionalItem, itemConfig, indexOfItem) {
    var _a2 = legend$1.area, width = _a2.width, height = _a2.height;
    if (itemConfig.type === LegendItemType.RADIUS) {
      additionalItem.style("width", height + "px").style("height", height + "px");
    } else {
      additionalItem.style("width", width + "px").style("height", height + "px");
    }
    if (itemConfig.type === LegendItemType.RADIUS) {
      var _b = legend$1.radius, iconData = _b.iconData, fill = _b.fill, stroke = _b.stroke;
      var circleEnter = additionalItem.attr("fill", "none").selectAll("circle").data(iconData).enter();
      circleEnter.append("circle").classed("radius", true).attr("role", Roles.IMG).attr("aria-label", "radius").attr("cx", function(d) {
        return d.cx;
      }).attr("cy", function(d) {
        return d.cy;
      }).attr("r", function(d) {
        return d.r;
      }).style("fill", itemConfig.fill ? itemConfig.fill : fill).style("stroke", itemConfig.stroke ? itemConfig.stroke : stroke);
    } else if (itemConfig.type === LegendItemType.LINE) {
      var lineConfig = legend$1.line;
      if (additionalItem.select("line.line").empty()) {
        additionalItem.append("line").classed("line-" + indexOfItem, true).attr("role", Roles.IMG).attr("aria-label", "line").attr("x1", 0).attr("y1", lineConfig.yPosition).attr("x2", width).attr("y2", lineConfig.yPosition).style("stroke", itemConfig.stroke ? itemConfig.stroke : lineConfig.stroke).style("stroke-width", lineConfig.strokeWidth);
      }
    } else if (itemConfig.type === LegendItemType.AREA) {
      if (additionalItem.select("rect.area").empty()) {
        additionalItem.append("rect").classed("area-" + indexOfItem, true).attr("role", Roles.IMG).attr("aria-label", "area").attr("width", width).attr("height", height).style("fill", indexOfItem > 3 && !itemConfig.fill ? legend$1.area.fill : itemConfig.fill).style("stroke", itemConfig.stroke);
      }
    } else if (itemConfig.type === LegendItemType.SIZE) {
      var _c = legend$1.size, iconData = _c.iconData, fill = _c.fill, stroke = _c.stroke;
      var sizeEnter = additionalItem.attr("fill", "none").attr("role", Roles.IMG).attr("aria-label", "size").selectAll("rect").data(iconData).enter();
      sizeEnter.append("rect").classed("size", true).attr("width", function(d) {
        return d.width;
      }).attr("height", function(d) {
        return d.height;
      }).attr("y", function(d) {
        return 0;
      }).style("fill", itemConfig.fill ? itemConfig.fill : fill).style("stroke", itemConfig.stroke ? itemConfig.stroke : stroke).style("stroke-width", 1);
    } else if (itemConfig.type === LegendItemType.QUARTILE) {
      var iconData = legend$1.quartile.iconData;
      var quartileEnter = additionalItem.selectAll("rect").attr("role", Roles.IMG).attr("aria-label", "quartile").data(iconData).enter();
      quartileEnter.append("rect").attr("class", function(d, i) {
        return "quartile-" + (i === 0 ? "wrapper" : "line");
      }).attr("x", function(d) {
        return d.x;
      }).attr("y", function(d) {
        return d.y;
      }).attr("width", function(d) {
        return d.width;
      }).attr("height", function(d) {
        return d.height;
      });
    } else if (itemConfig.type === LegendItemType.ZOOM) {
      var _d = Tools.getProperty(Configuration, "legend", "zoom"), iconData = _d.iconData, color_1 = _d.color;
      var zoomEnter = additionalItem.attr("role", Roles.IMG).attr("aria-label", "zoom").selectAll("g.icon").data(iconData).enter();
      zoomEnter.append("g").attr("x", function(d) {
        return d.x;
      }).attr("y", function(d) {
        return d.y;
      }).attr("width", function(d) {
        return d.width;
      }).attr("height", function(d) {
        return d.height;
      }).append("polygon").attr("points", "7.7 4.82 5.78 4.82 5.78 2.89 4.82 2.89 4.82 4.82 2.89 4.82 2.89 5.78 4.82 5.78 4.82 7.7 5.78 7.7 5.78 5.78 7.7 5.78 7.7 4.82").attr("fill", function(d) {
        return itemConfig.color ? itemConfig.color : color_1;
      });
      zoomEnter.append("path").attr("d", "M9.36,8.67A5.22,5.22,0,0,0,10.59,5.3,5.3,5.3,0,1,0,5.3,10.59,5.22,5.22,0,0,0,8.67,9.36L12.32,13l.68-.68Zm-4.06,1A4.34,4.34,0,1,1,9.63,5.3,4.33,4.33,0,0,1,5.3,9.63Z").attr("fill", function(d) {
        return itemConfig.color ? itemConfig.color : color_1;
      });
    }
  };
  Legend2.prototype.truncateLegendText = function() {
    var svg = this.getComponentContainer();
    var truncationOptions = Tools.getProperty(this.getOptions(), "legend", "truncation");
    var truncationType = Tools.getProperty(truncationOptions, "type");
    var truncationThreshold = Tools.getProperty(truncationOptions, "threshold");
    var truncationNumCharacter = Tools.getProperty(truncationOptions, "numCharacter");
    var addedLegendItemsText = svg.selectAll("div.legend-item p");
    addedLegendItemsText.attr("id", function(d, i) {
      var elementToReference = this.parentNode.querySelector("div.checkbox") || this.parentNode;
      return elementToReference.getAttribute("aria-labelledby");
    });
    if (truncationType !== TruncationTypes.NONE) {
      addedLegendItemsText.html(function(d) {
        if (d.name.length > truncationThreshold) {
          return Tools.truncateLabel(d.name, truncationType, truncationNumCharacter);
        } else {
          return d.name;
        }
      });
    } else {
      addedLegendItemsText.html(function(d) {
        return d.name;
      });
    }
  };
  Legend2.prototype.addEventListeners = function() {
    var self2 = this;
    var svg = this.getComponentContainer();
    var options2 = this.getOptions();
    var legendOptions = Tools.getProperty(options2, "legend");
    var truncationThreshold = Tools.getProperty(legendOptions, "truncation", "threshold");
    svg.selectAll("div.legend-item").on("mouseover", function(event) {
      self2.services.events.dispatchEvent(Events$1.Legend.ITEM_HOVER, {
        hoveredElement: select(this)
      });
      var hoveredItem = select(this);
      hoveredItem.select("div.checkbox").classed("hovered", true);
      var hoveredItemData = hoveredItem.datum();
      if (hoveredItemData.name.length > truncationThreshold) {
        self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
          event,
          hoveredElement: hoveredItem,
          content: hoveredItemData.name
        });
      }
    }).on("mousemove", function(event) {
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("click", function() {
      self2.services.events.dispatchEvent(Events$1.Legend.ITEM_CLICK, {
        clickedElement: select(this)
      });
      var clickedItem = select(this);
      var clickedItemData = clickedItem.datum();
      self2.model.toggleDataLabel(clickedItemData.name);
    }).on("mouseout", function() {
      var hoveredItem = select(this);
      hoveredItem.select("div.checkbox").classed("hovered", false);
      self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE);
      self2.services.events.dispatchEvent(Events$1.Legend.ITEM_MOUSEOUT, {
        hoveredElement: hoveredItem
      });
    });
    svg.selectAll("div.legend-item div.checkbox").on("keyup", function(event) {
      if (event.key && event.key === "Tab") {
        self2.services.events.dispatchEvent(Events$1.Legend.ITEM_HOVER, {
          hoveredElement: select(this)
        });
      }
    });
    svg.selectAll("div.legend-item div.checkbox").on("keydown", function(event, d) {
      if (event.key && event.key === " ") {
        event.preventDefault();
        self2.model.toggleDataLabel(d.name);
      } else if (event.key && event.key === "Tab") {
        self2.services.events.dispatchEvent(Events$1.Legend.ITEM_MOUSEOUT, {
          hoveredElement: select(this)
        });
      }
    });
    svg.selectAll("g.additional-item").on("mouseover", function(event) {
      var hoveredItem = select(this);
      var hoveredItemData = hoveredItem.datum();
      if (hoveredItemData.name.length > truncationThreshold) {
        self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
          event,
          hoveredElement: hoveredItem,
          content: hoveredItemData.name
        });
      }
    });
  };
  return Legend2;
}(Component);
function identity(x2) {
  return x2;
}
var top = 1, right = 2, bottom = 3, left = 4, epsilon$1 = 1e-6;
function translateX(x2) {
  return "translate(" + x2 + ",0)";
}
function translateY(y2) {
  return "translate(0," + y2 + ")";
}
function number(scale) {
  return (d) => +scale(d);
}
function center(scale, offset) {
  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
  if (scale.round())
    offset = Math.round(offset);
  return (d) => +scale(d) + offset;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k = orient === top || orient === left ? -1 : 1, x2 = orient === left || orient === right ? "x" : "y", transform = orient === top || orient === bottom ? translateX : translateY;
  function axis2(context) {
    var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format2 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range2 = scale.range(), range0 = +range2[0] + offset, range1 = +range2[range2.length - 1] + offset, position = (scale.bandwidth ? center : number)(scale.copy(), offset), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line2 = tick.select("line"), text = tick.select("text");
    path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line2 = line2.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x2 + "2", k * tickSizeInner));
    text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x2, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path2 = path2.transition(context);
      tick = tick.transition(context);
      line2 = line2.transition(context);
      text = text.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon$1).attr("transform", function(d) {
        return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon$1).attr("transform", function(d) {
        var p = this.parentNode.__axis;
        return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset);
      });
    }
    tickExit.remove();
    path2.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d) {
      return transform(position(d) + offset);
    });
    line2.attr(x2 + "2", k * tickSizeInner);
    text.attr(x2, k * spacing).text(format2);
    selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position;
    });
  }
  axis2.scale = function(_) {
    return arguments.length ? (scale = _, axis2) : scale;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_) {
    return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis2) : tickPadding;
  };
  axis2.offset = function(_) {
    return arguments.length ? (offset = +_, axis2) : offset;
  };
  return axis2;
}
function axisTop(scale) {
  return axis(top, scale);
}
function axisRight(scale) {
  return axis(right, scale);
}
function axisBottom(scale) {
  return axis(bottom, scale);
}
function axisLeft(scale) {
  return axis(left, scale);
}
var __extends$1o = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ColorScaleLegend = function(_super) {
  __extends$1o(ColorScaleLegend2, _super);
  function ColorScaleLegend2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "color-legend";
    _this.renderType = RenderTypes.SVG;
    _this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999);
    _this.handleAxisComplete = function(event) {
      var svg = _this.getComponentContainer();
      var width = DOMUtils.getSVGElementSize(svg, {
        useAttrs: true
      }).width;
      var isDataLoading = Tools.getProperty(_this.getOptions(), "data", "loading");
      if (width > legend$1.color.barWidth && !isDataLoading) {
        var title = Tools.getProperty(_this.getOptions(), "heatmap", "colorLegend", "title");
        var cartesianScales = _this.services.cartesianScales;
        var mainXScale = cartesianScales.getMainXScale();
        var xDimensions = mainXScale.range();
        if (xDimensions[0] > 1) {
          svg.select("g.legend").attr("transform", "translate(" + xDimensions[0] + ", 0)");
          if (title) {
            var textWidth = DOMUtils.getSVGElementSize(svg.select("g.legend-title").select("text"), { useBBox: true }).width;
            var availableSpace = xDimensions[0] - textWidth - 9;
            if (availableSpace > 1) {
              svg.select("g.legend-title").attr("transform", "translate(" + availableSpace + ", 0)");
            } else {
              svg.select("g.legend").attr("transform", "translate(" + xDimensions[0] + ", 16)");
              svg.select("g.legend-title").attr("transform", "translate(" + xDimensions[0] + ", 0)");
            }
          }
        }
      }
    };
    return _this;
  }
  ColorScaleLegend2.prototype.init = function() {
    var eventsFragment = this.services.events;
    eventsFragment.addEventListener(Events$1.Axis.RENDER_COMPLETE, this.handleAxisComplete);
  };
  ColorScaleLegend2.prototype.render = function(animate) {
    var options2 = this.getOptions();
    var customColors = Tools.getProperty(options2, "color", "gradient", "colors");
    var colorScaleType = Tools.getProperty(options2, "heatmap", "colorLegend", "type");
    var colorPairingOption = Tools.getProperty(options2, "color", "pairing", "option");
    var title = Tools.getProperty(options2, "heatmap", "colorLegend", "title");
    var customColorsEnabled = !Tools.isEmpty(customColors);
    var domain = this.model.getValueDomain();
    var svg = this.getComponentContainer();
    var isDataLoading = Tools.getProperty(this.getOptions(), "data", "loading");
    if (isDataLoading) {
      svg.html("");
      return;
    }
    var legend2 = DOMUtils.appendOrSelect(svg, "g.legend");
    var axis2 = DOMUtils.appendOrSelect(legend2, "g.legend-axis");
    var width = DOMUtils.getSVGElementSize(svg, {
      useAttrs: true
    }).width;
    var barWidth = legend$1.color.barWidth;
    if (width <= legend$1.color.barWidth) {
      barWidth = width;
    }
    if (title) {
      var legendTitleGroup = DOMUtils.appendOrSelect(svg, "g.legend-title");
      var legendTitle = DOMUtils.appendOrSelect(legendTitleGroup, "text");
      legendTitle.text(title).attr("dy", "0.7em");
      legend2.attr("transform", "translate(0, 16)");
    }
    var colorScheme = domain[0] < 0 && domain[1] > 0 ? "diverge" : "mono";
    if (colorPairingOption < 1 && colorPairingOption > 4 && colorScheme === "mono") {
      colorPairingOption = 1;
    } else if (colorPairingOption < 1 && colorPairingOption > 2 && colorScheme === "diverge") {
      colorPairingOption = 1;
    }
    var colorPairing = [];
    var colorGroupingLength = colorScheme === "diverge" ? 17 : 11;
    if (!customColorsEnabled) {
      for (var i = 1; i < colorGroupingLength + 1; i++) {
        colorPairing.push(colorScaleType === ColorLegendType.LINEAR ? "stop-color-" + colorScheme + "-" + colorPairingOption + "-" + i : "fill-" + colorScheme + "-" + colorPairingOption + "-" + i);
      }
    } else {
      colorPairing = customColors;
    }
    if (colorScaleType === ColorLegendType.LINEAR) {
      var stopLengthPercentage_1 = 100 / (colorPairing.length - 1);
      var linearGradient = DOMUtils.appendOrSelect(legend2, "linearGradient");
      linearGradient.attr("id", this.gradient_id + "-legend").selectAll("stop").data(colorPairing).enter().append("stop").attr("offset", function(_, i2) {
        return i2 * stopLengthPercentage_1 + "%";
      }).attr("class", function(_, i2) {
        return colorPairing[i2];
      }).attr("stop-color", function(d) {
        return d;
      });
      var rectangle = DOMUtils.appendOrSelect(legend2, "rect");
      rectangle.attr("width", barWidth).attr("height", legend$1.color.barHeight).style("fill", "url(#" + this.gradient_id + "-legend)");
      var linearScale = linear().domain(domain).range([0, barWidth]);
      domain.splice(1, 0, (domain[0] + domain[1]) / 2);
      var xAxis = axisBottom(linearScale).tickSize(0).tickValues(domain);
      axis2.attr("transform", "translate(0," + legend$1.color.axisYTranslation + ")").call(xAxis);
      axis2.select(".domain").remove();
      axis2.style("text-anchor", "start");
    } else if (colorScaleType === ColorLegendType.QUANTIZE) {
      var interpolator = interpolateRound(domain[0], domain[1]);
      var quant_1 = quantize$1(interpolator, colorPairing.length);
      if (!customColorsEnabled && colorScheme === "diverge") {
        colorPairing.splice(colorPairing.length / 2, 1);
      }
      var colorScaleBand_1 = band().domain(colorPairing).range([0, barWidth]);
      var rectangle = DOMUtils.appendOrSelect(legend2, "g.quantized-rect");
      rectangle.selectAll("rect").data(colorScaleBand_1.domain()).join("rect").attr("x", function(d) {
        return colorScaleBand_1(d);
      }).attr("y", 0).attr("width", Math.max(0, colorScaleBand_1.bandwidth()) - 1).attr("height", legend$1.color.barHeight).attr("class", function(d) {
        return d;
      }).attr("fill", function(d) {
        return d;
      });
      var xAxis = axisBottom(colorScaleBand_1).tickSize(0).tickValues(colorPairing).tickFormat(function(_, i2) {
        if (!customColorsEnabled && ((i2 + 1) % 2 === 0 || i2 === colorPairing.length - 1)) {
          return null;
        }
        return quant_1[i2].toString();
      });
      var axisTranslation = colorScaleBand_1.bandwidth() / 2;
      axis2.attr("transform", "translate(" + (!customColorsEnabled && colorScheme === "diverge" ? "-" : "") + axisTranslation + ", " + legend$1.color.axisYTranslation + ")").call(xAxis);
      var firstTick = axis2.select("g.tick").clone(true);
      firstTick.attr("transform", "translate(" + (barWidth + (!customColorsEnabled && colorScheme === "diverge" ? axisTranslation : -axisTranslation)) + ", 0)").classed("final-tick", true).select("text").text(quant_1[quant_1.length - 1]);
      axis2.enter().append(firstTick.node());
      axis2.select(".domain").remove();
    } else {
      throw Error("Entered color legend type is not supported.");
    }
    if (width <= legend$1.color.barWidth) {
      var lastTick = axis2.select("g.tick:last-of-type text");
      var width_1 = DOMUtils.getSVGElementSize(lastTick, {
        useBBox: true
      }).width;
      lastTick.attr("x", "-" + width_1);
    }
  };
  ColorScaleLegend2.prototype.destroy = function() {
    var eventsFragment = this.services.events;
    eventsFragment.removeEventListener(Events$1.Axis.RENDER_COMPLETE, this.handleAxisComplete);
  };
  return ColorScaleLegend2;
}(Legend);
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$1(o, minLen);
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1(arr);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function flatten(a) {
  return a.reduce(function(result, item) {
    if (Array.isArray(item)) {
      result.push.apply(result, _toConsumableArray$1(flatten(item)));
    } else {
      result.push(item);
    }
    return result;
  }, []);
}
function mixin() {
  for (var _len = arguments.length, mixinfns = new Array(_len), _key = 0; _key < _len; _key++) {
    mixinfns[_key] = arguments[_key];
  }
  return flatten(mixinfns).reduce(function(Class, mixinfn) {
    return mixinfn(Class);
  }, /* @__PURE__ */ function() {
    function _class() {
      _classCallCheck$6(this, _class);
    }
    return _class;
  }());
}
function _typeof$5(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$5 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$5 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$5(obj);
}
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$5(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$5(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$5(Constructor, staticProps);
  return Constructor;
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf$5(subClass, superClass);
}
function _setPrototypeOf$5(o, p) {
  _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$5(o, p);
}
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$5(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$5(this, result);
  };
}
function _possibleConstructorReturn$5(self2, call) {
  if (call && (_typeof$5(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$5(self2);
}
function _assertThisInitialized$5(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$5(o) {
  _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$5(o);
}
function createComponent(ToMix) {
  var CreateComponent = /* @__PURE__ */ function(_ToMix) {
    _inherits$5(CreateComponent2, _ToMix);
    var _super = _createSuper$5(CreateComponent2);
    function CreateComponent2(element) {
      var _this;
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck$5(this, CreateComponent2);
      _this = _super.call(this, element, options2);
      _this.children = [];
      if (!element || element.nodeType !== Node.ELEMENT_NODE) {
        throw new TypeError("DOM element should be given to initialize this widget.");
      }
      _this.element = element;
      _this.options = Object.assign(Object.create(_this.constructor.options), options2);
      _this.constructor.components.set(_this.element, _assertThisInitialized$5(_this));
      return _this;
    }
    _createClass$5(CreateComponent2, [{
      key: "release",
      value: function release() {
        for (var child = this.children.pop(); child; child = this.children.pop()) {
          child.release();
        }
        this.constructor.components.delete(this.element);
        return null;
      }
    }], [{
      key: "create",
      value: function create2(element, options2) {
        return this.components.get(element) || new this(element, options2);
      }
    }]);
    return CreateComponent2;
  }(ToMix);
  return CreateComponent;
}
function _typeof$4(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$4 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$4 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$4(obj);
}
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$4(Constructor, staticProps);
  return Constructor;
}
function _get(target, property2, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get2(target2, property3, receiver2) {
      var base = _superPropBase(target2, property3);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property3);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get(target, property2, receiver || target);
}
function _superPropBase(object2, property2) {
  while (!Object.prototype.hasOwnProperty.call(object2, property2)) {
    object2 = _getPrototypeOf$4(object2);
    if (object2 === null)
      break;
  }
  return object2;
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf$4(subClass, superClass);
}
function _setPrototypeOf$4(o, p) {
  _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$4(o, p);
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$4(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$4(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$4(this, result);
  };
}
function _possibleConstructorReturn$4(self2, call) {
  if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$4(self2);
}
function _assertThisInitialized$4(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$4(o) {
  _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$4(o);
}
function handles(ToMix) {
  var Handles = /* @__PURE__ */ function(_ToMix) {
    _inherits$4(Handles2, _ToMix);
    var _super = _createSuper$4(Handles2);
    function Handles2() {
      var _this;
      _classCallCheck$4(this, Handles2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _this.handles = /* @__PURE__ */ new Set();
      return _this;
    }
    _createClass$4(Handles2, [{
      key: "manage",
      value: function manage(handle) {
        this.handles.add(handle);
        return handle;
      }
    }, {
      key: "unmanage",
      value: function unmanage(handle) {
        this.handles.delete(handle);
        return handle;
      }
    }, {
      key: "release",
      value: function release() {
        var _this2 = this;
        this.handles.forEach(function(handle) {
          handle.release();
          _this2.handles.delete(handle);
        });
        return _get(_getPrototypeOf$4(Handles2.prototype), "release", this).call(this);
      }
    }]);
    return Handles2;
  }(ToMix);
  return Handles;
}
function on(element) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  element.addEventListener.apply(element, args);
  return {
    release: function release() {
      element.removeEventListener.apply(element, args);
      return null;
    }
  };
}
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$3 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$3(obj);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$3(Constructor, staticProps);
  return Constructor;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o, p) {
  _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$3(o, p);
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$3(this, result);
  };
}
function _possibleConstructorReturn$3(self2, call) {
  if (call && (_typeof$3(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$3(self2);
}
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$3(o) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$3(o);
}
function eventedState(ToMix) {
  var EventedState = /* @__PURE__ */ function(_ToMix) {
    _inherits$3(EventedState2, _ToMix);
    var _super = _createSuper$3(EventedState2);
    function EventedState2() {
      _classCallCheck$3(this, EventedState2);
      return _super.apply(this, arguments);
    }
    _createClass$3(EventedState2, [{
      key: "_changeState",
      value: function _changeState() {
        throw new Error("_changeState() should be overriden to perform actual change in state.");
      }
    }, {
      key: "changeState",
      value: function changeState() {
        var _this = this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var state = typeof args[0] === "string" ? args.shift() : void 0;
        var detail = Object(args[0]) === args[0] && typeof args[0] !== "function" ? args.shift() : void 0;
        var callback = typeof args[0] === "function" ? args.shift() : void 0;
        if (typeof this.shouldStateBeChanged === "function" && !this.shouldStateBeChanged(state, detail)) {
          if (callback) {
            callback(null, true);
          }
          return;
        }
        var data = {
          group: detail && detail.group,
          state
        };
        var eventNameSuffix = [data.group, state].filter(Boolean).join("-").split("-").map(function(item) {
          return item[0].toUpperCase() + item.substr(1);
        }).join("");
        var eventStart = new CustomEvent(this.options["eventBefore".concat(eventNameSuffix)], {
          bubbles: true,
          cancelable: true,
          detail
        });
        var fireOnNode = detail && detail.delegatorNode || this.element;
        var canceled = !fireOnNode.dispatchEvent(eventStart);
        if (canceled) {
          if (callback) {
            var error = new Error("Changing state (".concat(JSON.stringify(data), ") has been canceled."));
            error.canceled = true;
            callback(error);
          }
        } else {
          var changeStateArgs = [state, detail].filter(Boolean);
          this._changeState.apply(this, _toConsumableArray(changeStateArgs).concat([function() {
            fireOnNode.dispatchEvent(new CustomEvent(_this.options["eventAfter".concat(eventNameSuffix)], {
              bubbles: true,
              cancelable: true,
              detail
            }));
            if (callback) {
              callback();
            }
          }]));
        }
      }
    }]);
    return EventedState2;
  }(ToMix);
  return EventedState;
}
function eventMatches(event, selector2) {
  var target = event.target, currentTarget = event.currentTarget;
  if (typeof target.matches === "function") {
    if (target.matches(selector2)) {
      return target;
    }
    if (target.matches("".concat(selector2, " *"))) {
      var closest = target.closest(selector2);
      if ((currentTarget.nodeType === Node.DOCUMENT_NODE ? currentTarget.documentElement : currentTarget).contains(closest)) {
        return closest;
      }
    }
  }
  return void 0;
}
function getLaunchingDetails(evt) {
  if (!evt || typeof evt === "function") {
    return {
      launchingElement: null,
      launchingEvent: null
    };
  }
  var launchingElement = evt.delegateTarget || evt.currentTarget || evt;
  var launchingEvent = evt.currentTarget && evt;
  if (launchingElement && !launchingElement.nodeType) {
    throw new TypeError("DOM Node should be given for launching element.");
  }
  if (launchingEvent && !launchingEvent.type) {
    throw new TypeError("DOM event should be given for launching event.");
  }
  return {
    launchingElement,
    launchingEvent
  };
}
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$2 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$2(obj);
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  return Constructor;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o, p) {
  _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$2(o, p);
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _possibleConstructorReturn$2(self2, call) {
  if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$2(self2);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$2(o) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$2(o);
}
function eventedShowHideState(ToMix) {
  var EventedShowHideState = /* @__PURE__ */ function(_ToMix) {
    _inherits$2(EventedShowHideState2, _ToMix);
    var _super = _createSuper$2(EventedShowHideState2);
    function EventedShowHideState2() {
      _classCallCheck$2(this, EventedShowHideState2);
      return _super.apply(this, arguments);
    }
    _createClass$2(EventedShowHideState2, [{
      key: "show",
      value: function show(evtOrElem, callback) {
        if (!evtOrElem || typeof evtOrElem === "function") {
          callback = evtOrElem;
        }
        this.changeState("shown", getLaunchingDetails(evtOrElem), callback);
      }
    }, {
      key: "hide",
      value: function hide(evtOrElem, callback) {
        if (!evtOrElem || typeof evtOrElem === "function") {
          callback = evtOrElem;
        }
        this.changeState("hidden", getLaunchingDetails(evtOrElem), callback);
      }
    }]);
    return EventedShowHideState2;
  }(ToMix);
  return EventedShowHideState;
}
var exports$1 = [eventedState, eventedShowHideState];
var eventedShowHideState$1 = exports$1;
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  return Constructor;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o, p) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1(o, p);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _possibleConstructorReturn$1(self2, call) {
  if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1(self2);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1(o);
}
function initComponentByLauncher(ToMix) {
  var InitComponentByLauncher = /* @__PURE__ */ function(_ToMix) {
    _inherits$1(InitComponentByLauncher2, _ToMix);
    var _super = _createSuper$1(InitComponentByLauncher2);
    function InitComponentByLauncher2() {
      _classCallCheck$1(this, InitComponentByLauncher2);
      return _super.apply(this, arguments);
    }
    _createClass$1(InitComponentByLauncher2, null, [{
      key: "init",
      value: function init2() {
        var _this = this;
        var target = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
        var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var effectiveOptions = Object.assign(Object.create(this.options), options2);
        if (!target || target.nodeType !== Node.ELEMENT_NODE && target.nodeType !== Node.DOCUMENT_NODE) {
          throw new TypeError("DOM document or DOM element should be given to search for and initialize this widget.");
        }
        if (target.nodeType === Node.ELEMENT_NODE && target.matches(effectiveOptions.selectorInit)) {
          this.create(target, options2);
        } else {
          var handles2 = effectiveOptions.initEventNames.map(function(name) {
            return on(target, name, function(event) {
              var launcher = eventMatches(event, "[".concat(effectiveOptions.attribInitTarget, "]"));
              if (launcher) {
                event.delegateTarget = launcher;
                var elements = launcher.ownerDocument.querySelectorAll(launcher.getAttribute(effectiveOptions.attribInitTarget));
                if (elements.length > 1) {
                  throw new Error("Target widget must be unique.");
                }
                if (elements.length === 1) {
                  if (launcher.tagName === "A") {
                    event.preventDefault();
                  }
                  var component = _this.create(elements[0], options2);
                  if (typeof component.createdByLauncher === "function") {
                    component.createdByLauncher(event);
                  }
                }
              }
            });
          });
          return {
            release: function release() {
              for (var handle = handles2.pop(); handle; handle = handles2.pop()) {
                handle.release();
              }
            }
          };
        }
        return "";
      }
    }]);
    InitComponentByLauncher2.forLazyInit = true;
    return InitComponentByLauncher2;
  }(ToMix);
  return InitComponentByLauncher;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
var Modal$1 = /* @__PURE__ */ function(_mixin) {
  _inherits(Modal2, _mixin);
  var _super = _createSuper(Modal2);
  function Modal2(element, options2) {
    var _this;
    _classCallCheck(this, Modal2);
    _this = _super.call(this, element, options2);
    _this._handleFocusinListener = void 0;
    _this._handleKeydownListener = void 0;
    _this._handleFocusin = function(evt) {
      var focusWrapNode = _this.element.querySelector(_this.options.selectorModalContainer) || _this.element;
      if (_this.element.classList.contains(_this.options.classVisible) && !focusWrapNode.contains(evt.target) && _this.options.selectorsFloatingMenus.every(function(selector2) {
        return !eventMatches(evt, selector2);
      })) {
        _this.element.querySelector(settings$1.selectorTabbable).focus();
      }
    };
    _this._hookCloseActions();
    return _this;
  }
  _createClass(Modal2, [{
    key: "createdByLauncher",
    value: function createdByLauncher(evt) {
      this.show(evt);
    }
  }, {
    key: "shouldStateBeChanged",
    value: function shouldStateBeChanged(state) {
      if (state === "shown") {
        return !this.element.classList.contains(this.options.classVisible);
      }
      return this.element.classList.contains(this.options.classVisible);
    }
  }, {
    key: "_changeState",
    value: function _changeState(state, detail, callback) {
      var _this2 = this;
      var handleTransitionEnd;
      var transitionEnd = function transitionEnd2() {
        if (handleTransitionEnd) {
          handleTransitionEnd = _this2.unmanage(handleTransitionEnd).release();
        }
        if (state === "shown" && _this2.element.offsetWidth > 0 && _this2.element.offsetHeight > 0) {
          _this2.previouslyFocusedNode = _this2.element.ownerDocument.activeElement;
          var focusableItem = _this2.element.querySelector(_this2.options.selectorPrimaryFocus) || _this2.element.querySelector(settings$1.selectorTabbable);
          focusableItem.focus();
        }
        callback();
      };
      if (this._handleFocusinListener) {
        this._handleFocusinListener = this.unmanage(this._handleFocusinListener).release();
      }
      if (state === "shown") {
        var hasFocusin = "onfocusin" in this.element.ownerDocument.defaultView;
        var focusinEventName = hasFocusin ? "focusin" : "focus";
        this._handleFocusinListener = this.manage(on(this.element.ownerDocument, focusinEventName, this._handleFocusin, !hasFocusin));
      }
      if (state === "hidden") {
        this.element.classList.toggle(this.options.classVisible, false);
        this.element.ownerDocument.body.classList.toggle(this.options.classBody, false);
        if (this.options.selectorFocusOnClose || this.previouslyFocusedNode) {
          (this.element.ownerDocument.querySelector(this.options.selectorFocusOnClose) || this.previouslyFocusedNode).focus();
        }
      } else if (state === "shown") {
        this.element.classList.toggle(this.options.classVisible, true);
        this.element.ownerDocument.body.classList.toggle(this.options.classBody, true);
      }
      handleTransitionEnd = this.manage(on(this.element, "transitionend", transitionEnd));
    }
  }, {
    key: "_hookCloseActions",
    value: function _hookCloseActions() {
      var _this3 = this;
      this.manage(on(this.element, "click", function(evt) {
        var closeButton = eventMatches(evt, _this3.options.selectorModalClose);
        if (closeButton) {
          evt.delegateTarget = closeButton;
        }
        if (closeButton || evt.target === _this3.element) {
          _this3.hide(evt);
        }
      }));
      if (this._handleKeydownListener) {
        this._handleKeydownListener = this.unmanage(this._handleKeydownListener).release();
      }
      this._handleKeydownListener = this.manage(on(this.element.ownerDocument.body, "keydown", function(evt) {
        if (evt.which === 27 && _this3.shouldStateBeChanged("hidden")) {
          evt.stopPropagation();
          _this3.hide(evt);
        }
      }));
    }
  }], [{
    key: "options",
    get: function get2() {
      var prefix = settings$1.prefix;
      return {
        selectorInit: "[data-modal]",
        selectorModalClose: "[data-modal-close]",
        selectorPrimaryFocus: "[data-modal-primary-focus]",
        selectorsFloatingMenus: [".".concat(prefix, "--overflow-menu-options"), ".".concat(prefix, "--tooltip"), ".flatpickr-calendar"],
        selectorModalContainer: ".".concat(prefix, "--modal-container"),
        classVisible: "is-visible",
        classBody: "".concat(prefix, "--body--with-modal-open"),
        attribInitTarget: "data-modal-target",
        initEventNames: ["click"],
        eventBeforeShown: "modal-beingshown",
        eventAfterShown: "modal-shown",
        eventBeforeHidden: "modal-beinghidden",
        eventAfterHidden: "modal-hidden"
      };
    }
  }]);
  Modal2.components = /* @__PURE__ */ new WeakMap();
  return Modal2;
}(mixin(createComponent, initComponentByLauncher, eventedShowHideState$1, handles));
var CarbonModalComponent = Modal$1;
var __extends$1n = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Modal = function(_super) {
  __extends$1n(Modal2, _super);
  function Modal2(model, services, configs) {
    var _this = _super.call(this, model, services, configs) || this;
    _this.type = "modal";
    _this.isEventListenerAdded = false;
    _this.handleShowModal = function() {
      _this.modal.html(_this.getModalHTML());
      _this.modal.select("div.bx--modal-footer button.bx--btn").on("click", function() {
        return _this.model.exportToCSV();
      });
      var modalInstance = CarbonModalComponent.create(_this.modal.node());
      modalInstance.show();
    };
    _this.init();
    return _this;
  }
  Modal2.prototype.addEventListeners = function() {
    this.services.events.addEventListener(Events$1.Modal.SHOW, this.handleShowModal);
  };
  Modal2.prototype.removeEventListeners = function() {
    this.services.events.removeEventListener(Events$1.Modal.SHOW, this.handleShowModal);
  };
  Modal2.prototype.getModalHTML = function() {
    var options2 = this.model.getOptions();
    var chartprefix = Tools.getProperty(options2, "style", "prefix");
    var tableArray = this.model.getTabularDataArray();
    return '\n		<div class="bx--modal-container">\n			<div class="bx--modal-header">\n				<p class="bx--modal-header__label bx--type-delta" id="modal-title">Tabular representation</p>\n				<p class="bx--modal-header__heading bx--type-beta" id="modal-description">' + options2.title + '</p>\n				<button class="bx--modal-close" type="button" data-modal-close aria-label="close modal"  data-modal-primary-focus>\n					<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" fill="currentColor" aria-label="Close" width="20" height="20" viewBox="0 0 32 32" role="img" class="bx--modal-close__icon">\n						<path d="M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"></path>\n					</svg>\n				</button>\n			</div>\n			<div class="bx--modal-content"><table class="bx--data-table bx--data-table--no-border">\n					<thead>\n						<tr>\n							' + get$3(tableArray, 0).map(function(heading) {
      return '<th scope="col">\n								<div class="bx--table-header-label">' + heading + "</div>\n							</th>";
    }).join("") + "\n						</tr>\n					</thead>\n					<tbody>" + tableArray.slice(1).map(function(row) {
      return "\n							<tr>\n								" + row.map(function(column) {
        return "<td>" + column + "</td>";
      }).join("") + "\n							</tr>";
    }).join("") + '\n					</tbody>\n				</table>\n			</div>\n			<div class="bx--modal-footer">\n			  <div class="' + settings$1.prefix + "--" + chartprefix + '-modal-footer-spacer"></div>\n			  <button class="bx--btn bx--btn--primary" type="button" data-modal-primary-focus>Download as CSV</button>\n			</div>\n		</div>';
  };
  Modal2.prototype.render = function() {
    var options2 = this.model.getOptions();
    if (!this.isEventListenerAdded) {
      var holder = select(this.services.domUtils.getHolder());
      var chartprefix = Tools.getProperty(options2, "style", "prefix");
      this.modal = DOMUtils.appendOrSelect(holder, "div." + settings$1.prefix + "--" + chartprefix + "--modal");
      this.addEventListeners();
      this.isEventListenerAdded = true;
      this.modal.attr("data-modal", true).attr("class", "bx--modal").attr("role", "dialog").attr("aria-modal", true).attr("aria-labelledby", "modal-title").attr("aria-describedby", "modal-description").attr("tabindex", -1);
    }
  };
  Modal2.prototype.destroy = function() {
    this.removeEventListeners();
    this.isEventListenerAdded = false;
  };
  return Modal2;
}(Component);
var _a$1;
var PLACEMENTS;
(function(PLACEMENTS2) {
  PLACEMENTS2["LEFT"] = "left";
  PLACEMENTS2["RIGHT"] = "right";
  PLACEMENTS2["TOP"] = "top";
  PLACEMENTS2["BOTTOM"] = "bottom";
})(PLACEMENTS || (PLACEMENTS = {}));
var defaultPositions = (_a$1 = {}, _a$1[PLACEMENTS.LEFT] = function(referenceOffset, target, referenceRect) {
  return {
    top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),
    left: Math.round(referenceOffset.left - target.offsetWidth)
  };
}, _a$1[PLACEMENTS.RIGHT] = function(referenceOffset, target, referenceRect) {
  return {
    top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),
    left: Math.round(referenceOffset.left + referenceRect.width)
  };
}, _a$1[PLACEMENTS.TOP] = function(referenceOffset, target, referenceRect) {
  return {
    top: Math.round(referenceOffset.top - target.offsetHeight),
    left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)
  };
}, _a$1[PLACEMENTS.BOTTOM] = function(referenceOffset, target, referenceRect) {
  return {
    top: Math.round(referenceOffset.top + referenceRect.height),
    left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)
  };
}, _a$1);
var windowRef = typeof window !== "undefined" ? window : {
  innerHeight: 0,
  scrollY: 0,
  innerWidth: 0,
  scrollX: 0
};
var Position = function() {
  function Position2(positions) {
    if (positions === void 0) {
      positions = {};
    }
    this.positions = defaultPositions;
    this.positions = Object.assign({}, defaultPositions, positions);
  }
  Position2.prototype.getRelativeOffset = function(target) {
    var offsets = {
      left: target.offsetLeft,
      top: target.offsetTop
    };
    while (target.offsetParent && getComputedStyle(target.offsetParent).position === "static") {
      offsets.left += target.offsetLeft;
      offsets.top += target.offsetTop;
      target = target.offsetParent;
    }
    return offsets;
  };
  Position2.prototype.getAbsoluteOffset = function(target) {
    var currentNode = target;
    var margins = {
      top: 0,
      left: 0
    };
    while (currentNode.offsetParent) {
      var computed = getComputedStyle(currentNode.offsetParent);
      if (computed.position === "static" && computed.marginLeft && computed.marginTop) {
        if (parseInt(computed.marginTop, 10)) {
          margins.top += parseInt(computed.marginTop, 10);
        }
        if (parseInt(computed.marginLeft, 10)) {
          margins.left += parseInt(computed.marginLeft, 10);
        }
      }
      currentNode = currentNode.offsetParent;
    }
    var targetRect = target.getBoundingClientRect();
    var relativeRect = document.body.getBoundingClientRect();
    return {
      top: targetRect.top - relativeRect.top + margins.top,
      left: targetRect.left - relativeRect.left + margins.left
    };
  };
  Position2.prototype.findRelative = function(reference, target, placement) {
    var referenceOffset = this.getRelativeOffset(reference);
    var referenceRect = reference.getBoundingClientRect();
    return this.calculatePosition(referenceOffset, referenceRect, target, placement);
  };
  Position2.prototype.findAbsolute = function(reference, target, placement) {
    var referenceOffset = this.getAbsoluteOffset(reference);
    var referenceRect = reference.getBoundingClientRect();
    return this.calculatePosition(referenceOffset, referenceRect, target, placement);
  };
  Position2.prototype.findPosition = function(reference, target, placement, offsetFunction) {
    if (offsetFunction === void 0) {
      offsetFunction = this.getAbsoluteOffset;
    }
    var referenceOffset = offsetFunction(reference);
    var referenceRect = reference.getBoundingClientRect();
    return this.calculatePosition(referenceOffset, referenceRect, target, placement);
  };
  Position2.prototype.findPositionAt = function(offset, target, placement) {
    return this.calculatePosition(offset, { height: 0, width: 0 }, target, placement);
  };
  Position2.prototype.getPlacementBox = function(target, position) {
    var targetBottom = target.offsetHeight + position.top;
    var targetRight = target.offsetWidth + position.left;
    return {
      top: position.top,
      bottom: targetBottom,
      left: position.left,
      right: targetRight
    };
  };
  Position2.prototype.addOffset = function(position, top2, left2) {
    if (top2 === void 0) {
      top2 = 0;
    }
    if (left2 === void 0) {
      left2 = 0;
    }
    return Object.assign({}, position, {
      top: position.top + top2,
      left: position.left + left2
    });
  };
  Position2.prototype.setElement = function(element, position) {
    element.style.top = position.top + "px";
    element.style.left = position.left + "px";
  };
  Position2.prototype.findBestPlacement = function(reference, target, placements, containerFunction, positionFunction) {
    var _this = this;
    if (containerFunction === void 0) {
      containerFunction = this.defaultContainerFunction;
    }
    if (positionFunction === void 0) {
      positionFunction = this.findPosition;
    }
    var weightedPlacements = placements.map(function(placement) {
      var pos = positionFunction(reference, target, placement);
      var box = _this.getPlacementBox(target, pos);
      var hiddenHeight = box.bottom - containerFunction().height;
      var hiddenWidth = box.right - containerFunction().width;
      hiddenHeight = hiddenHeight < 0 ? target.offsetHeight : hiddenHeight;
      hiddenWidth = hiddenWidth < 0 ? target.offsetWidth : hiddenWidth;
      var area2 = target.offsetHeight * target.offsetWidth;
      var hiddenArea = hiddenHeight * hiddenWidth;
      var visibleArea = area2 - hiddenArea;
      visibleArea = visibleArea === 0 ? area2 : visibleArea;
      var visiblePercent = visibleArea / area2;
      return {
        placement,
        weight: visiblePercent
      };
    });
    weightedPlacements.sort(function(a, b) {
      return b.weight - a.weight;
    });
    return weightedPlacements[0].placement;
  };
  Position2.prototype.findBestPlacementAt = function(offset, target, placements, containerFunction) {
    var _this = this;
    if (containerFunction === void 0) {
      containerFunction = this.defaultContainerFunction;
    }
    var positionAt = function(_, target2, placement) {
      return _this.findPositionAt(offset, target2, placement);
    };
    return this.findBestPlacement(null, target, placements, containerFunction, positionAt);
  };
  Position2.prototype.defaultContainerFunction = function() {
    return {
      width: windowRef.innerHeight - windowRef.scrollY,
      height: windowRef.innerWidth - windowRef.scrollX
    };
  };
  Position2.prototype.calculatePosition = function(referenceOffset, referenceRect, target, placement) {
    if (this.positions[placement]) {
      return this.positions[placement](referenceOffset, target, referenceRect);
    }
    console.error("No function found for placement, defaulting to 0,0");
    return { left: 0, top: 0 };
  };
  return Position2;
}();
new Position();
var TIME_INTERVALS = [
  ["15seconds", 15 * 1e3],
  ["minute", 60 * 1e3],
  ["30minutes", 30 * 60 * 1e3],
  ["hourly", 60 * 60 * 1e3],
  ["daily", 24 * 60 * 60 * 1e3],
  ["monthly", 30 * 24 * 60 * 60 * 1e3],
  ["quarterly", 3 * 30 * 24 * 60 * 60 * 1e3],
  ["yearly", 12 * 30 * 24 * 60 * 60 * 1e3]
];
function isTickPrimary(tick, i, allTicks, interval2, showDayName) {
  var isFirstTick = i === 0;
  var hasANewWeekStarted = Number(format(new Date(tick), "c")) === 2;
  var isFirstQuarter = Number(format(new Date(tick), "q")) === 1;
  var previousTick = i !== 0 ? allTicks[i - 1] : null;
  switch (interval2) {
    case "15seconds":
      return isFirstTick || isDayOfMonthChanged(tick) || isMonthChanged(tick, previousTick) || isYearChanged(tick);
    case "minute":
      return isFirstTick || isDayOfMonthChanged(tick) || isMonthChanged(tick, previousTick) || isYearChanged(tick);
    case "30minutes":
      return isFirstTick || isDayOfMonthChanged(tick) || isMonthChanged(tick, previousTick) || isYearChanged(tick);
    case "hourly":
      return isFirstTick || isDayOfMonthChanged(tick) || isMonthChanged(tick, previousTick) || isYearChanged(tick);
    case "daily":
      if (!showDayName) {
        return isFirstTick || isMonthChanged(tick, previousTick) || isYearChanged(tick);
      } else {
        return isFirstTick || hasANewWeekStarted || isYearChanged(tick);
      }
    case "monthly":
      return isFirstTick || isYearChanged(tick);
    case "quarterly":
      return isFirstTick || isFirstQuarter;
    case "yearly":
      return false;
    default:
      throw new Error(interval2 + " is not a valid time interval.");
  }
}
function formatTick(tick, i, allTicks, interval2, timeScaleOptions) {
  var showDayName = timeScaleOptions.showDayName;
  var intervalConsideringAlsoShowDayNameOption = interval2 === "daily" && showDayName ? "weekly" : interval2;
  var date2 = new Date(tick);
  var formats = Tools.getProperty(timeScaleOptions, "timeIntervalFormats")[intervalConsideringAlsoShowDayNameOption];
  var primary = Tools.getProperty(formats, "primary");
  var secondary = Tools.getProperty(formats, "secondary");
  var formatString = isTickPrimary(tick, i, allTicks, interval2, showDayName) ? primary : secondary;
  var locale2 = timeScaleOptions.localeObject;
  return format(date2, formatString, { locale: locale2 });
}
function getTimeformats(timestamp) {
  var date2 = new Date(timestamp);
  return {
    M: date2.getMonth() + 1,
    d: date2.getDate(),
    H: date2.getHours(),
    m: date2.getMinutes(),
    s: date2.getSeconds()
  };
}
function getConsecutiveDifferences(elements) {
  if (!elements) {
    return;
  }
  return elements.slice(1).map(function(elem, i) {
    return elem - elements[i];
  });
}
function closestTimeIntervalName(duration) {
  var index2 = TIME_INTERVALS.reduce(function(nearestIndex, _a2, i) {
    _a2[0];
    var delta = _a2[1];
    var deltaNearest = TIME_INTERVALS[nearestIndex][1];
    var oldNearestSpan = Math.abs(deltaNearest - duration);
    var currentSpan = Math.abs(delta - duration);
    return oldNearestSpan < currentSpan ? nearestIndex : i;
  }, 0);
  return TIME_INTERVALS[index2][0];
}
function computeTimeIntervalName(ticks2) {
  if (ticks2.length === 1) {
    return "15seconds";
  }
  var differences = getConsecutiveDifferences(ticks2);
  var minDifference = min$3(differences);
  return closestTimeIntervalName(minDifference);
}
function isDayOfMonthChanged(timestamp) {
  var _a2 = getTimeformats(timestamp), s = _a2.s, m = _a2.m, H = _a2.H;
  return H === 0 && m === 0 && s === 0;
}
function isMonthChanged(timestamp, previousTimestamp) {
  var currentMonth = getTimeformats(timestamp).M;
  var previousMonth = getTimeformats(previousTimestamp).M;
  return currentMonth !== previousMonth;
}
function isYearChanged(timestamp) {
  var _a2 = getTimeformats(timestamp), M = _a2.M, d = _a2.d, s = _a2.s, m = _a2.m, H = _a2.H;
  return M === 1 && d === 1 && H === 0 && m === 0 && s === 0;
}
var __extends$1m = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Threshold = function(_super) {
  __extends$1m(Threshold2, _super);
  function Threshold2(model, services) {
    var _this = _super.call(this, model, services) || this;
    _this.type = "threshold";
    _this.renderType = RenderTypes.SVG;
    _this.positionService = new Position();
    return _this;
  }
  Threshold2.prototype.render = function(animate) {
    var _this = this;
    if (animate === void 0) {
      animate = false;
    }
    var axesOptions = Tools.getProperty(this.getOptions(), "axes");
    var thresholdData = [];
    Object.keys(axesOptions).forEach(function(axisPosition) {
      var _a2, _b;
      if (Object.values(AxisPositions).includes(axisPosition)) {
        var axisOptions = axesOptions[axisPosition];
        if (axisOptions.thresholds && axisOptions.thresholds.length > 0) {
          thresholdData.push({
            axisPosition,
            thresholds: axisOptions.thresholds,
            correspondingDatasets: (_a2 = axisOptions) === null || _a2 === void 0 ? void 0 : _a2.correspondingDatasets,
            mapsTo: (_b = axisOptions) === null || _b === void 0 ? void 0 : _b.mapsTo
          });
        }
      }
    });
    var svg = this.getComponentContainer({ withinChartClip: true });
    var thresholdAxisGroups = svg.selectAll("g.axis-thresholds").data(thresholdData, function(thresholdData2) {
      return thresholdData2.axisPosition;
    });
    thresholdAxisGroups.exit().attr("opacity", 0).remove();
    var thresholdAxisGroupsEnter = thresholdAxisGroups.enter().append("g");
    var thresholdAxisGroupsMerge = thresholdAxisGroupsEnter.merge(thresholdAxisGroups);
    thresholdAxisGroupsMerge.attr("class", function(d) {
      return "axis-thresholds " + d.axisPosition;
    });
    var thresholdGroups = thresholdAxisGroupsMerge.selectAll("g.threshold-group").data(function(d) {
      return d.thresholds.map(function(threshold) {
        threshold.axisPosition = d.axisPosition;
        threshold.datum = _this.constructDatumObj(d, threshold);
        return threshold;
      });
    });
    thresholdGroups.exit().attr("opacity", 0).remove();
    var thresholdGroupsEnter = thresholdGroups.enter().append("g");
    thresholdGroupsEnter.append("line").attr("class", "threshold-line");
    thresholdGroupsEnter.append("rect").attr("class", "threshold-hoverable-area");
    var thresholdGroupsMerge = thresholdGroupsEnter.merge(thresholdGroups);
    thresholdGroupsMerge.attr("class", "threshold-group");
    var self2 = this;
    thresholdAxisGroupsMerge.each(function(_a2) {
      var axisPosition = _a2.axisPosition;
      var scale = self2.services.cartesianScales.getScaleByPosition(axisPosition);
      var scaleType = self2.services.cartesianScales.getScaleTypeByPosition(axisPosition);
      var xScale = null;
      var yScale = null;
      if (axisPosition === AxisPositions.LEFT || axisPosition === AxisPositions.RIGHT) {
        yScale = scale;
        xScale = self2.services.cartesianScales.getMainXScale();
      } else {
        xScale = scale;
        yScale = self2.services.cartesianScales.getMainYScale();
      }
      var isScaleTypeLabels = scaleType === ScaleTypes.LABELS;
      var _b = xScale.range(), xScaleStart = _b[0], xScaleEnd = _b[1];
      var _c = yScale.range(), yScaleEnd = _c[0], yScaleStart = _c[1];
      var cartesianScales = self2.services.cartesianScales;
      var orientation = cartesianScales.getOrientation();
      var getDomainValue = function(d) {
        return cartesianScales.getDomainValue(d);
      };
      var getRangeValue = function(d) {
        return cartesianScales.getRangeValue(d);
      };
      var _d = Tools.flipDomainAndRangeBasedOnOrientation(getDomainValue, getRangeValue, orientation), getXValue = _d[0], getYValue = _d[1];
      var group = select(this);
      if (axisPosition === AxisPositions.TOP || axisPosition === AxisPositions.BOTTOM) {
        group.selectAll("line.threshold-line").transition().call(function(t) {
          return self2.services.transitions.setupTransition({
            transition: t,
            name: "threshold-line-update",
            animate
          });
        }).attr("y1", yScaleStart).attr("y2", yScaleEnd).attr("x1", function(_a3) {
          var datum2 = _a3.datum;
          return getXValue(datum2) + (isScaleTypeLabels ? scale.step() / 2 : 0);
        }).attr("x2", function(_a3) {
          var datum2 = _a3.datum;
          return getXValue(datum2) + (isScaleTypeLabels ? scale.step() / 2 : 0);
        }).style("stroke", function(_a3) {
          var fillColor = _a3.fillColor;
          return fillColor;
        });
        group.selectAll("rect.threshold-hoverable-area").attr("x", 0).attr("y", function(_a3) {
          var datum2 = _a3.datum;
          return -getXValue(datum2);
        }).attr("width", Math.abs(yScaleEnd - yScaleStart)).classed("rotate", true);
      } else {
        group.selectAll("line.threshold-line").transition().call(function(t) {
          return self2.services.transitions.setupTransition({
            transition: t,
            name: "threshold-line-update",
            animate
          });
        }).attr("x1", xScaleStart).attr("x2", xScaleEnd).attr("y1", function(_a3) {
          var datum2 = _a3.datum;
          return getYValue(datum2) + (isScaleTypeLabels ? scale.step() / 2 : 0);
        }).attr("y2", function(_a3) {
          var datum2 = _a3.datum;
          return getYValue(datum2) + (isScaleTypeLabels ? scale.step() / 2 : 0);
        }).style("stroke", function(_a3) {
          var fillColor = _a3.fillColor;
          return fillColor;
        });
        group.selectAll("rect.threshold-hoverable-area").attr("x", xScaleStart).attr("y", function(_a3) {
          var datum2 = _a3.datum;
          return getYValue(datum2);
        }).attr("width", Math.abs(xScaleEnd - xScaleStart)).classed("rotate", false);
      }
    });
    this.services.events.addEventListener(Events$1.Threshold.SHOW, function(e) {
      _this.setThresholdLabelPosition(e.detail);
      _this.label.classed("hidden", false);
    });
    this.services.events.addEventListener(Events$1.Threshold.HIDE, function(e) {
      _this.label.classed("hidden", true);
    });
    this.appendThresholdLabel();
    this.addEventListeners();
  };
  Threshold2.prototype.getFormattedValue = function(datum2) {
    var value2 = datum2.value, axisPosition = datum2.axisPosition;
    var options2 = this.getOptions();
    var scaleType = this.services.cartesianScales.getScaleTypeByPosition(axisPosition);
    if (scaleType === ScaleTypes.TIME) {
      var isVertical = [
        AxisPositions.LEFT,
        AxisPositions.RIGHT
      ].includes(axisPosition);
      var mainXScale = this.services.cartesianScales.getMainXScale();
      var mainYScale = this.services.cartesianScales.getMainYScale();
      var scale = isVertical ? mainYScale : mainXScale;
      var timeScaleOptions = Tools.getProperty(options2, "timeScale");
      var timeInterval = computeTimeIntervalName(scale.ticks());
      return formatTick(value2, 0, scale.ticks(), timeInterval, timeScaleOptions);
    }
    return value2.toLocaleString("en");
  };
  Threshold2.prototype.appendThresholdLabel = function() {
    var holder = select(this.services.domUtils.getHolder());
    var chartprefix = Tools.getProperty(this.getOptions(), "style", "prefix");
    this.label = DOMUtils.appendOrSelect(holder, "div." + settings$1.prefix + "--" + chartprefix + "--threshold--label").classed("hidden", true);
  };
  Threshold2.prototype.setThresholdLabelPosition = function(_a2) {
    var event = _a2.event, datum2 = _a2.datum;
    var holder = this.services.domUtils.getHolder();
    var mouseRelativePos = pointer(event, holder);
    var formattedValue = datum2.valueFormatter ? datum2.valueFormatter(datum2.value) : this.getFormattedValue(datum2);
    this.label.html((datum2.label || "Threshold") + ": " + formattedValue).style("background-color", datum2.fillColor);
    var target = this.label.node();
    var bestPlacementOption = this.positionService.findBestPlacementAt({
      left: mouseRelativePos[0],
      top: mouseRelativePos[1]
    }, target, [
      PLACEMENTS.RIGHT,
      PLACEMENTS.LEFT,
      PLACEMENTS.TOP,
      PLACEMENTS.BOTTOM
    ], function() {
      return {
        width: holder.offsetWidth,
        height: holder.offsetHeight
      };
    });
    var pos = this.positionService.findPositionAt({
      left: mouseRelativePos[0],
      top: mouseRelativePos[1]
    }, target, bestPlacementOption);
    this.positionService.setElement(target, pos);
  };
  Threshold2.prototype.constructDatumObj = function(d, element) {
    var datum2 = {};
    if (d.correspondingDatasets) {
      datum2["group"] = Tools.getProperty(d, "correspondingDatasets", 0);
    }
    datum2[d["mapsTo"]] = element.value;
    return datum2;
  };
  Threshold2.prototype.addEventListeners = function() {
    var self2 = this;
    var svg = this.getComponentContainer({ withinChartClip: true });
    svg.selectAll("rect.threshold-hoverable-area").on("mouseover mousemove", function(event) {
      select(this.parentNode).select("line.threshold-line").classed("active", true);
      self2.services.events.dispatchEvent(Events$1.Threshold.SHOW, {
        event,
        hoveredElement: select(this),
        datum: select(this).datum()
      });
    }).on("mouseout", function(event) {
      select(this.parentNode).select("line.threshold-line").classed("active", false);
      self2.services.events.dispatchEvent(Events$1.Threshold.HIDE, {
        event,
        hoveredElement: select(this),
        datum: select(this).datum()
      });
    });
  };
  return Threshold2;
}(Component);
var __extends$1l = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Title = function(_super) {
  __extends$1l(Title2, _super);
  function Title2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "title";
    _this.renderType = RenderTypes.HTML;
    return _this;
  }
  Title2.prototype.render = function() {
    var svg = this.getComponentContainer();
    var title = Tools.getProperty(this.getOptions(), "title");
    var text = svg.selectAll("p.title").data([title]);
    text.enter().append("p").classed("title", true).attr("role", "heading").attr("aria-level", 2).merge(text).html(function(d) {
      return d;
    });
    if (text.node() && text.node().offsetWidth < text.node().scrollWidth) {
      var self_1 = this;
      text.on("mouseover", function(event) {
        self_1.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
          event,
          hoveredElement: text,
          content: text.text()
        });
      }).on("mousemove", function(event) {
        self_1.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
          event
        });
      }).on("mouseout", function() {
        self_1.services.events.dispatchEvent(Events$1.Tooltip.HIDE);
      });
    }
    text.exit().remove();
  };
  Title2.prototype.truncateTitle = function(title, maxWidth) {
    if (maxWidth <= 0) {
      return;
    }
    var untruncatedTitle = title.text();
    if (title.node().getComputedTextLength() > maxWidth) {
      title.append("tspan").text("...");
      var tspanLength = DOMUtils.appendOrSelect(title, "tspan").node().getComputedTextLength();
      var titleString = title.text();
      var substringIndex = this.getSubstringIndex(title.node(), 0, titleString.length - 1, maxWidth - tspanLength);
      title.html(titleString.substring(0, substringIndex - 1)).append("tspan").text("...");
      var self_2 = this;
      title.on("mouseover", function(event) {
        self_2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
          event,
          hoveredElement: title,
          content: untruncatedTitle
        });
      }).on("mousemove", function(event) {
        self_2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
          event
        });
      }).on("mouseout", function() {
        self_2.services.events.dispatchEvent(Events$1.Tooltip.HIDE);
      });
    }
  };
  Title2.prototype.getMaxTitleWidth = function() {
    return DOMUtils.getSVGElementSize(this.parent.node(), {
      useAttrs: true
    }).width;
  };
  Title2.prototype.getSubstringIndex = function(title, start2, end, width) {
    var mid = Math.floor((end + start2) / 2);
    if (title.getSubStringLength(0, mid) > width) {
      return this.getSubstringIndex(title, start2, mid, width);
    } else if (title.getSubStringLength(0, mid) < width) {
      if (title.getSubStringLength(0, mid + 1) > width) {
        return mid;
      }
      return this.getSubstringIndex(title, mid, end, width);
    } else {
      return mid;
    }
  };
  return Title2;
}(Component);
var __extends$1k = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var MeterTitle = function(_super) {
  __extends$1k(MeterTitle2, _super);
  function MeterTitle2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "meter-title";
    _this.renderType = RenderTypes.SVG;
    return _this;
  }
  MeterTitle2.prototype.render = function() {
    var dataset = Tools.getProperty(this.model.getDisplayData(), 0);
    var options2 = this.getOptions();
    var svg = this.getComponentContainer();
    var groupMapsTo = options2.data.groupMapsTo;
    var proportional = Tools.getProperty(options2, "meter", "proportional");
    if (proportional) {
      this.displayTotal();
      this.displayBreakdownTitle();
    } else {
      var title = svg.selectAll("text.meter-title").data([dataset[groupMapsTo]]);
      title.enter().append("text").classed("meter-title", true).merge(title).attr("x", 0).attr("y", "1em").text(function(d) {
        return d;
      });
      title.exit().remove();
      this.appendPercentage();
    }
    this.displayStatus();
    var maxWidth = this.getMaxTitleWidth();
    var titleElement = DOMUtils.appendOrSelect(svg, "text.meter-title");
    if (maxWidth > 0 && titleElement.node().getComputedTextLength() > maxWidth) {
      this.truncateTitle(titleElement, maxWidth);
    }
  };
  MeterTitle2.prototype.displayBreakdownTitle = function() {
    var svg = this.getComponentContainer();
    var options2 = this.getOptions();
    var datasetsTotal = this.model.getMaximumDomain(this.model.getDisplayData());
    var total = Tools.getProperty(options2, "meter", "proportional", "total");
    var unit2 = Tools.getProperty(options2, "meter", "proportional", "unit") ? Tools.getProperty(options2, "meter", "proportional", "unit") : "";
    var data;
    if (datasetsTotal === total) {
      data = null;
    } else {
      var difference = total !== null ? total - datasetsTotal : datasetsTotal;
      var breakdownFormatter = Tools.getProperty(options2, "meter", "proportional", "breakdownFormatter");
      data = breakdownFormatter !== null ? breakdownFormatter({
        datasetsTotal,
        total
      }) : datasetsTotal + " " + unit2 + " used (" + difference + " " + unit2 + " available)";
    }
    var title = svg.selectAll("text.proportional-meter-title").data([data]);
    title.enter().append("text").classed("proportional-meter-title", true).merge(title).attr("x", 0).attr("y", "1em").text(function(d) {
      return d;
    });
    title.exit().remove();
    var maxWidth = this.getMaxTitleWidth();
    var titleElement = DOMUtils.appendOrSelect(svg, "text.proportional-meter-title");
    if (maxWidth > 0 && titleElement.node().getComputedTextLength() > maxWidth) {
      this.truncateTitle(titleElement, maxWidth);
    }
  };
  MeterTitle2.prototype.displayTotal = function() {
    var svg = this.getComponentContainer();
    var options2 = this.getOptions();
    var total = Tools.getProperty(options2, "meter", "proportional", "total");
    var totalValue = total ? Tools.getProperty(options2, "meter", "proportional", "total") : this.model.getMaximumDomain(this.model.getDisplayData());
    var unit2 = Tools.getProperty(options2, "meter", "proportional", "unit") ? Tools.getProperty(options2, "meter", "proportional", "unit") : "";
    var totalFormatter = Tools.getProperty(options2, "meter", "proportional", "totalFormatter");
    var totalString = totalFormatter !== null ? totalFormatter(totalValue) : total + " " + unit2 + " total";
    var containerBounds = DOMUtils.getHTMLElementSize(this.services.domUtils.getMainContainer());
    var containerWidth = containerBounds.width ? containerBounds.width : this.parent.node().getAttribute("width");
    var title = svg.selectAll("text.proportional-meter-total").data([totalString]);
    title.enter().append("text").classed("proportional-meter-total", true).merge(title).attr("x", this.model.getStatus() ? containerWidth - meter.total.paddingRight : containerWidth).attr("y", "1em").attr("text-anchor", "end").text(function(d) {
      return d;
    });
    title.exit().remove();
  };
  MeterTitle2.prototype.displayStatus = function() {
    var self2 = this;
    var svg = this.getComponentContainer();
    var containerBounds = DOMUtils.getHTMLElementSize(this.services.domUtils.getMainContainer());
    var containerWidth = containerBounds.width ? containerBounds.width : 0;
    var status = this.model.getStatus();
    var radius = meter.status.indicatorSize / 2;
    var statusGroup = DOMUtils.appendOrSelect(svg, "g.status-indicator").attr("class", status !== null ? "status-indicator status--" + status : "").attr("transform", "translate(" + (containerWidth - radius) + ", 0)");
    var data = status ? [status] : [];
    var icon = statusGroup.selectAll("circle.status").data(data);
    icon.enter().append("circle").merge(icon).attr("class", "status").attr("r", radius).attr("cx", 0).attr("cy", "calc(1em / 2)");
    var innerIcon = statusGroup.selectAll("path.innerFill").data(data);
    innerIcon.enter().append("path").merge(innerIcon).attr("d", self2.getStatusIconPathString(status)).attr("transform", "translate(-" + radius + ", 0)").attr("class", "innerFill");
    innerIcon.exit().remove();
    icon.exit().remove();
  };
  MeterTitle2.prototype.appendPercentage = function() {
    var dataValue = Tools.getProperty(this.model.getDisplayData(), 0, "value");
    var svg = this.getComponentContainer();
    var title = DOMUtils.appendOrSelect(svg, "text.meter-title");
    var data = Tools.getProperty(this.getOptions(), "meter", "statusBar", "percentageIndicator", "enabled") === true ? [dataValue] : [];
    var percentage = svg.selectAll("text.percent-value").data(data);
    var offset = meter.statusBar.paddingRight;
    percentage.enter().append("text").classed("percent-value", true).merge(percentage).text(function(d) {
      return d + "%";
    }).attr("x", +title.attr("x") + title.node().getComputedTextLength() + offset).attr("y", title.attr("y"));
    percentage.exit().remove();
  };
  MeterTitle2.prototype.truncateTitle = function(title, maxWidth) {
    _super.prototype.truncateTitle.call(this, title, maxWidth);
    var tspan = DOMUtils.appendOrSelect(this.parent, "tspan");
    var offset = meter.statusBar.paddingRight;
    var tspanLength = Math.ceil(tspan.node().getComputedTextLength());
    var percentage = DOMUtils.appendOrSelect(this.parent, "text.percent-value");
    percentage.attr("x", +title.attr("x") + title.node().getComputedTextLength() + tspanLength + offset);
  };
  MeterTitle2.prototype.getMaxTitleWidth = function() {
    var containerBounds = DOMUtils.getHTMLElementSize(this.services.domUtils.getMainContainer());
    var proportional = Tools.getProperty(this.getOptions(), "meter", "proportional");
    var containerWidth = containerBounds.width ? containerBounds.width : this.parent.node().getAttribute("width");
    if (proportional !== null) {
      var total = DOMUtils.appendOrSelect(this.parent, "text.proportional-meter-total").node();
      var totalWidth = DOMUtils.getSVGElementSize(total, {
        useBBox: true
      }).width;
      return containerWidth - totalWidth - meter.total.paddingLeft;
    } else {
      var percentage = DOMUtils.appendOrSelect(this.parent, "text.percent-value");
      var offset = meter.statusBar.paddingRight;
      var percentageWidth = percentage.node().getComputedTextLength();
      var statusGroup = DOMUtils.appendOrSelect(this.parent, "g.status-indicator").node();
      var statusWidth = DOMUtils.getSVGElementSize(statusGroup, { useBBox: true }).width + meter.status.paddingLeft;
      return containerWidth - percentageWidth - offset - statusWidth;
    }
  };
  MeterTitle2.prototype.getStatusIconPathString = function(status) {
    switch (status) {
      case Statuses.SUCCESS:
        return "M6.875 11.3125 3.75 8.1875 4.74375 7.25 6.875 9.34375 11.50625 4.75 12.5 5.7375 Z";
      case Statuses.DANGER:
        return "M10.7 11.5 4.5 5.3 5.3 4.5 11.5 10.7 Z";
      case Statuses.WARNING:
        return "M7.9375,11.125 C7.41973305,11.125 7,11.544733 7,12.0625 C7,12.580267 7.41973305,13 7.9375,13 C8.45526695,13 8.875,12.580267 8.875,12.0625 C8.875,11.544733 8.45526695,11.125 7.9375,11.125 M7.3125, 3 8.5625, 3 8.5625, 9.875 7.3125, 9.875, 7.3125, 3 Z";
    }
  };
  return MeterTitle2;
}(Title);
var __extends$1j = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Tooltip = function(_super) {
  __extends$1j(Tooltip2, _super);
  function Tooltip2(model, services, configs) {
    var _this = _super.call(this, model, services, configs) || this;
    _this.type = "tooltip";
    _this.renderType = RenderTypes.HTML;
    _this.isEventListenerAdded = false;
    _this.positionService = new Position();
    _this.handleShowTooltip = function(e) {
      var data = e.detail.data || e.detail.items;
      var defaultHTML = _this.getTooltipHTML(e);
      var tooltipTextContainer = DOMUtils.appendOrSelect(_this.tooltip, "div.content-box");
      if (Tools.getProperty(_this.getOptions(), "tooltip", "customHTML")) {
        if (e.detail.content) {
          var labelHTML = '<div class="title-tooltip"><p>' + e.detail.content + "</p></div>";
          tooltipTextContainer.html(labelHTML);
        } else {
          tooltipTextContainer.html(_this.model.getOptions().tooltip.customHTML(data, defaultHTML));
        }
      } else {
        tooltipTextContainer.html(defaultHTML);
      }
      _this.positionTooltip(e);
      _this.tooltip.classed("hidden", false).attr("aria-hidden", false);
    };
    _this.handleHideTooltip = function() {
      _this.tooltip.classed("hidden", true).attr("aria-hidden", true);
    };
    _this.init();
    return _this;
  }
  Tooltip2.prototype.addTooltipEventListener = function() {
    var _this = this;
    this.services.events.addEventListener(Events$1.Tooltip.MOVE, function(e) {
      if (_this.tooltip.classed("hidden") === false) {
        _this.positionTooltip(e);
      }
    });
    this.services.events.addEventListener(Events$1.Tooltip.SHOW, this.handleShowTooltip);
    this.services.events.addEventListener(Events$1.Tooltip.HIDE, this.handleHideTooltip);
    this.services.events.addEventListener(Events$1.Chart.MOUSEOUT, this.handleHideTooltip);
  };
  Tooltip2.prototype.removeTooltipEventListener = function() {
    this.services.events.removeEventListener(Events$1.Tooltip.MOVE, null);
    this.services.events.removeEventListener(Events$1.Tooltip.SHOW, this.handleShowTooltip);
    this.services.events.removeEventListener(Events$1.Tooltip.HIDE, this.handleHideTooltip);
    this.services.events.removeEventListener(Events$1.Chart.MOUSEOUT, this.handleHideTooltip);
  };
  Tooltip2.prototype.getItems = function(e) {
    if (e.detail.items) {
      return e.detail.items;
    }
    return [];
  };
  Tooltip2.prototype.formatItems = function(items) {
    var _this = this;
    var options2 = this.getOptions();
    var truncationType = Tools.getProperty(options2, "tooltip", "truncation", "type");
    var truncationThreshold = Tools.getProperty(options2, "tooltip", "truncation", "threshold");
    var truncationNumCharacter = Tools.getProperty(options2, "tooltip", "truncation", "numCharacter");
    if (truncationType !== TruncationTypes.NONE) {
      return items.map(function(item) {
        var labelIconSize = item.labelIcon ? 12 : 0;
        item.value = item.value ? _this.valueFormatter(item.value, item.label) : item.value;
        if (item.label && item.label.length + labelIconSize > truncationThreshold) {
          item.label = Tools.truncateLabel(item.label, truncationType, truncationNumCharacter);
        }
        if (item.value && item.value.length > truncationThreshold) {
          item.value = Tools.truncateLabel(item.value, truncationType, truncationNumCharacter);
        }
        return item;
      });
    }
    return items;
  };
  Tooltip2.prototype.getTooltipHTML = function(e) {
    var defaultHTML;
    if (e.detail.content) {
      defaultHTML = '<div class="title-tooltip"><p>' + e.detail.content + "</p></div>";
    } else {
      var items = this.getItems(e);
      var formattedItems = this.formatItems(items);
      defaultHTML = '<ul class="multi-tooltip">' + formattedItems.map(function(item) {
        return '<li>\n							<div class="datapoint-tooltip ' + (item.bold ? "bold" : "") + '">\n								' + (item.class ? '<div class="tooltip-color ' + item.class + '"></div>' : "") + "\n								" + (item.color ? '<div style="background-color: ' + item.color + '" class="tooltip-color"></div>' : "") + '\n								<div class="label">\n								<p>' + (item.label || "") + "</p>\n								" + (item.labelIcon ? '<span class="label-icon"/>' + item.labelIcon + "</span>" : "") + "\n								</div>\n								" + (item.value === void 0 || item.value === null ? "" : '<p class="value"/>' + item.value + "</p>") + "\n							</div>\n						</li>";
      }).join("") + "</ul>";
    }
    return defaultHTML;
  };
  Tooltip2.prototype.valueFormatter = function(value2, label) {
    var options2 = this.getOptions();
    var valueFormatter = Tools.getProperty(options2, "tooltip", "valueFormatter");
    if (valueFormatter) {
      return valueFormatter(value2, label);
    }
    if (typeof value2.getTime === "function") {
      return format(value2, "MMM d, yyyy");
    }
    return value2.toLocaleString();
  };
  Tooltip2.prototype.render = function() {
    var options2 = this.getOptions();
    var isTooltipEnabled = Tools.getProperty(options2, "tooltip", "enabled");
    if (isTooltipEnabled) {
      var holder = select(this.services.domUtils.getHolder());
      var chartprefix = Tools.getProperty(options2, "style", "prefix");
      this.tooltip = DOMUtils.appendOrSelect(holder, "div." + settings$1.prefix + "--" + chartprefix + "--tooltip");
      this.tooltip.style("max-width", null).attr("role", "tooltip");
      if (!this.isEventListenerAdded) {
        this.addTooltipEventListener();
        this.isEventListenerAdded = true;
      }
      this.tooltip.classed("hidden", true);
    } else if (!isTooltipEnabled && this.isEventListenerAdded) {
      this.removeTooltipEventListener();
      this.isEventListenerAdded = false;
    }
  };
  Tooltip2.prototype.positionTooltip = function(e) {
    var holder = this.services.domUtils.getHolder();
    var target = this.tooltip.node();
    var options2 = this.getOptions();
    var isTopZoomBarEnabled = Tools.getProperty(options2, "zoomBar", "top", "enabled");
    var mouseRelativePos = Tools.getProperty(e, "detail", "mousePosition");
    if (!mouseRelativePos) {
      mouseRelativePos = pointer(Tools.getProperty(e, "detail", "event"), holder);
    } else {
      var zoombarType = Tools.getProperty(options2, "zoomBar", "top", "type");
      var zoombarHeight = zoomBar.height[zoombarType];
      if (isTopZoomBarEnabled) {
        mouseRelativePos[1] += zoombarHeight + zoomBar.spacerHeight;
      }
    }
    var pos;
    var holderWidth = holder.offsetWidth;
    var holderHeight = holder.offsetHeight;
    var bestPlacementOption;
    if (mouseRelativePos[0] / holderWidth > 0.9) {
      bestPlacementOption = PLACEMENTS.LEFT;
    } else if (mouseRelativePos[0] / holderWidth < 0.1) {
      bestPlacementOption = PLACEMENTS.RIGHT;
    } else {
      bestPlacementOption = this.positionService.findBestPlacementAt({
        left: mouseRelativePos[0],
        top: mouseRelativePos[1]
      }, target, [
        PLACEMENTS.RIGHT,
        PLACEMENTS.LEFT,
        PLACEMENTS.TOP,
        PLACEMENTS.BOTTOM
      ], function() {
        return {
          width: holderWidth,
          height: holderHeight
        };
      });
    }
    var horizontalOffset = tooltips.horizontalOffset;
    if (bestPlacementOption === PLACEMENTS.LEFT) {
      horizontalOffset *= -1;
    }
    pos = this.positionService.findPositionAt({
      left: mouseRelativePos[0] + horizontalOffset,
      top: mouseRelativePos[1]
    }, target, bestPlacementOption);
    this.positionService.setElement(target, pos);
  };
  return Tooltip2;
}(Component);
var __extends$1i = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays$i = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var AxisChartsTooltip = function(_super) {
  __extends$1i(AxisChartsTooltip2, _super);
  function AxisChartsTooltip2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AxisChartsTooltip2.prototype.getItems = function(e) {
    var _this = this;
    if (e.detail.items) {
      return e.detail.items;
    }
    var data = e.detail.data;
    if (!data.length || !data[0]) {
      return [];
    }
    var options2 = this.getOptions();
    var cartesianScales = this.services.cartesianScales;
    var domainIdentifier = cartesianScales.getDomainIdentifier();
    var dualAxes = cartesianScales.isDualAxes();
    var groupMapsTo = options2.data.groupMapsTo;
    var domainLabel = cartesianScales.getDomainLabel();
    var rangeLabel = cartesianScales.getRangeLabel();
    var domainValue = data[0][domainIdentifier];
    var items;
    if (data.length === 1) {
      var datum2 = data[0];
      var rangeIdentifier = cartesianScales.getRangeIdentifier(datum2);
      if (dualAxes) {
        var position = cartesianScales.getRangeAxisPosition({
          datum: datum2,
          groups: [datum2[groupMapsTo]]
        });
        rangeLabel = cartesianScales.getScaleLabel(position);
      }
      var value2 = datum2[rangeIdentifier];
      items = __spreadArrays$i([
        {
          label: domainLabel,
          value: domainValue
        }
      ], Array.isArray(value2) && value2.length === 2 ? [
        {
          label: "Start",
          value: value2[0]
        },
        {
          label: "End",
          value: value2[1]
        }
      ] : [
        {
          label: rangeLabel,
          value: datum2[rangeIdentifier]
        }
      ]);
      if (e.detail.additionalItems) {
        e.detail.additionalItems.forEach(function(additionalItem) {
          return items.push({
            label: additionalItem.label,
            value: additionalItem.value
          });
        });
      }
      items.push({
        label: options2.tooltip.groupLabel,
        value: datum2[groupMapsTo],
        color: this.model.getFillColor(datum2[groupMapsTo]),
        class: this.model.getColorClassName({
          classNameTypes: [ColorClassNameTypes.TOOLTIP],
          dataGroupName: datum2[groupMapsTo]
        })
      });
    } else if (data.length > 1) {
      items = [
        {
          label: domainLabel,
          value: domainValue
        }
      ];
      items = items.concat(data.map(function(datum3) {
        var value3 = datum3[cartesianScales.getRangeIdentifier(datum3)];
        return {
          label: datum3[groupMapsTo],
          value: Array.isArray(value3) && value3.length === 2 ? value3[0] + " - " + value3[1] : value3,
          color: _this.model.getFillColor(datum3[groupMapsTo]),
          class: _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.TOOLTIP],
            dataGroupName: datum3[groupMapsTo]
          })
        };
      }).sort(function(a, b) {
        return b.value - a.value;
      }));
      if (!dualAxes && Tools.getProperty(options2, "tooltip", "showTotal") === true) {
        var rangeIdentifier_1 = cartesianScales.getRangeIdentifier();
        items.push({
          label: get$3(options2, "tooltip.totalLabel") || "Total",
          value: data.reduce(function(accumulator, datum3) {
            return accumulator + datum3[rangeIdentifier_1];
          }, 0),
          bold: true
        });
      }
    }
    return items;
  };
  return AxisChartsTooltip2;
}(Tooltip);
var __extends$1h = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ChartClip = function(_super) {
  __extends$1h(ChartClip2, _super);
  function ChartClip2(model, services, configs) {
    var _this = _super.call(this, model, services, configs) || this;
    _this.type = "chart-clip";
    _this.renderType = RenderTypes.SVG;
    _this.chartClipId = "chart-clip-id-" + Math.floor(Math.random() * 99999999999);
    _this.init();
    return _this;
  }
  ChartClip2.prototype.init = function() {
    this.model.set({ chartClipId: this.chartClipId }, { skipUpdate: true });
  };
  ChartClip2.prototype.render = function(animate) {
    this.createClipPath();
  };
  ChartClip2.prototype.createClipPath = function() {
    var svg = this.parent;
    var cartesianScales = this.services.cartesianScales;
    var mainXScale = cartesianScales.getMainXScale();
    var mainYScale = cartesianScales.getMainYScale();
    var _a2 = mainXScale.range(), xScaleStart = _a2[0], xScaleEnd = _a2[1];
    var _b = mainYScale.range(), yScaleEnd = _b[0], yScaleStart = _b[1];
    this.chartClipPath = DOMUtils.appendOrSelect(svg, "clipPath." + this.type).attr("id", this.chartClipId);
    var clipRect = DOMUtils.appendOrSelect(this.chartClipPath, "rect." + this.type);
    clipRect.attr("x", xScaleStart).attr("y", yScaleStart).attr("width", xScaleEnd - xScaleStart).attr("height", yScaleEnd - yScaleStart);
    this.chartClipPath.merge(clipRect).lower();
  };
  return ChartClip2;
}(Component);
var __extends$1g = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CanvasChartClip = function(_super) {
  __extends$1g(CanvasChartClip2, _super);
  function CanvasChartClip2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "canvas-chart-clip";
    _this.chartClipId = "canvas-chart-clip-id-" + Math.floor(Math.random() * 99999999999);
    return _this;
  }
  CanvasChartClip2.prototype.createClipPath = function() {
    var svg = this.parent;
    var _a2 = DOMUtils.getSVGElementSize(this.parent, {
      useAttrs: true
    }), width = _a2.width, height = _a2.height;
    this.chartClipPath = DOMUtils.appendOrSelect(svg, "clipPath." + this.type).attr("id", this.chartClipId);
    var clipRect = DOMUtils.appendOrSelect(this.chartClipPath, "rect." + this.type);
    clipRect.attr("x", 0).attr("y", 0).attr("width", width).attr("height", height);
    this.chartClipPath.merge(clipRect).lower();
  };
  return CanvasChartClip2;
}(ChartClip);
var __extends$1f = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __rest = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Highlight = function(_super) {
  __extends$1f(Highlight2, _super);
  function Highlight2(model, services) {
    var _this = _super.call(this, model, services) || this;
    _this.type = "highlight";
    _this.renderType = RenderTypes.SVG;
    _this.positionService = new Position();
    _this.highlightStrokeWidth = 1;
    return _this;
  }
  Highlight2.prototype.render = function(animate) {
    if (animate === void 0) {
      animate = false;
    }
    var axesOptions = Tools.getProperty(this.getOptions(), "axes");
    var highlightData = [];
    Object.keys(axesOptions).forEach(function(axisPosition) {
      if (Object.values(AxisPositions).includes(axisPosition)) {
        var axisOptions = axesOptions[axisPosition];
        if (axisOptions.highlights && axisOptions.highlights.data.length > 0) {
          highlightData.push({
            axisPosition,
            highlightStartMapsTo: axisOptions.highlights.highlightStartMapsTo,
            highlightEndMapsTo: axisOptions.highlights.highlightEndMapsTo,
            labelMapsTo: axisOptions.highlights.labelMapsTo,
            highlight: axisOptions.highlights.data,
            color: axisOptions.highlights.color
          });
        }
      }
    });
    var svg = this.getComponentContainer({ withinChartClip: true });
    var highlightAxisGroups = svg.selectAll("g.axis-highlight").data(highlightData, function(highlightData2) {
      return highlightData2.axisPosition;
    });
    highlightAxisGroups.exit().attr("opacity", 0).remove();
    var highlightAxisGroupsEnter = highlightAxisGroups.enter().append("g");
    var highlightAxisGroupsMerge = highlightAxisGroupsEnter.merge(highlightAxisGroups);
    highlightAxisGroupsMerge.attr("class", function(d) {
      return "axis-highlight " + d.axisPosition;
    });
    var highlightGroups = highlightAxisGroupsMerge.selectAll("g.highlight-group").data(function(d) {
      return d.highlight.map(function(highlight) {
        highlight.axisPosition = d.axisPosition;
        highlight.highlightStartMapsTo = d.highlightStartMapsTo;
        highlight.labelMapsTo = d.labelMapsTo;
        highlight.color = d.color;
        highlight.highlightEndMapsTo = d.highlightEndMapsTo;
        return highlight;
      });
    });
    highlightGroups.exit().attr("opacity", 0).remove();
    var highlightGroupsEnter = highlightGroups.enter().append("g");
    highlightGroupsEnter.append("rect").attr("class", "highlight-bar");
    highlightGroupsEnter.append("line").attr("class", "highlight-line");
    var highlightGroupsMerge = highlightGroupsEnter.merge(highlightGroups);
    highlightGroupsMerge.attr("class", "highlight-group");
    var self2 = this;
    highlightAxisGroupsMerge.each(function(_a2) {
      var axisPosition = _a2.axisPosition;
      var mainXScale = self2.services.cartesianScales.getMainXScale();
      var mainYScale = self2.services.cartesianScales.getMainYScale();
      var _b = mainXScale.range(), xScaleStart = _b[0], xScaleEnd = _b[1];
      var _c = mainYScale.range(), yScaleEnd = _c[0], yScaleStart = _c[1];
      var cartesianScales = self2.services.cartesianScales;
      var orientation = cartesianScales.getOrientation();
      var getDomainValue = function(d) {
        return cartesianScales.getDomainValue(d);
      };
      var getRangeValue = function(d) {
        return cartesianScales.getRangeValue(d);
      };
      var _d = Tools.flipDomainAndRangeBasedOnOrientation(getDomainValue, getRangeValue, orientation), getXValue = _d[0], getYValue = _d[1];
      var group = select(this);
      if (axisPosition === AxisPositions.TOP || axisPosition === AxisPositions.BOTTOM) {
        group.selectAll("rect.highlight-bar").transition().call(function(t) {
          return self2.services.transitions.setupTransition({
            transition: t,
            name: "highlight-bar-update",
            animate
          });
        }).attr("y", Math.max(yScaleStart + self2.highlightStrokeWidth, 0)).attr("height", Math.max(yScaleEnd - 2 * self2.highlightStrokeWidth, 0)).attr("x", function(_a3) {
          var highlightStartMapsTo = _a3.highlightStartMapsTo, d = __rest(_a3, ["highlightStartMapsTo"]);
          return getXValue(d[highlightStartMapsTo]);
        }).attr("width", function(_a3) {
          var highlightStartMapsTo = _a3.highlightStartMapsTo, highlightEndMapsTo = _a3.highlightEndMapsTo, d = __rest(_a3, ["highlightStartMapsTo", "highlightEndMapsTo"]);
          return Math.max(getXValue(d[highlightEndMapsTo]) - getXValue(d[highlightStartMapsTo]), 0);
        }).style("stroke", function(_a3) {
          var color2 = _a3.color, labelMapsTo = _a3.labelMapsTo, data = __rest(_a3, ["color", "labelMapsTo"]);
          return color2 && color2.scale[data[labelMapsTo]] ? color2.scale[data[labelMapsTo]] : null;
        }).style("stroke-dasharray", "2, 2").attr("stroke-width", self2.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", function(_a3) {
          var color2 = _a3.color, labelMapsTo = _a3.labelMapsTo, data = __rest(_a3, ["color", "labelMapsTo"]);
          return color2 && color2.scale[data[labelMapsTo]] ? color2.scale[data[labelMapsTo]] : null;
        });
      } else {
        group.selectAll("rect.highlight-bar").transition().call(function(t) {
          return self2.services.transitions.setupTransition({
            transition: t,
            name: "highlight-bar-update",
            animate
          });
        }).attr("x", xScaleStart).attr("width", Math.max(xScaleEnd - xScaleStart, 0)).attr("y", function(_a3) {
          var highlightEndMapsTo = _a3.highlightEndMapsTo, d = __rest(_a3, ["highlightEndMapsTo"]);
          return getYValue(d[highlightEndMapsTo]);
        }).attr("height", function(_a3) {
          var highlightStartMapsTo = _a3.highlightStartMapsTo, highlightEndMapsTo = _a3.highlightEndMapsTo, d = __rest(_a3, ["highlightStartMapsTo", "highlightEndMapsTo"]);
          return Math.max(getYValue(d[highlightStartMapsTo]) - getYValue(d[highlightEndMapsTo]), 0);
        }).style("stroke", function(_a3) {
          var color2 = _a3.color, labelMapsTo = _a3.labelMapsTo, data = __rest(_a3, ["color", "labelMapsTo"]);
          return color2 && color2.scale[data[labelMapsTo]] ? color2.scale[data[labelMapsTo]] : null;
        }).style("stroke-dasharray", "2, 2").attr("stroke-width", self2.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", function(_a3) {
          var color2 = _a3.color, labelMapsTo = _a3.labelMapsTo, data = __rest(_a3, ["color", "labelMapsTo"]);
          return color2 && color2.scale[data[labelMapsTo]] ? color2.scale[data[labelMapsTo]] : null;
        });
      }
    });
  };
  return Highlight2;
}(Component);
var __extends$1e = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Area = function(_super) {
  __extends$1e(Area2, _super);
  function Area2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "area";
    _this.renderType = RenderTypes.SVG;
    _this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999);
    _this.handleLegendOnHover = function(event) {
      var hoveredElement = event.detail.hoveredElement;
      _this.parent.selectAll("path.area").transition("legend-hover-area").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-hover-area"
        });
      }).attr("opacity", function(group) {
        if (group.name !== hoveredElement.datum()["name"]) {
          return area$1.opacity.unselected;
        }
        return area$1.opacity.selected;
      });
    };
    _this.handleLegendMouseOut = function(event) {
      _this.parent.selectAll("path.area").transition("legend-mouseout-area").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-area"
        });
      }).attr("opacity", area$1.opacity.selected);
    };
    return _this;
  }
  Area2.prototype.init = function() {
    var eventsFragment = this.services.events;
    eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  Area2.prototype.render = function(animate) {
    var _this = this;
    if (animate === void 0) {
      animate = true;
    }
    var svg = this.getComponentContainer({ withinChartClip: true });
    var options2 = this.getOptions();
    var domain = [0, 0];
    var cartesianScales = this.services.cartesianScales;
    var orientation = cartesianScales.getOrientation();
    var areaGenerator = area().curve(this.services.curves.getD3Curve()).defined(function(datum2, i) {
      var rangeIdentifier = cartesianScales.getRangeIdentifier();
      var value2 = datum2[rangeIdentifier];
      if (value2 === null || value2 === void 0) {
        return false;
      }
      return true;
    });
    var groupedData = this.model.getGroupedData(this.configs.groups);
    var bounds = Tools.getProperty(options2, "bounds");
    var boundsEnabled = bounds && groupedData && groupedData.length === 1;
    if (!boundsEnabled && bounds) {
      console.warn("Bounds can only be shown when having 1 single datagroup, you've supplied " + groupedData.length);
    }
    var upperBoundRangeValue = 0;
    var includeZeroInRangeValue = function(position, domain2) {
      if (Tools.getProperty(options2, "axes", position, "includeZero") === false) {
        if (domain2[0] > 0 && domain2[1] > 0) {
          upperBoundRangeValue = domain2[0];
        }
      }
    };
    var upperBound = function(d, i) {
      return boundsEnabled ? cartesianScales.getBoundedScaledValues(d, i)[0] : cartesianScales.getRangeValue(upperBoundRangeValue);
    };
    var lowerBound = function(d, i) {
      return boundsEnabled ? cartesianScales.getBoundedScaledValues(d, i)[1] : cartesianScales.getRangeValue(d, i);
    };
    if (orientation === CartesianOrientations.VERTICAL) {
      domain = cartesianScales.getMainYScale().domain();
      includeZeroInRangeValue(cartesianScales.getMainYAxisPosition(), domain);
      areaGenerator.x(function(d, i) {
        return cartesianScales.getDomainValue(d, i);
      }).y0(function(d, i) {
        return upperBound(d, i);
      }).y1(function(d, i) {
        return lowerBound(d, i);
      });
    } else {
      domain = cartesianScales.getMainXScale().domain();
      includeZeroInRangeValue(cartesianScales.getMainXAxisPosition(), domain);
      areaGenerator.x0(function(d, i) {
        return upperBound(d, i);
      }).x1(function(d, i) {
        return lowerBound(d, i);
      }).y(function(d, i) {
        return cartesianScales.getDomainValue(d, i);
      });
    }
    var isGradientEnabled = Tools.getProperty(options2, "color", "gradient", "enabled");
    var isGradientAllowed = groupedData && groupedData.length === 1 && isGradientEnabled;
    if (groupedData.length > 1 && isGradientEnabled) {
      console.error("Gradients can only be enabled when having 1 single dataset");
    }
    var areas = svg.selectAll("path.area").data(groupedData, function(group) {
      return group.name;
    });
    var chartMainContainer = select(this.services.domUtils.getMainContainer());
    areas.exit().attr("opacity", 0).remove();
    if (!groupedData.length) {
      return;
    }
    if (isGradientAllowed) {
      var strokePathElement = chartMainContainer.select("path." + this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.STROKE],
        dataGroupName: groupedData[0].name
      })).node();
      var colorValue = void 0;
      if (strokePathElement) {
        colorValue = getComputedStyle(strokePathElement, null).getPropertyValue("stroke");
      } else {
        var sparklineColorObject = Tools.getProperty(this.model.getOptions(), "color", "scale");
        if (sparklineColorObject !== null) {
          var sparklineColorObjectKeys = Object.keys(sparklineColorObject);
          colorValue = sparklineColorObject[sparklineColorObjectKeys[0]];
        }
      }
      GradientUtils.appendOrUpdateLinearGradient({
        svg: this.parent,
        id: this.services.domUtils.generateElementIDString(groupedData[0].name.replace(" ", "") + "_" + this.gradient_id),
        x1: "0%",
        x2: "0%",
        y1: "0%",
        y2: "100%",
        stops: GradientUtils.getStops(domain, colorValue)
      });
    } else {
      if (!this.parent.selectAll("defs linearGradient").empty()) {
        this.parent.selectAll("defs linearGradient").each(function() {
          this.parentNode.remove();
        });
      }
    }
    var self2 = this;
    var enteringAreas = areas.enter().append("path");
    if (isGradientAllowed) {
      enteringAreas.merge(areas).style("fill", function(group) {
        return "url(#" + _this.services.domUtils.generateElementIDString(group.name.replace(" ", "") + "_" + _this.gradient_id) + ")";
      }).attr("class", "area").attr("class", function(group) {
        return _this.model.getColorClassName({
          classNameTypes: [ColorClassNameTypes.FILL],
          dataGroupName: group.name,
          originalClassName: "area"
        });
      }).attr("d", function(group) {
        var data = group.data;
        return areaGenerator(data);
      });
    } else {
      enteringAreas.attr("opacity", 0).merge(areas).attr("class", "area").attr("class", function(group) {
        return _this.model.getColorClassName({
          classNameTypes: [
            ColorClassNameTypes.FILL,
            ColorClassNameTypes.STROKE
          ],
          dataGroupName: group.name,
          originalClassName: "area"
        });
      }).style("fill", function(group) {
        return self2.model.getFillColor(group.name);
      }).transition().call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "area-update-enter",
          animate
        });
      }).attr("opacity", boundsEnabled ? 1 : area$1.opacity.selected).attr("d", function(group) {
        var data = group.data;
        return areaGenerator(data);
      });
      if (boundsEnabled) {
        enteringAreas.attr("fill-opacity", area$1.opacity.selected).style("stroke", function(group) {
          return self2.model.getStrokeColor(group.name);
        }).style("stroke-dasharray", "2, 2").attr("stroke-width", 0.7 + "px");
      }
    }
  };
  Area2.prototype.destroy = function() {
    var eventsFragment = this.services.events;
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  return Area2;
}(Component);
var __extends$1d = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var StackedArea = function(_super) {
  __extends$1d(StackedArea2, _super);
  function StackedArea2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "area-stacked";
    _this.renderType = RenderTypes.SVG;
    _this.handleLegendOnHover = function(event) {
      var hoveredElement = event.detail.hoveredElement;
      var options2 = _this.getOptions();
      var groupMapsTo = options2.data.groupMapsTo;
      _this.parent.selectAll("path.area").transition("legend-hover-area").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-hover-area"
        });
      }).attr("opacity", function(d) {
        if (Tools.getProperty(d, 0, groupMapsTo) !== hoveredElement.datum().name) {
          return area$1.opacity.unselected;
        }
        return area$1.opacity.selected;
      });
    };
    _this.handleLegendMouseOut = function() {
      _this.parent.selectAll("path.area").transition("legend-mouseout-area").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-area"
        });
      }).attr("opacity", area$1.opacity.selected);
    };
    return _this;
  }
  StackedArea2.prototype.init = function() {
    var eventsFragment = this.services.events;
    eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  StackedArea2.prototype.render = function(animate) {
    var _this = this;
    if (animate === void 0) {
      animate = true;
    }
    var svg = this.getComponentContainer({ withinChartClip: true });
    var self2 = this;
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var percentage = Object.keys(options2.axes).some(function(axis2) {
      return options2.axes[axis2].percentage;
    });
    var stackedData = this.model.getStackedData({
      percentage,
      groups: this.configs.groups
    });
    var firstDatum = Tools.getProperty(stackedData, 0, 0);
    var domainAxisPosition = this.services.cartesianScales.getDomainAxisPosition({ firstDatum });
    var rangeAxisPosition = this.services.cartesianScales.getRangeAxisPosition({ firstDatum });
    var mainYScale = this.services.cartesianScales.getScaleByPosition(rangeAxisPosition);
    var areas = svg.selectAll("path.area").data(stackedData, function(d) {
      return Tools.getProperty(d, 0, groupMapsTo);
    });
    this.areaGenerator = area().x(function(d, i) {
      return _this.services.cartesianScales.getValueThroughAxisPosition(domainAxisPosition, d.data.sharedStackKey, i);
    }).y0(function(d) {
      return mainYScale(d[0]);
    }).y1(function(d) {
      return mainYScale(d[1]);
    }).curve(this.services.curves.getD3Curve());
    areas.exit().attr("opacity", 0).remove();
    var enteringAreas = areas.enter().append("path").attr("opacity", 0);
    enteringAreas.merge(areas).data(stackedData, function(d) {
      return Tools.getProperty(d, 0, groupMapsTo);
    }).attr("class", "area").attr("class", function(d) {
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.FILL],
        dataGroupName: Tools.getProperty(d, 0, groupMapsTo),
        originalClassName: "area"
      });
    }).style("fill", function(d) {
      return self2.model.getFillColor(Tools.getProperty(d, 0, groupMapsTo));
    }).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "area").attr("aria-label", function(d) {
      return Tools.getProperty(d, 0, groupMapsTo);
    }).transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "area-update-enter",
        animate
      });
    }).attr("opacity", area$1.opacity.selected).attr("d", this.areaGenerator);
  };
  return StackedArea2;
}(Component);
var __extends$1c = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Bar = function(_super) {
  __extends$1c(Bar2, _super);
  function Bar2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Bar2.prototype.getBarWidth = function(allDataLabels) {
    var options2 = this.getOptions();
    if (options2.bars.width) {
      return options2.bars.width;
    }
    var numberOfDatapoints = this.model.getDisplayData().length;
    var mainXScale = this.services.cartesianScales.getMainXScale();
    var chartWidth = DOMUtils.getSVGElementSize(this.parent, {
      useAttrs: true
    }).width;
    if (!mainXScale.step) {
      var spacingFactor = Tools.getProperty(options2, "bars", "spacingFactor");
      return Math.min(options2.bars.maxWidth, chartWidth * spacingFactor / numberOfDatapoints);
    }
    return Math.min(options2.bars.maxWidth, mainXScale.step() / 2);
  };
  Bar2.prototype.isOutsideZoomedDomain = function(x0, x1) {
    var dataCount = this.model.getDisplayData().length;
    if (dataCount <= 1) {
      return false;
    }
    var zoomDomain = this.model.get("zoomDomain");
    if (zoomDomain !== void 0) {
      var domainScale = this.services.cartesianScales.getDomainScale();
      return x0 < domainScale(zoomDomain[0]) || x1 > domainScale(zoomDomain[1]);
    }
    return false;
  };
  return Bar2;
}(Component);
var __extends$1b = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SimpleBar = function(_super) {
  __extends$1b(SimpleBar2, _super);
  function SimpleBar2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "simple-bar";
    _this.renderType = RenderTypes.SVG;
    _this.handleLegendOnHover = function(event) {
      var hoveredElement = event.detail.hoveredElement;
      var groupMapsTo = _this.getOptions().data.groupMapsTo;
      _this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-hover-simple-bar"
        });
      }).attr("opacity", function(d) {
        return d[groupMapsTo] !== hoveredElement.datum()["name"] ? 0.3 : 1;
      });
    };
    _this.handleLegendMouseOut = function(event) {
      _this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-simple-bar"
        });
      }).attr("opacity", 1);
    };
    return _this;
  }
  SimpleBar2.prototype.init = function() {
    var eventsFragment = this.services.events;
    eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  SimpleBar2.prototype.render = function(animate) {
    var _this = this;
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var svg = this.getComponentContainer({ withinChartClip: true });
    var data = this.model.getDisplayData(this.configs.groups);
    var orientation = this.services.cartesianScales.getOrientation();
    var bars = svg.selectAll("path.bar").data(data, function(datum2) {
      return datum2[groupMapsTo];
    });
    bars.exit().attr("opacity", 0).remove();
    var barsEnter = bars.enter().append("path").attr("opacity", 0);
    barsEnter.merge(bars).classed("bar", true).attr("width", this.getBarWidth.bind(this)).transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "bar-update-enter",
        animate
      });
    }).attr("class", function(d) {
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.FILL],
        dataGroupName: d[groupMapsTo],
        originalClassName: "bar"
      });
    }).style("fill", function(d) {
      return _this.model.getFillColor(d[groupMapsTo]);
    }).attr("d", function(d, i) {
      var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier();
      var barWidth = _this.getBarWidth();
      var value2 = d[rangeIdentifier];
      var x0 = _this.services.cartesianScales.getDomainValue(d, i) - barWidth / 2;
      var x1 = x0 + barWidth;
      var y0, y1;
      if (Array.isArray(value2) && value2.length === 2) {
        y0 = _this.services.cartesianScales.getRangeValue(value2[0]);
        y1 = _this.services.cartesianScales.getRangeValue(value2[1], i);
      } else {
        var rangeScale = _this.services.cartesianScales.getRangeScale();
        var yScaleDomainStart = rangeScale.domain()[0];
        y0 = _this.services.cartesianScales.getRangeValue(Math.max(0, yScaleDomainStart));
        y1 = _this.services.cartesianScales.getRangeValue(d, i);
      }
      var difference = Math.abs(y1 - y0);
      if (difference !== 0 && difference < 2) {
        if (value2 > 0 && orientation === CartesianOrientations.VERTICAL || value2 < 0 && orientation === CartesianOrientations.HORIZONTAL) {
          y1 = y0 - 2;
        } else {
          y1 = y0 + 2;
        }
      }
      if (_this.isOutsideZoomedDomain(x0, x1)) {
        return;
      }
      return Tools.generateSVGPathString({ x0, x1, y0, y1 }, orientation);
    }).attr("opacity", 1).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", function(d) {
      return d.value;
    });
    this.addEventListeners();
  };
  SimpleBar2.prototype.addEventListeners = function() {
    var self2 = this;
    this.parent.selectAll("path.bar").on("mouseover", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", true);
      self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEOVER, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
        event,
        hoveredElement,
        data: [datum2]
      });
    }).on("mousemove", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEMOVE, {
        event,
        element: select(this),
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("click", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Bar.BAR_CLICK, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mouseout", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", false);
      self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEOUT, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
        hoveredElement
      });
    });
  };
  SimpleBar2.prototype.destroy = function() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    var eventsFragment = this.services.events;
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  return SimpleBar2;
}(Bar);
var __extends$1a = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var GroupedBar = function(_super) {
  __extends$1a(GroupedBar2, _super);
  function GroupedBar2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "grouped-bar";
    _this.renderType = RenderTypes.SVG;
    _this.padding = 5;
    _this.handleLegendOnHover = function(event) {
      var hoveredElement = event.detail.hoveredElement;
      var groupMapsTo = _this.getOptions().data.groupMapsTo;
      _this.parent.selectAll("path.bar").transition("legend-hover-bar").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-hover-bar"
        });
      }).attr("opacity", function(d) {
        return d[groupMapsTo] !== hoveredElement.datum()["name"] ? 0.3 : 1;
      });
    };
    _this.handleLegendMouseOut = function(event) {
      _this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        });
      }).attr("opacity", 1);
    };
    return _this;
  }
  GroupedBar2.prototype.init = function() {
    var eventsFragment = this.services.events;
    eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  GroupedBar2.prototype.render = function(animate) {
    var _this = this;
    var displayData = this.model.getDisplayData(this.configs.groups);
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    this.setGroupScale();
    var svg = this.getComponentContainer({ withinChartClip: true });
    var allDataLabels = Tools.removeArrayDuplicates(displayData.map(function(datum2) {
      var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(datum2);
      return datum2[domainIdentifier] && typeof datum2[domainIdentifier].toString === "function" ? datum2[domainIdentifier].toString() : datum2[domainIdentifier];
    }));
    var barGroups = svg.selectAll("g.bars").data(allDataLabels, function(label) {
      return label;
    });
    barGroups.exit().attr("opacity", 0).remove();
    var barGroupsEnter = barGroups.enter().append("g").classed("bars", true).attr("role", Roles.GROUP).attr("data-name", "bars");
    var allBarGroups = barGroupsEnter.merge(barGroups);
    allBarGroups.transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "bar-group-update-enter",
        animate
      });
    }).attr("transform", function(label, i) {
      var scaleValue = _this.services.cartesianScales.getDomainValue(label, i);
      var translateBy = scaleValue - _this.getGroupWidth() / 2;
      if (_this.services.cartesianScales.getOrientation() === CartesianOrientations.VERTICAL) {
        return "translate(" + translateBy + ", 0)";
      } else {
        return "translate(0, " + translateBy + ")";
      }
    });
    var bars = allBarGroups.selectAll("path.bar").data(function(label) {
      return _this.getDataCorrespondingToLabel(label);
    }, function(d) {
      return d[groupMapsTo];
    });
    bars.exit().attr("opacity", 0).remove();
    var barsEnter = bars.enter().append("path").attr("opacity", 0);
    barsEnter.merge(bars).classed("bar", true).transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "bar-update-enter",
        animate
      });
    }).attr("class", function(d) {
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.FILL],
        dataGroupName: d[groupMapsTo],
        originalClassName: "bar"
      });
    }).style("fill", function(d) {
      return _this.model.getFillColor(d[groupMapsTo]);
    }).attr("d", function(d) {
      var startX = _this.groupScale(d[groupMapsTo]);
      var barWidth = _this.getBarWidth();
      var x0 = startX;
      var x1 = startX + barWidth;
      var rangeAxis = _this.services.cartesianScales.getRangeAxisPosition({ datum: d });
      var y0 = _this.services.cartesianScales.getValueThroughAxisPosition(rangeAxis, 0);
      var y1 = _this.services.cartesianScales.getRangeValue(d);
      if (_this.isOutsideZoomedDomain(x0, x1)) {
        return;
      }
      return Tools.generateSVGPathString({ x0, x1, y0, y1 }, _this.services.cartesianScales.getOrientation());
    }).attr("opacity", 1).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", function(d) {
      return d.value;
    });
    this.addEventListeners();
  };
  GroupedBar2.prototype.addEventListeners = function() {
    var self2 = this;
    this.parent.selectAll("path.bar").on("mouseover", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", true);
      self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEOVER, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
        event,
        hoveredElement,
        data: [datum2]
      });
    }).on("mousemove", function(event, datum2) {
      var hoveredElement = select(this);
      self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEMOVE, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("click", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Bar.BAR_CLICK, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mouseout", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", false);
      self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEOUT, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
        hoveredElement
      });
    });
  };
  GroupedBar2.prototype.destroy = function() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    var eventsFragment = this.services.events;
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  GroupedBar2.prototype.getDataCorrespondingToLabel = function(label) {
    var _this = this;
    var displayData = this.model.getDisplayData(this.configs.groups);
    return displayData.filter(function(datum2) {
      var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(datum2);
      return datum2[domainIdentifier] === label;
    });
  };
  GroupedBar2.prototype.getGroupWidth = function() {
    var activeData = this.model.getGroupedData(this.configs.groups);
    var totalGroupPadding = this.getTotalGroupPadding();
    return this.getBarWidth() * activeData.length + totalGroupPadding;
  };
  GroupedBar2.prototype.getTotalGroupPadding = function() {
    var activeData = this.model.getGroupedData(this.configs.groups);
    if (activeData.length === 1) {
      return 0;
    }
    var domainScale = this.services.cartesianScales.getDomainScale();
    var padding = Math.min(5, 5 * (domainScale.step() / 70));
    return padding * (activeData.length - 1);
  };
  GroupedBar2.prototype.getBarWidth = function() {
    var options2 = this.getOptions();
    var providedWidth = Tools.getProperty(options2, "bars", "width");
    var providedMaxWidth = Tools.getProperty(options2, "bars", "maxWidth");
    if (providedWidth !== null) {
      if (providedMaxWidth === null || providedWidth <= providedMaxWidth) {
        return providedWidth;
      }
    }
    var activeData = this.model.getGroupedData(this.configs.groups);
    var numOfActiveDataGroups = activeData.length;
    var totalGroupPadding = this.getTotalGroupPadding();
    var domainScale = this.services.cartesianScales.getDomainScale();
    return Math.min(providedMaxWidth, (domainScale.step() - totalGroupPadding) / numOfActiveDataGroups);
  };
  GroupedBar2.prototype.setGroupScale = function() {
    var activeData = this.model.getActiveDataGroupNames(this.configs.groups);
    this.groupScale = band().domain(activeData).rangeRound([0, this.getGroupWidth()]);
  };
  return GroupedBar2;
}(Bar);
var __extends$19 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var StackedBar = function(_super) {
  __extends$19(StackedBar2, _super);
  function StackedBar2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "stacked-bar";
    _this.renderType = RenderTypes.SVG;
    _this.handleLegendOnHover = function(event) {
      var hoveredElement = event.detail.hoveredElement;
      var groupMapsTo = _this.model.getOptions().data.groupMapsTo;
      _this.parent.selectAll("path.bar").transition("legend-hover-bar").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-hover-bar"
        });
      }).attr("opacity", function(d) {
        return d[groupMapsTo] !== hoveredElement.datum()["name"] ? 0.3 : 1;
      });
    };
    _this.handleLegendMouseOut = function(event) {
      _this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        });
      }).attr("opacity", 1);
    };
    return _this;
  }
  StackedBar2.prototype.init = function() {
    var eventsFragment = this.services.events;
    eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  StackedBar2.prototype.render = function(animate) {
    var _this = this;
    var svg = this.getComponentContainer({ withinChartClip: true });
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var stackData = this.model.getStackedData({
      groups: this.configs.groups,
      divergent: true
    });
    var activeDataGroupNames = this.model.getActiveDataGroupNames();
    var barGroups = svg.selectAll("g.bars").data(stackData, function(d) {
      return Tools.getProperty(d, 0, groupMapsTo);
    });
    barGroups.exit().attr("opacity", 0).remove();
    barGroups.enter().append("g").classed("bars", true).attr("role", Roles.GROUP).attr("data-name", "bars");
    var bars = svg.selectAll("g.bars").selectAll("path.bar").data(function(d) {
      return d;
    }, function(d) {
      return d.data.sharedStackKey;
    });
    bars.exit().remove();
    bars.enter().append("path").merge(bars).classed("bar", true).transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "bar-update-enter",
        animate
      });
    }).attr("class", function(d) {
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.FILL],
        dataGroupName: d[groupMapsTo],
        originalClassName: "bar"
      });
    }).style("fill", function(d) {
      return _this.model.getFillColor(d[groupMapsTo]);
    }).attr("d", function(d, i) {
      var key = d.data.sharedStackKey;
      var barWidth = _this.getBarWidth();
      var x0 = _this.services.cartesianScales.getDomainValue(key, i) - barWidth / 2;
      var x1 = x0 + barWidth;
      var y0 = _this.services.cartesianScales.getRangeValue(d[0], i);
      var y1 = _this.services.cartesianScales.getRangeValue(d[1], i);
      if (_this.isOutsideZoomedDomain(x0, x1)) {
        return;
      }
      if (Math.abs(y1 - y0) > 0 && Math.abs(y1 - y0) > options2.bars.dividerSize) {
        var barIsNegative = d[0] < 0 && d[1] <= 0;
        if (barIsNegative && activeDataGroupNames.length > 1) {
          if (_this.services.cartesianScales.getOrientation() === CartesianOrientations.VERTICAL) {
            y1 += d[1] === 0 ? 2 : 1;
          } else {
            y1 -= 1;
          }
        } else if (!barIsNegative) {
          if (_this.services.cartesianScales.getOrientation() === CartesianOrientations.VERTICAL) {
            y1 += 1;
          } else {
            y1 -= 1;
          }
        }
      }
      return Tools.generateSVGPathString({ x0, x1, y0, y1 }, _this.services.cartesianScales.getOrientation());
    }).attr("opacity", 1).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", function(d) {
      return d[1] - d[0];
    });
    this.addEventListeners();
  };
  StackedBar2.prototype.addEventListeners = function() {
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var self2 = this;
    this.parent.selectAll("path.bar").on("mouseover", function(event, datum2) {
      var _a2;
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", true);
      self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEOVER, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      var displayData = self2.model.getDisplayData(self2.configs.groups);
      var matchingDataPoint = displayData.find(function(d) {
        var domainIdentifier2 = self2.services.cartesianScales.getDomainIdentifier(d);
        var rangeIdentifier2 = self2.services.cartesianScales.getRangeIdentifier(d);
        return d[rangeIdentifier2] === datum2.data[datum2[groupMapsTo]] && d[domainIdentifier2].toString() === datum2.data.sharedStackKey && d[groupMapsTo] === datum2[groupMapsTo];
      });
      if (matchingDataPoint === void 0) {
        var domainIdentifier = self2.services.cartesianScales.getDomainIdentifier();
        var rangeIdentifier = self2.services.cartesianScales.getRangeIdentifier();
        matchingDataPoint = (_a2 = {}, _a2[domainIdentifier] = datum2.data.sharedStackKey, _a2[rangeIdentifier] = datum2.data[datum2[groupMapsTo]], _a2[groupMapsTo] = datum2[groupMapsTo], _a2);
      }
      self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
        event,
        hoveredElement,
        data: [matchingDataPoint]
      });
    }).on("mousemove", function(event, datum2) {
      var hoveredElement = select(this);
      self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEMOVE, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("click", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Bar.BAR_CLICK, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mouseout", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", false);
      self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEOUT, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
        hoveredElement
      });
    });
  };
  StackedBar2.prototype.getBarWidth = function() {
    var options2 = this.getOptions();
    if (Tools.getProperty(options2, "bars", "width")) {
      return options2.bars.width;
    }
    var mainXScale = this.services.cartesianScales.getMainXScale();
    var chartWidth = DOMUtils.getSVGElementSize(this.parent, {
      useAttrs: true
    }).width;
    var numberOfDomainValues = this.model.getStackKeys().length;
    var spacingFactor = Tools.getProperty(options2, "bars", "spacingFactor");
    if (!mainXScale.step) {
      return Math.min(options2.bars.maxWidth, chartWidth * spacingFactor / numberOfDomainValues);
    }
    return Math.min(options2.bars.maxWidth, mainXScale.step() / 2);
  };
  StackedBar2.prototype.destroy = function() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    var eventsFragment = this.services.events;
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  return StackedBar2;
}(Bar);
var __extends$18 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Boxplot = function(_super) {
  __extends$18(Boxplot2, _super);
  function Boxplot2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "boxplot";
    _this.renderType = RenderTypes.SVG;
    return _this;
  }
  Boxplot2.prototype.render = function(animate) {
    var _this = this;
    var svg = this.getComponentContainer({ withinChartClip: true });
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var dataGroupNames = this.model.getDataGroupNames();
    var mainXScale = this.services.cartesianScales.getMainXScale();
    var mainYScale = this.services.cartesianScales.getMainYScale();
    var _a2 = mainXScale.range(), xScaleStart = _a2[0], xScaleEnd = _a2[1];
    var _b = mainYScale.range(), yScaleEnd = _b[0], yScaleStart = _b[1];
    var width = xScaleEnd - xScaleStart;
    var height = yScaleEnd - yScaleStart;
    if (width === 0) {
      return;
    }
    var cartesianScales = this.services.cartesianScales;
    var orientation = cartesianScales.getOrientation();
    var isInVerticalOrientation = orientation === CartesianOrientations.VERTICAL;
    var _c = Tools.flipDomainAndRangeBasedOnOrientation(function(d, i) {
      return _this.services.cartesianScales.getDomainValue(d, i);
    }, function(d, i) {
      return _this.services.cartesianScales.getRangeValue(d, i);
    }, orientation), getXValue = _c[0], getYValue = _c[1];
    var gridSize = Math.floor((isInVerticalOrientation ? width : height) / dataGroupNames.length);
    var boxWidth = Math.min(gridSize / 2, 16);
    var boxplotData = this.model.getBoxplotData();
    var boxGroups = svg.selectAll(".box-group").data(boxplotData);
    boxGroups.exit().remove();
    var boxGroupsEnter = boxGroups.enter().append("g").attr("class", "box-group");
    var allBoxGroups = boxGroups.merge(boxGroupsEnter);
    boxGroupsEnter.append("path").merge(boxGroups.select("path.vertical-line.start")).attr("class", function() {
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.STROKE],
        originalClassName: "vertical-line start"
      });
    }).attr("stroke-width", boxplot.strokeWidth.default).attr("fill", "none").transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "boxplot-update-verticalstartline",
        animate
      });
    }).attr("d", function(d) {
      var x0 = cartesianScales.getDomainValue(d[groupMapsTo]);
      var x1 = x0;
      var y0 = cartesianScales.getRangeValue(d.whiskers.min);
      var y1 = cartesianScales.getRangeValue(d.quartiles.q_25);
      return Tools.generateSVGPathString({ x0, x1, y0, y1 }, orientation);
    });
    boxGroupsEnter.append("path").merge(boxGroups.select("path.vertical-line.end")).attr("class", function() {
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.STROKE],
        originalClassName: "vertical-line end"
      });
    }).attr("stroke-width", boxplot.strokeWidth.default).attr("fill", "none").transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "boxplot-update-verticalendline",
        animate
      });
    }).attr("d", function(d) {
      var x0 = cartesianScales.getDomainValue(d[groupMapsTo]);
      var x1 = x0;
      var y0 = cartesianScales.getRangeValue(d.whiskers.max);
      var y1 = cartesianScales.getRangeValue(d.quartiles.q_75);
      return Tools.generateSVGPathString({ x0, x1, y0, y1 }, orientation);
    });
    boxGroupsEnter.append("path").merge(boxGroups.select("path.box")).attr("class", function() {
      return _this.model.getColorClassName({
        classNameTypes: [
          ColorClassNameTypes.FILL,
          ColorClassNameTypes.STROKE
        ],
        originalClassName: "box"
      });
    }).attr("fill-opacity", boxplot.box.opacity.default).attr("stroke-width", boxplot.strokeWidth.default).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "box").attr("aria-label", function(d) {
      return d[groupMapsTo];
    }).transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "boxplot-update-quartiles",
        animate
      });
    }).attr("d", function(d) {
      var x0 = cartesianScales.getDomainValue(d[groupMapsTo]) - boxWidth / 2;
      var x1 = x0 + boxWidth;
      var y0 = cartesianScales.getRangeValue(Math[isInVerticalOrientation ? "max" : "min"](d.quartiles.q_75, d.quartiles.q_25));
      var y1 = y0 + Math.abs(cartesianScales.getRangeValue(d.quartiles.q_75) - cartesianScales.getRangeValue(d.quartiles.q_25));
      return Tools.generateSVGPathString({ x0, x1, y0, y1 }, orientation);
    });
    boxGroupsEnter.append("path").merge(boxGroups.select("path.highlight-area")).attr("class", "highlight-area").attr("opacity", 0).attr("d", function(d) {
      var x0 = cartesianScales.getDomainValue(d[groupMapsTo]) - boxWidth / 2;
      var x1 = x0 + boxWidth;
      var y0 = cartesianScales.getRangeValue(d.whiskers.min);
      var y1 = cartesianScales.getRangeValue(d.whiskers.max);
      return Tools.generateSVGPathString({ x0, x1, y0, y1 }, orientation);
    });
    boxGroupsEnter.append("path").merge(boxGroups.select("path.whisker.start")).attr("class", function() {
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.STROKE],
        originalClassName: "whisker start"
      });
    }).attr("stroke-width", boxplot.strokeWidth.thicker).attr("fill", "none").transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "boxplot-update-startingwhisker",
        animate
      });
    }).attr("d", function(d) {
      var x0 = cartesianScales.getDomainValue(d[groupMapsTo]) - boxWidth / 4;
      var x1 = x0 + boxWidth / 2;
      var y0 = cartesianScales.getRangeValue(d.whiskers.min);
      var y1 = cartesianScales.getRangeValue(d.whiskers.min);
      return Tools.generateSVGPathString({ x0, x1, y0, y1 }, orientation);
    });
    boxGroupsEnter.append("path").merge(boxGroups.select("path.median")).attr("fill", "none").attr("class", function() {
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.STROKE],
        originalClassName: "median"
      });
    }).attr("stroke-width", 2).transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "boxplot-update-median",
        animate
      });
    }).attr("d", function(d) {
      var x0 = cartesianScales.getDomainValue(d[groupMapsTo]) - boxWidth / 2;
      var x1 = x0 + boxWidth;
      var y0 = cartesianScales.getRangeValue(d.quartiles.q_50);
      var y1 = y0;
      return Tools.generateSVGPathString({ x0, x1, y0, y1 }, orientation);
    });
    boxGroupsEnter.append("path").merge(boxGroups.select("path.whisker.end")).attr("class", function() {
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.STROKE],
        originalClassName: "whisker end"
      });
    }).attr("stroke-width", boxplot.strokeWidth.thicker).attr("fill", "none").transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "boxplot-update-endingwhisker",
        animate
      });
    }).attr("d", function(d) {
      var x0 = cartesianScales.getDomainValue(d[groupMapsTo]) - boxWidth / 4;
      var x1 = x0 + boxWidth / 2;
      var y0 = cartesianScales.getRangeValue(d.whiskers.max);
      var y1 = cartesianScales.getRangeValue(d.whiskers.max);
      return Tools.generateSVGPathString({ x0, x1, y0, y1 }, orientation);
    });
    var circles = allBoxGroups.selectAll("circle.outlier").data(function(d) {
      return d.outliers.map(function(outlier) {
        var _a3;
        return _a3 = {
          min: d.whiskers.min,
          max: d.whiskers.max
        }, _a3[groupMapsTo] = d[groupMapsTo], _a3.value = outlier, _a3;
      });
    });
    circles.exit().remove();
    var circlesEnter = circles.enter().append("circle");
    circles.merge(circlesEnter).attr("r", boxplot.circle.radius).attr("class", function() {
      return _this.model.getColorClassName({
        classNameTypes: [
          ColorClassNameTypes.FILL,
          ColorClassNameTypes.STROKE
        ],
        originalClassName: "outlier"
      });
    }).attr("fill-opacity", boxplot.circle.opacity.default).attr("cx", getXValue).transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "boxplot-update-circles",
        animate
      });
    }).attr("cy", getYValue);
    this.addBoxEventListeners();
    this.addCircleEventListeners();
  };
  Boxplot2.prototype.addBoxEventListeners = function() {
    var self2 = this;
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    this.parent.selectAll("path.highlight-area").on("mouseover", function(event, datum2) {
      var hoveredElement = select(this);
      var parentElement = select(this.parentNode);
      parentElement.select("path.box").classed("hovered", true).attr("fill-opacity", boxplot.box.opacity.hovered);
      self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
        event,
        hoveredElement,
        items: [
          {
            label: options2.tooltip.groupLabel,
            value: datum2[groupMapsTo],
            class: self2.model.getColorClassName({
              classNameTypes: [ColorClassNameTypes.TOOLTIP]
            })
          },
          {
            label: "Minimum",
            value: datum2.whiskers.min
          },
          {
            label: "Q1",
            value: datum2.quartiles.q_25
          },
          {
            label: "Median",
            value: datum2.quartiles.q_50
          },
          {
            label: "Q3",
            value: datum2.quartiles.q_75
          },
          {
            label: "Maximum",
            value: datum2.whiskers.max
          },
          {
            label: "IQR",
            value: datum2.quartiles.q_75 - datum2.quartiles.q_25
          }
        ]
      });
      self2.services.events.dispatchEvent(Events$1.Boxplot.BOX_MOUSEOVER, {
        event,
        element: hoveredElement,
        datum: datum2
      });
    }).on("mousemove", function(event, datum2) {
      var hoveredElement = select(this);
      self2.services.events.dispatchEvent(Events$1.Boxplot.BOX_MOUSEMOVE, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("click", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Boxplot.BOX_CLICK, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mouseout", function(event, datum2) {
      var hoveredElement = select(this);
      var parentElement = select(this.parentNode);
      parentElement.select("path.box").classed("hovered", false).attr("fill-opacity", boxplot.box.opacity.default);
      self2.services.events.dispatchEvent(Events$1.Boxplot.BOX_MOUSEOUT, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
        hoveredElement
      });
    });
  };
  Boxplot2.prototype.addCircleEventListeners = function() {
    var self2 = this;
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var rangeIdentifier = this.services.cartesianScales.getRangeIdentifier();
    this.parent.selectAll("circle").on("mouseover", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", true).attr("fill-opacity", boxplot.circle.opacity.hovered).classed("unfilled", false);
      self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
        event,
        hoveredElement,
        items: [
          {
            label: options2.tooltip.groupLabel,
            value: datum2[groupMapsTo],
            class: self2.model.getColorClassName({
              classNameTypes: [ColorClassNameTypes.TOOLTIP]
            })
          },
          {
            label: "Outlier",
            value: datum2[rangeIdentifier]
          }
        ]
      });
      self2.services.events.dispatchEvent(Events$1.Boxplot.OUTLIER_MOUSEOVER, {
        event,
        element: hoveredElement,
        datum: datum2
      });
    }).on("mousemove", function(event, datum2) {
      var hoveredElement = select(this);
      self2.services.events.dispatchEvent(Events$1.Boxplot.OUTLIER_MOUSEMOVE, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("click", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Boxplot.OUTLIER_CLICK, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mouseout", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", false).attr("fill-opacity", boxplot.circle.opacity.default);
      self2.services.events.dispatchEvent(Events$1.Boxplot.OUTLIER_MOUSEOUT, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
        hoveredElement
      });
    });
  };
  return Boxplot2;
}(Component);
var __extends$17 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Scatter = function(_super) {
  __extends$17(Scatter2, _super);
  function Scatter2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "scatter";
    _this.renderType = RenderTypes.SVG;
    _this.handleChartHolderOnHover = function(event) {
      _this.parent.selectAll("circle.dot").transition("chart-holder-hover-scatter").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "chart-holder-hover-scatter"
        });
      }).attr("opacity", 1);
    };
    _this.handleChartHolderOnMouseOut = function(event) {
      _this.parent.selectAll("circle.dot").transition("chart-holder-mouseout-scatter").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "chart-holder-mouseout-scatter"
        });
      }).attr("opacity", 0);
    };
    _this.handleLegendOnHover = function(event) {
      var hoveredElement = event.detail.hoveredElement;
      var groupMapsTo = _this.getOptions().data.groupMapsTo;
      _this.parent.selectAll("circle.dot").transition("legend-hover-scatter").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-hover-scatter"
        });
      }).attr("opacity", function(d) {
        return d[groupMapsTo] !== hoveredElement.datum()["name"] ? 0.3 : 1;
      });
    };
    _this.handleLegendMouseOut = function(event) {
      _this.parent.selectAll("circle.dot").transition("legend-mouseout-scatter").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-scatter"
        });
      }).attr("opacity", 1);
    };
    return _this;
  }
  Scatter2.prototype.init = function() {
    var events = this.services.events;
    events.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    events.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
    var fadeInOnChartHolderMouseover = this.configs.fadeInOnChartHolderMouseover;
    if (fadeInOnChartHolderMouseover) {
      events.addEventListener(Events$1.Chart.MOUSEOVER, this.handleChartHolderOnHover);
      events.addEventListener(Events$1.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut);
    }
  };
  Scatter2.prototype.filterBasedOnZoomDomain = function(data) {
    var domainIdentifier = this.services.cartesianScales.getDomainIdentifier(data);
    var zoomDomain = this.model.get("zoomDomain");
    if (zoomDomain !== void 0) {
      return data.filter(function(d) {
        return d[domainIdentifier].getTime() >= zoomDomain[0].getTime() && d[domainIdentifier].getTime() <= zoomDomain[1].getTime();
      });
    }
    return data;
  };
  Scatter2.prototype.getScatterData = function() {
    var _this = this;
    var options2 = this.getOptions();
    var stacked = this.configs.stacked;
    var scatterData;
    if (stacked) {
      var percentage = Object.keys(options2.axes).some(function(axis2) {
        return options2.axes[axis2].percentage;
      });
      scatterData = this.model.getStackedData({
        groups: this.configs.groups,
        percentage
      });
    } else {
      scatterData = this.model.getDisplayData(this.configs.groups).filter(function(d) {
        var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(d);
        return d[rangeIdentifier] !== void 0 && d[rangeIdentifier] !== null;
      });
    }
    return this.filterBasedOnZoomDomain(scatterData);
  };
  Scatter2.prototype.render = function(animate) {
    var isScatterEnabled = Tools.getProperty(this.getOptions(), "points", "enabled") || Tools.getProperty(this.getOptions(), "bubble", "enabled");
    if (!isScatterEnabled) {
      return;
    }
    var svg = this.getComponentContainer({ withinChartClip: true });
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var domainIdentifier = this.services.cartesianScales.getDomainIdentifier();
    var circles = svg.selectAll("circle.dot").data(this.getScatterData(), function(datum2) {
      return datum2[groupMapsTo] + "-" + datum2[domainIdentifier];
    });
    circles.exit().attr("opacity", 0).remove();
    var enteringCircles = circles.enter().append("circle").classed("dot", true).attr("opacity", 0);
    var circlesToStyle = enteringCircles.merge(circles);
    this.styleCircles(circlesToStyle, animate);
    this.addEventListeners();
  };
  Scatter2.prototype.isDatapointThresholdAnomaly = function(datum2, index2) {
    var _this = this;
    var handleThresholds = this.configs.handleThresholds;
    if (!handleThresholds) {
      return false;
    }
    var cartesianScales = this.services.cartesianScales;
    var orientation = cartesianScales.getOrientation();
    var _a2 = Tools.flipDomainAndRangeBasedOnOrientation(this.services.cartesianScales.getHighestDomainThreshold(), this.services.cartesianScales.getHighestRangeThreshold(), orientation), xThreshold = _a2[0], yThreshold = _a2[1];
    var _b = Tools.flipDomainAndRangeBasedOnOrientation(function(d, i) {
      return _this.services.cartesianScales.getDomainValue(d, i);
    }, function(d, i) {
      return _this.services.cartesianScales.getRangeValue(d, i);
    }, orientation), getXValue = _b[0], getYValue = _b[1];
    var xValue = getXValue(datum2, index2);
    var yValue = getYValue(datum2, index2);
    if (yThreshold && xThreshold) {
      return yValue <= yThreshold.scaleValue && xValue >= xThreshold.scaleValue;
    }
    if (yThreshold) {
      return yValue <= yThreshold.scaleValue;
    }
    if (xThreshold) {
      return xValue >= xThreshold.scaleValue;
    }
  };
  Scatter2.prototype.styleCircles = function(selection2, animate) {
    var _this = this;
    var options2 = this.getOptions();
    var _a2 = options2.points, filled = _a2.filled, fillOpacity = _a2.fillOpacity;
    var _b = this.services, cartesianScales = _b.cartesianScales;
    _b.transitions;
    var groupMapsTo = options2.data.groupMapsTo;
    var getDomainValue = function(d, i) {
      return cartesianScales.getDomainValue(d, i);
    };
    var getRangeValue = function(d, i) {
      return cartesianScales.getRangeValue(d, i);
    };
    var _c = Tools.flipDomainAndRangeBasedOnOrientation(getDomainValue, getRangeValue, cartesianScales.getOrientation()), getXValue = _c[0], getYValue = _c[1];
    var fadeInOnChartHolderMouseover = this.configs.fadeInOnChartHolderMouseover;
    selection2.raise().classed("dot", true).attr("class", function(d) {
      var domainIdentifier = cartesianScales.getDomainIdentifier(d);
      var isFilled = _this.model.getIsFilled(d[groupMapsTo], d[domainIdentifier], d, filled);
      var classNamesNeeded = isFilled ? [ColorClassNameTypes.FILL, ColorClassNameTypes.STROKE] : [ColorClassNameTypes.STROKE];
      return _this.model.getColorClassName({
        classNameTypes: classNamesNeeded,
        dataGroupName: d[groupMapsTo],
        originalClassName: "dot"
      });
    }).classed("threshold-anomaly", function(d, i) {
      return _this.isDatapointThresholdAnomaly(d, i);
    }).classed("filled", function(d) {
      var domainIdentifier = cartesianScales.getDomainIdentifier(d);
      return _this.model.getIsFilled(d[groupMapsTo], d[domainIdentifier], d, filled);
    }).classed("unfilled", function(d) {
      var domainIdentifier = cartesianScales.getDomainIdentifier(d);
      return !_this.model.getIsFilled(d[groupMapsTo], d[domainIdentifier], d, filled);
    }).transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "scatter-update-enter",
        animate
      });
    }).attr("cx", getXValue).attr("cy", getYValue).attr("r", options2.points.radius).style("fill", function(d) {
      var domainIdentifier = cartesianScales.getDomainIdentifier(d);
      if (_this.model.getIsFilled(d[groupMapsTo], d[domainIdentifier], d, filled)) {
        return _this.model.getFillColor(d[groupMapsTo], d[domainIdentifier], d);
      }
    }).style("stroke", function(d) {
      var domainIdentifier = cartesianScales.getDomainIdentifier(d);
      return _this.model.getStrokeColor(d[groupMapsTo], d[domainIdentifier], d);
    }).attr("fill-opacity", filled ? fillOpacity : 1).attr("opacity", fadeInOnChartHolderMouseover ? 0 : 1).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "point").attr("aria-label", function(d) {
      var rangeIdentifier = cartesianScales.getRangeIdentifier(d);
      return d[rangeIdentifier];
    });
    this.addEventListeners();
  };
  Scatter2.prototype.getTooltipAdditionalItems = function(datum2) {
    return null;
  };
  Scatter2.prototype.addEventListeners = function() {
    var self2 = this;
    var groupMapsTo = self2.getOptions().data.groupMapsTo;
    this.parent.selectAll("circle").on("mouseover", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", true).attr("class", function(d) {
        return self2.model.getColorClassName({
          classNameTypes: [ColorClassNameTypes.FILL],
          dataGroupName: d[groupMapsTo],
          originalClassName: hoveredElement.attr("class")
        });
      }).style("fill", function(d) {
        var domainIdentifier = self2.services.cartesianScales.getDomainIdentifier(d);
        return self2.model.getFillColor(d[groupMapsTo], d[domainIdentifier], d);
      }).classed("unfilled", false);
      self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
        event,
        hoveredElement,
        data: [datum2],
        additionalItems: self2.getTooltipAdditionalItems(datum2)
      });
      self2.services.events.dispatchEvent(Events$1.Scatter.SCATTER_MOUSEOVER, {
        event,
        element: hoveredElement,
        datum: datum2
      });
    }).on("mousemove", function(event, datum2) {
      var hoveredElement = select(this);
      self2.services.events.dispatchEvent(Events$1.Scatter.SCATTER_MOUSEMOVE, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("click", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Scatter.SCATTER_CLICK, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mouseout", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", false);
      if (!self2.configs.filled) {
        var filled_1 = self2.getOptions().points.filled;
        var domainIdentifier_1 = self2.services.cartesianScales.getDomainIdentifier(datum2);
        var isFilled_1 = self2.model.getIsFilled(datum2[groupMapsTo], datum2[domainIdentifier_1], datum2, filled_1);
        hoveredElement.classed("unfilled", !isFilled_1).style("fill", function(d) {
          if (isFilled_1 || filled_1) {
            return self2.model.getFillColor(d[groupMapsTo], d[domainIdentifier_1], d);
          }
          return null;
        });
      }
      self2.services.events.dispatchEvent(Events$1.Scatter.SCATTER_MOUSEOUT, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
        hoveredElement
      });
    });
  };
  Scatter2.prototype.destroy = function() {
    this.parent.selectAll("circle").on("mousemove", null).on("mouseout", null);
    var events = this.services.events;
    events.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    events.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
    events.removeEventListener(Events$1.Chart.MOUSEOVER, this.handleChartHolderOnHover);
    events.removeEventListener(Events$1.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut);
  };
  return Scatter2;
}(Component);
var __extends$16 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Bubble = function(_super) {
  __extends$16(Bubble2, _super);
  function Bubble2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "bubble";
    _this.renderType = RenderTypes.SVG;
    return _this;
  }
  Bubble2.prototype.getRadiusScale = function(selection2) {
    var options2 = this.getOptions();
    var radiusMapsTo = options2.bubble.radiusMapsTo;
    var data = selection2.data();
    var allRadii = data.map(function(d) {
      return d[radiusMapsTo];
    }).filter(function(radius) {
      return radius;
    });
    var chartSize = DOMUtils.getHTMLElementSize(this.services.domUtils.getMainContainer());
    var radiusDataIsValid = allRadii.length > 0;
    var domain = radiusDataIsValid ? extent(allRadii) : [1, 1];
    return linear().domain(domain).range(radiusDataIsValid ? options2.bubble.radiusRange(chartSize, data) : [4, 4]);
  };
  Bubble2.prototype.styleCircles = function(selection2, animate) {
    var _this = this;
    var options2 = this.getOptions();
    var radiusMapsTo = options2.bubble.radiusMapsTo;
    var radiusScale = this.getRadiusScale(selection2);
    var groupMapsTo = options2.data.groupMapsTo;
    var cartesianScales = this.services.cartesianScales;
    var getDomainValue = function(d, i) {
      return cartesianScales.getDomainValue(d, i);
    };
    var getRangeValue = function(d, i) {
      return cartesianScales.getRangeValue(d, i);
    };
    var _a2 = Tools.flipDomainAndRangeBasedOnOrientation(getDomainValue, getRangeValue, cartesianScales.getOrientation()), getXValue = _a2[0], getYValue = _a2[1];
    selection2.raise().classed("dot", true).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-label", function(d) {
      var rangeIdentifier = cartesianScales.getRangeIdentifier(d);
      return d[rangeIdentifier];
    }).transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "bubble-update-enter",
        animate
      });
    }).attr("cx", getXValue).attr("cy", getYValue).attr("r", function(d) {
      return radiusScale(d[radiusMapsTo] || 1);
    }).attr("class", function(d) {
      return _this.model.getColorClassName({
        classNameTypes: [
          ColorClassNameTypes.FILL,
          ColorClassNameTypes.STROKE
        ],
        dataGroupName: d[groupMapsTo],
        originalClassName: "dot"
      });
    }).style("fill", function(d) {
      var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(d);
      return _this.model.getFillColor(d[groupMapsTo], d[domainIdentifier], d);
    }).style("stroke", function(d) {
      var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(d);
      return _this.model.getStrokeColor(d[groupMapsTo], d[domainIdentifier], d);
    }).attr("fill-opacity", options2.bubble.fillOpacity).attr("opacity", 1);
  };
  Bubble2.prototype.getTooltipAdditionalItems = function(datum2) {
    var bubbleOptions = Tools.getProperty(this.getOptions(), "bubble");
    return [
      {
        label: Tools.getProperty(bubbleOptions, "radiusLabel"),
        value: datum2[Tools.getProperty(bubbleOptions, "radiusMapsTo")]
      }
    ];
  };
  return Bubble2;
}(Scatter);
var __extends$15 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Bullet = function(_super) {
  __extends$15(Bullet2, _super);
  function Bullet2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "bullet";
    _this.renderType = RenderTypes.SVG;
    _this.handleLegendOnHover = function(event) {
      var hoveredElement = event.detail.hoveredElement;
      var groupMapsTo = _this.getOptions().data.groupMapsTo;
      _this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-hover-simple-bar"
        });
      }).attr("opacity", function(d) {
        return d[groupMapsTo] !== hoveredElement.datum()["name"] ? 0.3 : 1;
      });
    };
    _this.handleLegendMouseOut = function(event) {
      _this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-simple-bar"
        });
      }).attr("opacity", 1);
    };
    return _this;
  }
  Bullet2.prototype.init = function() {
    var eventsFragment = this.services.events;
    eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  Bullet2.prototype.render = function(animate) {
    var _this = this;
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var svg = this.getComponentContainer({ withinChartClip: true });
    var data = this.model.getDisplayData(this.configs.groups);
    var rangeScale = this.services.cartesianScales.getRangeScale();
    var rangeIdentifier = this.services.cartesianScales.getRangeIdentifier();
    var _a2 = rangeScale.range(), rangeScaleStart = _a2[0], rangeScaleEnd = _a2[1];
    var _b = rangeScale.domain();
    _b[0];
    var rangeScaleDomainMax = _b[1];
    var renderRangeBoxes = function() {
      var rangeBoxData = [];
      data.forEach(function(datum2) {
        if (datum2.ranges) {
          datum2.ranges.forEach(function(range2, i) {
            if (range2 !== null && range2 !== void 0 && range2 < rangeScaleDomainMax) {
              rangeBoxData.push({
                datum: datum2,
                value: range2,
                order: i + 1
              });
            }
          });
        } else {
          rangeBoxData.push({
            datum: datum2,
            order: 1
          });
        }
      });
      var rangeBoxes = DOMUtils.appendOrSelect(svg, "g.range-boxes").selectAll("path.range-box").data(rangeBoxData, function(datum2) {
        return datum2[groupMapsTo] + "-" + datum2.order;
      });
      rangeBoxes.exit().attr("opacity", 0).remove();
      var rangeBoxesEnter = rangeBoxes.enter().append("path").attr("opacity", 0);
      rangeBoxesEnter.merge(rangeBoxes).attr("class", function(d) {
        return "range-box order-" + d.order;
      }).transition().call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "bullet-range-box-update-enter",
          animate
        });
      }).attr("d", function(d, i) {
        var lineHeight = 16;
        var x0, x1, y0, y1;
        if (d.order === 1) {
          x0 = _this.services.cartesianScales.getDomainValue(d.datum, i) - lineHeight / 2;
          x1 = x0 + lineHeight;
          y0 = rangeScaleEnd - 2;
          y1 = rangeScaleStart + 1;
        } else {
          x0 = _this.services.cartesianScales.getDomainValue(d.datum, i) - lineHeight / 2;
          x1 = x0 + lineHeight;
          y0 = _this.services.cartesianScales.getRangeValue(d.value, i);
          y1 = rangeScaleEnd;
        }
        return Tools.generateSVGPathString({ x0, x1, y0, y1 }, _this.services.cartesianScales.getOrientation());
      }).attr("opacity", 1);
    };
    var renderBars = function() {
      var bars = DOMUtils.appendOrSelect(svg, "g.bars").selectAll("path.bar").data(data, function(datum2) {
        return datum2[groupMapsTo];
      });
      bars.exit().attr("opacity", 0).remove();
      var barsEnter = bars.enter().append("path").attr("opacity", 0);
      barsEnter.merge(bars).classed("bar", true).transition().call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "bullet-bar-update-enter",
          animate
        });
      }).attr("class", function(d) {
        return _this.model.getColorClassName({
          classNameTypes: [ColorClassNameTypes.FILL],
          dataGroupName: d[groupMapsTo],
          originalClassName: "bar"
        });
      }).style("fill", function(d) {
        return _this.model.getFillColor(d[groupMapsTo]);
      }).attr("d", function(d, i) {
        var barWidth = 8;
        var x0 = _this.services.cartesianScales.getDomainValue(d, i) - barWidth / 2;
        var x1 = x0 + barWidth;
        var y0 = _this.services.cartesianScales.getRangeValue(0) + 1;
        var y1 = _this.services.cartesianScales.getRangeValue(d, i);
        return Tools.generateSVGPathString({ x0, x1, y0, y1 }, _this.services.cartesianScales.getOrientation());
      }).attr("opacity", 1).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", function(d) {
        return d.value;
      });
    };
    var renderTargetLines = function() {
      var lines2 = DOMUtils.appendOrSelect(svg, "g.markers").selectAll("path.marker").data(data.filter(function(d) {
        return Tools.getProperty(d, "marker") !== null;
      }), function(datum2) {
        return datum2[groupMapsTo];
      });
      lines2.exit().attr("opacity", 0).remove();
      var linesEnter = lines2.enter().append("path").attr("opacity", 0);
      linesEnter.merge(lines2).classed("marker", true).transition().call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "bullet-marker-update-enter",
          animate
        });
      }).attr("d", function(d, i) {
        var lineHeight = 24;
        var x0 = _this.services.cartesianScales.getDomainValue(d, i) - lineHeight / 2;
        var x1 = x0 + lineHeight;
        var y0 = _this.services.cartesianScales.getRangeValue(d.marker, i);
        var y1 = y0;
        return Tools.generateSVGPathString({ x0, x1, y0, y1 }, _this.services.cartesianScales.getOrientation());
      }).attr("opacity", 1);
    };
    var renderTargetQuartiles = function() {
      var quartilesData = [];
      data.filter(function(d) {
        return Tools.getProperty(d, "marker") !== null;
      }).forEach(function(d) {
        var value2 = d.marker;
        var barValue = d[rangeIdentifier];
        quartilesData = quartilesData.concat([
          { datum: d, value: value2 * 0.25, barValue },
          { datum: d, value: value2 * 0.5, barValue },
          { datum: d, value: value2 * 0.75, barValue }
        ]);
      });
      var lines2 = DOMUtils.appendOrSelect(svg, "g.quartiles").selectAll("path.quartile").data(quartilesData, function(datum2) {
        return datum2[groupMapsTo];
      });
      lines2.exit().attr("opacity", 0).remove();
      var linesEnter = lines2.enter().append("path").attr("opacity", 0);
      linesEnter.merge(lines2).attr("class", function(d) {
        return "quartile " + (d.value <= d.barValue ? "over-bar" : "");
      }).transition().call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "bullet-quartile-update-enter",
          animate
        });
      }).attr("d", function(_a3, i) {
        var d = _a3.datum, value2 = _a3.value;
        var lineHeight = 4;
        if (d.ranges && d.ranges.indexOf(value2) !== -1) {
          lineHeight = 8;
        }
        var x0 = _this.services.cartesianScales.getDomainValue(d, i) - lineHeight / 2;
        var x1 = x0 + lineHeight;
        var y0 = _this.services.cartesianScales.getRangeValue(value2, i);
        var y1 = y0;
        return Tools.generateSVGPathString({ x0, x1, y0, y1 }, _this.services.cartesianScales.getOrientation());
      }).attr("opacity", 1);
    };
    renderRangeBoxes();
    renderBars();
    renderTargetLines();
    renderTargetQuartiles();
    this.addEventListeners();
  };
  Bullet2.prototype.addEventListeners = function() {
    var self2 = this;
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var rangeIdentifier = this.services.cartesianScales.getRangeIdentifier();
    this.parent.selectAll("path.bar").on("mouseover", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", true);
      self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEOVER, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      var performanceAreaTitles = Tools.getProperty(options2, "bullet", "performanceAreaTitles");
      var matchingRangeIndex = self2.model.getMatchingRangeIndexForDatapoint(datum2);
      self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
        event,
        hoveredElement,
        items: [
          {
            label: options2.tooltip.groupLabel || "Group",
            value: datum2[groupMapsTo],
            class: self2.model.getColorClassName({
              classNameTypes: [ColorClassNameTypes.TOOLTIP],
              dataGroupName: datum2[groupMapsTo]
            })
          },
          {
            label: "Value",
            value: datum2[rangeIdentifier]
          },
          {
            label: "Target",
            value: datum2.marker
          },
          {
            label: "Percentage",
            value: Math.floor(datum2[rangeIdentifier] / datum2.marker * 100) + "%"
          },
          {
            label: "Performance",
            value: performanceAreaTitles[matchingRangeIndex]
          }
        ]
      });
    }).on("mousemove", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEMOVE, {
        event,
        element: select(this),
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("click", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Bar.BAR_CLICK, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mouseout", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", false);
      self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEOUT, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
        hoveredElement
      });
    });
  };
  Bullet2.prototype.destroy = function() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    var eventsFragment = this.services.events;
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  return Bullet2;
}(Component);
var __extends$14 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Histogram = function(_super) {
  __extends$14(Histogram2, _super);
  function Histogram2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "histogram";
    _this.renderType = RenderTypes.SVG;
    _this.handleLegendOnHover = function(event) {
      var hoveredElement = event.detail.hoveredElement;
      var options2 = _this.getOptions();
      var groupMapsTo = options2.data.groupMapsTo;
      _this.parent.selectAll("path.bar").transition("legend-hover-bar").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-hover-bar"
        });
      }).attr("opacity", function(d) {
        return d[groupMapsTo] !== hoveredElement.datum()["name"] ? 0.3 : 1;
      });
    };
    _this.handleLegendMouseOut = function(event) {
      _this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        });
      }).attr("opacity", 1);
    };
    return _this;
  }
  Histogram2.prototype.init = function() {
    var eventsFragment = this.services.events;
    eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  Histogram2.prototype.render = function(animate) {
    var _this = this;
    var svg = this.getComponentContainer();
    var options2 = this.model.getOptions();
    var groupIdentifier = options2.groupIdentifier;
    var groupMapsTo = options2.data.groupMapsTo;
    var binnedStackedData = this.model.getBinnedStackedData();
    var x2 = this.services.cartesianScales.getMainXScale();
    var barGroups = svg.selectAll("g.bars").data(binnedStackedData, function(d) {
      return get$3(d, "0." + groupMapsTo);
    });
    barGroups.exit().attr("opacity", 0).remove();
    barGroups.enter().append("g").classed("bars", true).attr("role", Roles.GROUP);
    var bars = svg.selectAll("g.bars").selectAll("path.bar").data(function(data) {
      return data;
    });
    bars.exit().remove();
    bars.enter().append("path").merge(bars).classed("bar", true).attr(groupIdentifier, function(d, i) {
      return i;
    }).transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "histogram-bar-update-enter",
        animate
      });
    }).attr("class", function(d) {
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.FILL],
        dataGroupName: d[groupMapsTo],
        originalClassName: "bar"
      });
    }).style("fill", function(d) {
      return _this.model.getFillColor(d[groupMapsTo]);
    }).attr("d", function(d, i) {
      var bin2 = get$3(d, "data");
      if (!bin2) {
        return;
      }
      var barWidth = x2(bin2.x1) - x2(bin2.x0) - 1;
      var x0 = _this.services.cartesianScales.getDomainValue(bin2.x0, i);
      var x1 = x0 + barWidth;
      var y0 = _this.services.cartesianScales.getRangeValue(d[0], i);
      var y1 = _this.services.cartesianScales.getRangeValue(d[1], i);
      if (Math.abs(y1 - y0) > 0 && Math.abs(y1 - y0) > options2.bars.dividerSize) {
        if (_this.services.cartesianScales.getOrientation() === CartesianOrientations.VERTICAL) {
          y1 += 1;
        } else {
          y1 -= 1;
        }
      }
      return Tools.generateSVGPathString({ x0, x1, y0, y1 }, _this.services.cartesianScales.getOrientation());
    }).attr("opacity", 1).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", function(d) {
      return Tools.getProperty(d, "data", d[groupMapsTo]);
    });
    this.addEventListeners();
  };
  Histogram2.prototype.addEventListeners = function() {
    var options2 = this.model.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var self2 = this;
    this.parent.selectAll("path.bar").on("mouseover", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", true);
      var x0 = parseFloat(get$3(datum2, "data.x0"));
      var x1 = parseFloat(get$3(datum2, "data.x1"));
      var rangeAxisPosition = self2.services.cartesianScales.getRangeAxisPosition();
      var rangeScaleLabel = self2.services.cartesianScales.getScaleLabel(rangeAxisPosition);
      self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
        event,
        hoveredElement,
        items: [
          {
            label: get$3(options2, "bins.rangeLabel") || "Range",
            value: x0 + " \u2013 " + x1
          },
          {
            label: options2.tooltip.groupLabel || "Group",
            value: datum2[groupMapsTo],
            class: self2.model.getColorClassName({
              classNameTypes: [ColorClassNameTypes.TOOLTIP],
              dataGroupName: datum2[groupMapsTo]
            })
          },
          {
            label: rangeScaleLabel,
            value: get$3(datum2, "data." + datum2[groupMapsTo])
          }
        ]
      });
    }).on("mousemove", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("mouseout", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", false);
      self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE);
    });
  };
  Histogram2.prototype.destroy = function() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    var eventsFragment = this.services.events;
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  return Histogram2;
}(Component);
var __extends$13 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Line = function(_super) {
  __extends$13(Line2, _super);
  function Line2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "line";
    _this.renderType = RenderTypes.SVG;
    _this.handleLegendOnHover = function(event) {
      var hoveredElement = event.detail.hoveredElement;
      _this.parent.selectAll("path.line").transition("legend-hover-line").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-hover-line"
        });
      }).attr("opacity", function(group) {
        if (group.name !== hoveredElement.datum()["name"]) {
          return lines.opacity.unselected;
        }
        return lines.opacity.selected;
      });
    };
    _this.handleLegendMouseOut = function(event) {
      _this.parent.selectAll("path.line").transition("legend-mouseout-line").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-line"
        });
      }).attr("opacity", lines.opacity.selected);
    };
    return _this;
  }
  Line2.prototype.init = function() {
    var events = this.services.events;
    events.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    events.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  Line2.prototype.render = function(animate) {
    var _this = this;
    if (animate === void 0) {
      animate = true;
    }
    var svg = this.getComponentContainer({ withinChartClip: true });
    var _a2 = this.services, cartesianScales = _a2.cartesianScales, curves = _a2.curves;
    var getDomainValue = function(d, i) {
      return cartesianScales.getDomainValue(d, i);
    };
    var getRangeValue = function(d, i) {
      return cartesianScales.getRangeValue(d, i);
    };
    var _b = Tools.flipDomainAndRangeBasedOnOrientation(getDomainValue, getRangeValue, cartesianScales.getOrientation()), getXValue = _b[0], getYValue = _b[1];
    var options2 = this.getOptions();
    var lineGenerator = line().x(getXValue).y(getYValue).curve(curves.getD3Curve()).defined(function(datum2, i) {
      var rangeIdentifier = cartesianScales.getRangeIdentifier(datum2);
      var value2 = datum2[rangeIdentifier];
      if (value2 === null || value2 === void 0) {
        return false;
      }
      return true;
    });
    var data = [];
    if (this.configs.stacked) {
      var percentage = Object.keys(options2.axes).some(function(axis2) {
        return options2.axes[axis2].percentage;
      });
      var groupMapsTo_1 = options2.data.groupMapsTo;
      var stackedData = this.model.getStackedData({
        groups: this.configs.groups,
        percentage
      });
      data = stackedData.map(function(d) {
        var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(d);
        var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(d);
        return {
          name: Tools.getProperty(d, 0, groupMapsTo_1),
          data: d.map(function(datum2) {
            var _a3;
            return _a3 = {}, _a3[domainIdentifier] = datum2.data.sharedStackKey, _a3[groupMapsTo_1] = datum2[groupMapsTo_1], _a3[rangeIdentifier] = datum2[1], _a3;
          }),
          hidden: !Tools.some(d, function(datum2) {
            return datum2[0] !== datum2[1];
          })
        };
      });
    } else {
      data = this.model.getGroupedData(this.configs.groups);
    }
    var lines2 = svg.selectAll("path.line").data(data, function(group) {
      return group.name;
    });
    lines2.exit().attr("opacity", 0).remove();
    var enteringLines = lines2.enter().append("path").classed("line", true).attr("opacity", 0);
    enteringLines.merge(lines2).data(data, function(group) {
      return group.name;
    }).attr("class", function(group) {
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.STROKE],
        dataGroupName: group.name,
        originalClassName: "line"
      });
    }).style("stroke", function(group) {
      return _this.model.getStrokeColor(group.name);
    }).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "line").attr("aria-label", function(group) {
      var groupData = group.data;
      return groupData.map(function(datum2) {
        var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(datum2);
        return datum2[rangeIdentifier];
      }).join(",");
    }).transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "line-update-enter",
        animate
      });
    }).attr("opacity", function(d) {
      return d.hidden ? 0 : 1;
    }).attr("d", function(group) {
      var groupData = group.data;
      return lineGenerator(groupData);
    });
  };
  Line2.prototype.destroy = function() {
    var eventsFragment = this.services.events;
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  return Line2;
}(Component);
var __extends$12 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Lollipop = function(_super) {
  __extends$12(Lollipop2, _super);
  function Lollipop2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "lollipop";
    _this.renderType = RenderTypes.SVG;
    _this.handleScatterOnHover = function(event) {
      var hoveredElement = event.detail;
      var options2 = _this.getOptions();
      var groupMapsTo = options2.data.groupMapsTo;
      _this.parent.selectAll("line.line").attr("stroke-width", function(d) {
        if (d[groupMapsTo] !== hoveredElement.datum[groupMapsTo]) {
          return lines.weight.unselected;
        }
        return lines.weight.selected;
      });
    };
    _this.handleScatterOnMouseOut = function(event) {
      _this.parent.selectAll("line.line").attr("stroke-width", lines.weight.unselected);
    };
    _this.handleLegendOnHover = function(event) {
      var hoveredElement = event.detail.hoveredElement;
      var options2 = _this.getOptions();
      var groupMapsTo = options2.data.groupMapsTo;
      _this.parent.selectAll("line.line").transition("legend-hover-line").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-hover-line"
        });
      }).attr("opacity", function(d) {
        if (d[groupMapsTo] !== hoveredElement.datum()["name"]) {
          return lines.opacity.unselected;
        }
        return lines.opacity.selected;
      });
    };
    _this.handleLegendMouseOut = function(event) {
      _this.parent.selectAll("line.line").transition("legend-mouseout-line").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-line"
        });
      }).attr("opacity", lines.opacity.selected);
    };
    return _this;
  }
  Lollipop2.prototype.init = function() {
    var events = this.services.events;
    events.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    events.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  Lollipop2.prototype.render = function(animate) {
    var _this = this;
    var svg = this.getComponentContainer({ withinChartClip: true });
    var options2 = this.model.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var cartesianScales = this.services.cartesianScales;
    var mainXScale = cartesianScales.getMainXScale();
    var mainYScale = cartesianScales.getMainYScale();
    var domainIdentifier = cartesianScales.getDomainIdentifier();
    var getDomainValue = function(d, i) {
      return cartesianScales.getDomainValue(d, i);
    };
    var getRangeValue = function(d, i) {
      return cartesianScales.getRangeValue(d, i);
    };
    var orientation = cartesianScales.getOrientation();
    var _a2 = Tools.flipDomainAndRangeBasedOnOrientation(getDomainValue, getRangeValue, orientation), getXValue = _a2[0], getYValue = _a2[1];
    var lines2 = svg.selectAll("line.line").data(this.getScatterData(), function(datum2) {
      return datum2[groupMapsTo] + "-" + datum2[domainIdentifier];
    });
    lines2.exit().attr("opacity", 0).remove();
    var enteringLines = lines2.enter().append("line").attr("opacity", 0);
    var allLines = enteringLines.merge(lines2).classed("line", true).attr("class", function(d) {
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.STROKE],
        dataGroupName: d[groupMapsTo],
        originalClassName: "line"
      });
    }).transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "lollipop-line-update-enter",
        animate
      });
    }).style("stroke", function(d) {
      return _this.model.getFillColor(d[groupMapsTo], d[domainIdentifier], d);
    }).attr("opacity", 1);
    if (orientation === CartesianOrientations.HORIZONTAL) {
      allLines.attr("y1", getYValue).attr("y2", getYValue).attr("x1", mainXScale.range()[0]).attr("x2", function(d, i) {
        return getXValue(d, i) - options2.points.radius;
      });
    } else {
      allLines.attr("x1", getXValue).attr("x2", getXValue).attr("y1", mainYScale.range()[0]).attr("y2", function(d, i) {
        return getYValue(d, i) + options2.points.radius;
      });
    }
    this.addScatterPointEventListeners();
  };
  Lollipop2.prototype.addScatterPointEventListeners = function() {
    this.services.events.addEventListener(Events$1.Scatter.SCATTER_MOUSEOVER, this.handleScatterOnHover);
    this.services.events.addEventListener(Events$1.Scatter.SCATTER_MOUSEOUT, this.handleScatterOnMouseOut);
  };
  Lollipop2.prototype.destroy = function() {
    var eventsFragment = this.services.events;
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
    eventsFragment.removeEventListener(Events$1.Scatter.SCATTER_MOUSEOVER, this.handleScatterOnHover);
    eventsFragment.removeEventListener(Events$1.Scatter.SCATTER_MOUSEOUT, this.handleScatterOnMouseOut);
  };
  return Lollipop2;
}(Scatter);
var __extends$11 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var StackedScatter = function(_super) {
  __extends$11(StackedScatter2, _super);
  function StackedScatter2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "scatter-stacked";
    _this.renderType = RenderTypes.SVG;
    return _this;
  }
  StackedScatter2.prototype.render = function(animate) {
    var _this = this;
    var isScatterEnabled = Tools.getProperty(this.getOptions(), "points", "enabled");
    if (!isScatterEnabled) {
      return;
    }
    var svg = this.getComponentContainer({ withinChartClip: true });
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var percentage = Object.keys(options2.axes).some(function(axis2) {
      return options2.axes[axis2].percentage;
    });
    var stackedData = this.model.getStackedData({
      groups: this.configs.groups,
      percentage
    });
    var circleGroups = svg.selectAll("g.dots").data(stackedData, function(d) {
      return Tools.getProperty(d, 0, groupMapsTo);
    });
    circleGroups.exit().attr("opacity", 0).remove();
    var circleGroupsEnter = circleGroups.enter().append("g").classed("dots", true).attr("role", Roles.GROUP);
    var circles = circleGroupsEnter.merge(circleGroups).selectAll("circle.dot").data(function(d) {
      return d;
    });
    circles.exit().attr("opacity", 0).remove();
    var enteringCircles = circles.enter().append("circle").classed("dot", true).attr("opacity", 0);
    var circlesToStyle = enteringCircles.merge(circles).datum(function(d) {
      var _a2;
      var group = d[groupMapsTo];
      var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(d);
      var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(d);
      return _a2 = {}, _a2[groupMapsTo] = group, _a2[domainIdentifier] = d["data"]["sharedStackKey"], _a2[rangeIdentifier] = d[1], _a2;
    });
    this.styleCircles(circlesToStyle, animate);
    this.addEventListeners();
  };
  StackedScatter2.prototype.getTooltipData = function(hoveredX, hoveredY) {
    var _this = this;
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var percentage = Object.keys(options2.axes).some(function(axis2) {
      return options2.axes[axis2].percentage;
    });
    var stackedData = this.model.getStackedData({
      groups: this.configs.groups,
      percentage
    });
    var tooltipData = [];
    stackedData.forEach(function(groupData, groupDataIndex) {
      groupData.forEach(function(datum2, dataIndex) {
        var _a2;
        var group = datum2[groupMapsTo];
        var domainValue = datum2["data"]["sharedStackKey"];
        var rangeValue = datum2["data"][group];
        var stackedRangeValue = datum2[1];
        var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(datum2);
        var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(datum2);
        if (rangeValue !== null && rangeValue !== void 0 && hoveredX === _this.services.cartesianScales.getDomainValue(domainValue) && hoveredY === _this.services.cartesianScales.getRangeValue(stackedRangeValue)) {
          if (percentage) {
            rangeValue = _this.model.getStackedData({
              groups: _this.configs.groups
            })[groupDataIndex][dataIndex]["data"][group];
          }
          if (rangeValue !== null) {
            tooltipData.push((_a2 = {}, _a2[groupMapsTo] = group, _a2[domainIdentifier] = domainValue, _a2[rangeIdentifier] = rangeValue, _a2));
          }
        }
      });
    });
    return this.model.getDisplayData(this.configs.groups).filter(function(datapoint) {
      var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(datapoint);
      var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(datapoint);
      return tooltipData.find(function(tooltipDatapoint) {
        return tooltipDatapoint[groupMapsTo] == datapoint[groupMapsTo] && tooltipDatapoint[domainIdentifier] == datapoint[domainIdentifier] && tooltipDatapoint[rangeIdentifier] == datapoint[rangeIdentifier];
      }) !== void 0;
    });
  };
  return StackedScatter2;
}(Scatter);
var __extends$10 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
function arcTween(a, arcFunc) {
  var _this = this;
  var i = interpolate$1(this._current, a);
  return function(t) {
    _this._current = i(t);
    return arcFunc(_this._current);
  };
}
var Pie = function(_super) {
  __extends$10(Pie2, _super);
  function Pie2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "pie";
    _this.renderType = RenderTypes.SVG;
    _this.handleLegendOnHover = function(event) {
      var hoveredElement = event.detail.hoveredElement;
      var groupMapsTo = _this.getOptions().data.groupMapsTo;
      _this.parent.selectAll("path.slice").transition("legend-hover-bar").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-hover-bar"
        });
      }).attr("opacity", function(d) {
        return d.data[groupMapsTo] !== hoveredElement.datum()["name"] ? 0.3 : 1;
      });
    };
    _this.handleLegendMouseOut = function(event) {
      _this.parent.selectAll("path.slice").transition("legend-mouseout-bar").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        });
      }).attr("opacity", 1);
    };
    return _this;
  }
  Pie2.prototype.init = function() {
    var eventsFragment = this.services.events;
    eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  Pie2.prototype.getInnerRadius = function() {
    return pie$1.innerRadius;
  };
  Pie2.prototype.render = function(animate) {
    var _this = this;
    if (animate === void 0) {
      animate = true;
    }
    var self2 = this;
    var svg = this.getComponentContainer();
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var valueMapsTo = options2.pie.valueMapsTo;
    var displayData = this.model.getDisplayData().filter(function(data) {
      return data[valueMapsTo] > 0;
    });
    var radius = this.computeRadius();
    this.arc = arc().innerRadius(this.getInnerRadius()).outerRadius(radius);
    this.hoverArc = arc().innerRadius(this.getInnerRadius()).outerRadius(radius + pie$1.hoverArc.outerRadiusOffset);
    var pieLayout = pie().value(function(d) {
      return d[valueMapsTo];
    }).sort(Tools.getProperty(options2, "pie", "sortFunction")).padAngle(pie$1.padAngle);
    var pieLayoutData = pieLayout(displayData);
    var slicesGroup = DOMUtils.appendOrSelect(svg, "g.slices").attr("role", Roles.GROUP).attr("data-name", "slices");
    var paths = slicesGroup.selectAll("path.slice").data(pieLayoutData, function(d) {
      return d.data[groupMapsTo];
    });
    paths.exit().attr("opacity", 0).remove();
    var enteringPaths = paths.enter().append("path").classed("slice", true).attr("opacity", 0);
    var allPaths = enteringPaths.merge(paths).attr("class", function(d) {
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.FILL],
        dataGroupName: d.data[groupMapsTo],
        originalClassName: "slice"
      });
    }).style("fill", function(d) {
      return self2.model.getFillColor(d.data[groupMapsTo]);
    }).attr("d", this.arc);
    allPaths.transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "pie_slice_enter_update",
        animate
      });
    }).attr("opacity", 1).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "slice").attr("aria-label", function(d) {
      return d[valueMapsTo] + ", " + (Tools.convertValueToPercentage(d.data[valueMapsTo], displayData, valueMapsTo) + "%");
    }).attrTween("d", function(a) {
      return arcTween.bind(this)(a, self2.arc);
    });
    var renderLabels = options2.pie.labels.enabled;
    var labelData = renderLabels ? pieLayoutData.filter(function(x2) {
      return x2.data[valueMapsTo] > 0;
    }) : [];
    var labelsGroup = DOMUtils.appendOrSelect(svg, "g.labels").attr("role", Roles.GROUP).attr("data-name", "labels");
    var labels = labelsGroup.selectAll("text.pie-label").data(labelData, function(d) {
      return d.data[groupMapsTo];
    });
    labels.exit().attr("opacity", 0).remove();
    var enteringLabels = labels.enter().append("text").classed("pie-label", true);
    var calloutData = [];
    enteringLabels.merge(labels).style("text-anchor", "middle").text(function(d) {
      if (options2.pie.labels.formatter) {
        return options2.pie.labels.formatter(d);
      }
      return Tools.convertValueToPercentage(d.data[valueMapsTo], displayData, valueMapsTo) + "%";
    }).datum(function(d) {
      var marginedRadius = radius + 7;
      var theta = (d.endAngle - d.startAngle) / 2 + d.startAngle;
      var deg = theta / Math.PI * 180;
      var textLength = this.getComputedTextLength();
      d.textOffsetX = textLength / 2;
      d.textOffsetY = deg > 90 && deg < 270 ? 10 : 0;
      d.xPosition = (d.textOffsetX + marginedRadius) * Math.sin(theta);
      d.yPosition = (d.textOffsetY + marginedRadius) * -Math.cos(theta);
      return d;
    }).attr("transform", function(d, i) {
      var totalSlices = labelData.length;
      var sliceAngleDeg = (d.endAngle - d.startAngle) * (180 / Math.PI);
      if (i >= totalSlices - 2) {
        if (sliceAngleDeg < pie$1.callout.minSliceDegree) {
          var labelTranslateX = void 0, labelTranslateY = void 0;
          if (d.index === totalSlices - 1) {
            labelTranslateX = d.xPosition + pie$1.callout.offsetX + pie$1.callout.textMargin + d.textOffsetX;
            labelTranslateY = d.yPosition - pie$1.callout.offsetY;
            d.direction = CalloutDirections.RIGHT;
            calloutData.push(d);
          } else {
            labelTranslateX = d.xPosition - pie$1.callout.offsetX - d.textOffsetX - pie$1.callout.textMargin;
            labelTranslateY = d.yPosition - pie$1.callout.offsetY;
            d.direction = CalloutDirections.LEFT;
            calloutData.push(d);
          }
          return "translate(" + labelTranslateX + ", " + labelTranslateY + ")";
        }
      }
      return "translate(" + d.xPosition + ", " + d.yPosition + ")";
    });
    this.renderCallouts(calloutData);
    var optionName = Tools.getProperty(options2, "donut") ? "donut" : "pie";
    var alignment = Tools.getProperty(options2, optionName, "alignment");
    var width = DOMUtils.getSVGElementSize(this.getParent(), {
      useAttrs: true
    }).width;
    var xOffset = renderLabels ? pie$1.xOffset : 0;
    var yOffset = renderLabels ? pie$1.yOffset : 0;
    var pieTranslateX = radius + xOffset;
    if (alignment === Alignments.CENTER) {
      pieTranslateX = width / 2;
    } else if (alignment === Alignments.RIGHT) {
      pieTranslateX = width - radius - pie$1.xOffset;
    }
    var pieTranslateY = radius + yOffset;
    if (calloutData.length > 0) {
      pieTranslateY += pie$1.yOffsetCallout;
    }
    svg.attr("x", pieTranslateX + 7).attr("y", pieTranslateY);
    this.addEventListeners();
  };
  Pie2.prototype.renderCallouts = function(calloutData) {
    var svg = DOMUtils.appendOrSelect(this.getComponentContainer(), "g.callouts").attr("role", Roles.GROUP).attr("data-name", "callouts");
    var callouts = svg.selectAll("g.callout").data(calloutData);
    callouts.exit().remove();
    var enteringCallouts = callouts.enter().append("g").classed("callout", true).attr("role", Roles.GROUP).attr("aria-roledescription", "label callout");
    enteringCallouts.merge(callouts).datum(function(d) {
      var xPosition = d.xPosition, yPosition = d.yPosition, direction = d.direction;
      if (direction === CalloutDirections.RIGHT) {
        d.startPos = {
          x: xPosition,
          y: yPosition + d.textOffsetY
        };
        d.endPos = {
          x: xPosition + pie$1.callout.offsetX,
          y: yPosition - pie$1.callout.offsetY + d.textOffsetY
        };
        d.intersectPointX = d.endPos.x - pie$1.callout.horizontalLineLength;
      } else {
        d.startPos = {
          x: xPosition,
          y: yPosition + d.textOffsetY
        };
        d.endPos = {
          x: xPosition - pie$1.callout.offsetX,
          y: yPosition - pie$1.callout.offsetY + d.textOffsetY
        };
        d.intersectPointX = d.endPos.x + pie$1.callout.horizontalLineLength;
      }
      return d;
    });
    var enteringVerticalLines = enteringCallouts.append("line").classed("vertical-line", true);
    enteringVerticalLines.merge(svg.selectAll("line.vertical-line")).datum(function(d) {
      return select(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", function(d) {
      return d.startPos.x;
    }).attr("y1", function(d) {
      return d.startPos.y;
    }).attr("x2", function(d) {
      return d.intersectPointX;
    }).attr("y2", function(d) {
      return d.endPos.y;
    });
    var enteringHorizontalLines = enteringCallouts.append("line").classed("horizontal-line", true);
    enteringHorizontalLines.merge(svg.selectAll("line.horizontal-line")).datum(function(d) {
      return select(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", function(d) {
      return d.intersectPointX;
    }).attr("y1", function(d) {
      return d.endPos.y;
    }).attr("x2", function(d) {
      return d.endPos.x;
    }).attr("y2", function(d) {
      return d.endPos.y;
    });
  };
  Pie2.prototype.addEventListeners = function() {
    var self2 = this;
    this.parent.selectAll("path.slice").on("mouseover", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", true).transition("pie_slice_mouseover").call(function(t) {
        return self2.services.transitions.setupTransition({
          transition: t,
          name: "pie_slice_mouseover"
        });
      }).attr("d", self2.hoverArc);
      self2.services.events.dispatchEvent(Events$1.Pie.SLICE_MOUSEOVER, {
        event,
        element: select(this),
        datum: datum2
      });
      var groupMapsTo = self2.getOptions().data.groupMapsTo;
      var valueMapsTo = self2.getOptions().pie.valueMapsTo;
      self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
        event,
        hoveredElement,
        items: [
          {
            label: datum2.data[groupMapsTo],
            value: datum2.data[valueMapsTo]
          }
        ]
      });
    }).on("mousemove", function(event, datum2) {
      var hoveredElement = select(this);
      self2.services.events.dispatchEvent(Events$1.Pie.SLICE_MOUSEMOVE, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("click", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Pie.SLICE_CLICK, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mouseout", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", false).transition("pie_slice_mouseout").call(function(t) {
        return self2.services.transitions.setupTransition({
          transition: t,
          name: "pie_slice_mouseout"
        });
      }).attr("d", self2.arc);
      self2.services.events.dispatchEvent(Events$1.Pie.SLICE_MOUSEOUT, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
        hoveredElement
      });
    });
  };
  Pie2.prototype.computeRadius = function() {
    var _a2 = DOMUtils.getSVGElementSize(this.parent, {
      useAttrs: true
    }), width = _a2.width, height = _a2.height;
    var options2 = this.getOptions();
    var radius = Math.min(width, height) / 2;
    var renderLabels = options2.pie.labels.enabled;
    return renderLabels ? radius + pie$1.radiusOffset : radius;
  };
  return Pie2;
}(Component);
var __extends$$ = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ARROW_UP_PATH_STRING = "4,10 8,6 12,10";
var ARROW_DOWN_PATH_STRING = "12,6 8,10 4,6";
var Gauge = function(_super) {
  __extends$$(Gauge2, _super);
  function Gauge2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "gauge";
    _this.renderType = RenderTypes.SVG;
    return _this;
  }
  Gauge2.prototype.getValue = function() {
    var _a2, _b;
    var data = this.model.getData();
    var value2 = (_b = (_a2 = data.find(function(d) {
      return d.group === "value";
    })) === null || _a2 === void 0 ? void 0 : _a2.value, _b !== null && _b !== void 0 ? _b : null);
    return value2;
  };
  Gauge2.prototype.getValueRatio = function() {
    var value2 = Tools.clamp(this.getValue(), 0, 100);
    return value2 / 100;
  };
  Gauge2.prototype.getDelta = function() {
    var _a2, _b;
    var data = this.model.getData();
    var delta = (_b = (_a2 = data.find(function(d) {
      return d.group === "delta";
    })) === null || _a2 === void 0 ? void 0 : _a2.value, _b !== null && _b !== void 0 ? _b : null);
    return delta;
  };
  Gauge2.prototype.getArcRatio = function() {
    var options2 = this.getOptions();
    var type2 = Tools.getProperty(options2, "gauge", "type");
    var arcRatio = type2 === GaugeTypes.FULL ? 1 : 0.5;
    return arcRatio;
  };
  Gauge2.prototype.getArcSize = function() {
    return this.getArcRatio() * Math.PI * 2;
  };
  Gauge2.prototype.getStartAngle = function() {
    var arcSize = this.getArcSize();
    if (arcSize === 2 * Math.PI) {
      return 0;
    }
    return -arcSize / 2;
  };
  Gauge2.prototype.getArrow = function(delta) {
    var options2 = this.getOptions();
    var arrowDirection = Tools.getProperty(options2, "gauge", "deltaArrow", "direction");
    switch (arrowDirection) {
      case ArrowDirections.UP:
        return ARROW_UP_PATH_STRING;
      case ArrowDirections.DOWN:
        return ARROW_DOWN_PATH_STRING;
      default:
        return delta > 0 ? ARROW_UP_PATH_STRING : ARROW_DOWN_PATH_STRING;
    }
  };
  Gauge2.prototype.render = function(animate) {
    var _this = this;
    var svg = this.getComponentContainer().attr("width", "100%").attr("height", "100%");
    var options2 = this.getOptions();
    var value2 = this.getValue();
    var valueRatio = this.getValueRatio();
    var arcSize = this.getArcSize();
    var startAngle = this.getStartAngle();
    var rotationAngle = valueRatio * arcSize;
    var currentAngle = startAngle + rotationAngle;
    var endAngle = startAngle + arcSize;
    var radius = this.computeRadius();
    var innerRadius = this.getInnerRadius();
    this.backgroundArc = arc().innerRadius(innerRadius).outerRadius(radius).startAngle(currentAngle).endAngle(endAngle);
    this.arc = arc().innerRadius(innerRadius).outerRadius(radius).startAngle(startAngle).endAngle(currentAngle);
    DOMUtils.appendOrSelect(svg, "path.arc-background").attr("d", this.backgroundArc);
    var arcValue = svg.selectAll("path.arc-foreground").data([value2]);
    var arcEnter = arcValue.enter().append("path");
    arcEnter.merge(arcValue).attr("class", this.model.getColorClassName({
      classNameTypes: [ColorClassNameTypes.FILL],
      dataGroupName: "value",
      originalClassName: "arc-foreground"
    })).style("fill", function(d) {
      return Tools.getProperty(_this.getOptions(), "color", "scale", "value");
    }).attr("d", this.arc).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", function(d) {
      return d;
    });
    this.drawValueNumber();
    this.drawDelta();
    arcValue.exit().remove();
    var alignment = Tools.getProperty(options2, "gauge", "alignment");
    var width = DOMUtils.getSVGElementSize(this.getParent(), {
      useAttrs: true
    }).width;
    var gaugeTranslateX = radius;
    if (alignment === Alignments.CENTER) {
      gaugeTranslateX = width / 2;
    } else if (alignment === Alignments.RIGHT) {
      gaugeTranslateX = width - radius;
    }
    svg.attr("x", gaugeTranslateX).attr("y", radius);
    this.addEventListeners();
  };
  Gauge2.prototype.drawValueNumber = function() {
    var svg = this.getComponentContainer();
    var options2 = this.getOptions();
    var arcType = Tools.getProperty(options2, "gauge", "type");
    var value2 = this.getValue();
    var delta = this.getDelta();
    var radius = this.computeRadius();
    var valueFontSize = Tools.getProperty(options2, "gauge", "valueFontSize");
    var deltaFontSize = Tools.getProperty(options2, "gauge", "deltaFontSize");
    var numberSpacing = Tools.getProperty(options2, "gauge", "numberSpacing");
    var showPercentageSymbol = Tools.getProperty(options2, "gauge", "showPercentageSymbol");
    var numbersYPosition = 0;
    if (arcType === GaugeTypes.FULL && !delta) {
      numbersYPosition = deltaFontSize(radius);
    } else if (arcType === GaugeTypes.SEMI && delta) {
      numbersYPosition = -(deltaFontSize(radius) + numberSpacing);
    }
    var numbersGroup = DOMUtils.appendOrSelect(svg, "g.gauge-numbers").attr("transform", "translate(0, " + numbersYPosition + ")");
    var fontSize = valueFontSize(radius);
    var valueNumberGroup = DOMUtils.appendOrSelect(numbersGroup, "g.gauge-value-number");
    var numberFormatter = Tools.getProperty(options2, "gauge", "numberFormatter");
    var valueNumber = valueNumberGroup.selectAll("text.gauge-value-number").data([value2]);
    valueNumber.enter().append("text").attr("class", "gauge-value-number").merge(valueNumber).style("font-size", fontSize + "px").attr("text-anchor", "middle").text(function(d) {
      return numberFormatter(d);
    });
    var valueNumberWidth = DOMUtils.getSVGElementSize(DOMUtils.appendOrSelect(svg, "text.gauge-value-number"), { useBBox: true }).width;
    var symbolFontSize = fontSize / 2;
    var gaugeSymbol = showPercentageSymbol ? "%" : "";
    var symbol = DOMUtils.appendOrSelect(valueNumberGroup, "text.gauge-value-symbol").style("font-size", symbolFontSize + "px").attr("x", valueNumberWidth / 2).text(gaugeSymbol);
    var _a2 = DOMUtils.getSVGElementSize(symbol, { useBBox: true }), symbolWidth = _a2.width, symbolHeight = _a2.height;
    symbol.attr("y", "-" + symbolHeight / 2 + "px");
    valueNumberGroup.attr("transform", "translate(-" + symbolWidth / 2 + ", 0)");
  };
  Gauge2.prototype.drawDelta = function() {
    var self2 = this;
    var svg = this.getComponentContainer();
    var options2 = this.getOptions();
    var delta = this.getDelta();
    var radius = this.computeRadius();
    var deltaFontSize = delta ? Tools.getProperty(options2, "gauge", "deltaFontSize") : function() {
      return 0;
    };
    var numberFormatter = delta ? Tools.getProperty(options2, "gauge", "numberFormatter") : function() {
      return null;
    };
    var arrowSize = Tools.getProperty(options2, "gauge", "deltaArrow", "size");
    var numberSpacing = Tools.getProperty(options2, "gauge", "numberSpacing");
    var showPercentageSymbol = Tools.getProperty(options2, "gauge", "showPercentageSymbol");
    var numbersGroup = DOMUtils.appendOrSelect(svg, "g.gauge-numbers");
    var deltaGroup = DOMUtils.appendOrSelect(numbersGroup, "g.gauge-delta").attr("transform", "translate(0, " + (deltaFontSize(radius) + numberSpacing) + ")");
    var deltaNumber = DOMUtils.appendOrSelect(deltaGroup, "text.gauge-delta-number");
    var gaugeSymbol = showPercentageSymbol ? "%" : "";
    deltaNumber.data(delta === null ? [] : [delta]);
    deltaNumber.enter().append("text").classed("gauge-delta-number", true).merge(deltaNumber).attr("text-anchor", "middle").style("font-size", deltaFontSize(radius) + "px").text(function(d) {
      return "" + numberFormatter(d) + gaugeSymbol;
    });
    var deltaNumberWidth = DOMUtils.getSVGElementSize(DOMUtils.appendOrSelect(svg, ".gauge-delta-number"), { useBBox: true }).width;
    var arrowEnabled = Tools.getProperty(options2, "gauge", "deltaArrow", "enabled");
    var deltaArrow = deltaGroup.selectAll("svg.gauge-delta-arrow").data(delta !== null && arrowEnabled ? [delta] : []);
    deltaArrow.enter().append("svg").merge(deltaArrow).attr("class", "gauge-delta-arrow").attr("x", -arrowSize(radius) - deltaNumberWidth / 2).attr("y", -arrowSize(radius) / 2 - deltaFontSize(radius) * 0.35).attr("width", arrowSize(radius)).attr("height", arrowSize(radius)).attr("viewBox", "0 0 16 16").each(function() {
      var deltaArrowSelection = select(this);
      DOMUtils.appendOrSelect(deltaArrowSelection, "rect.gauge-delta-arrow-backdrop").attr("width", "16").attr("height", "16").attr("fill", "none");
      var status = Tools.getProperty(options2, "gauge", "status");
      DOMUtils.appendOrSelect(deltaArrowSelection, "polygon.gauge-delta-arrow").attr("class", status !== null ? "gauge-delta-arrow status--" + status : "").attr("points", self2.getArrow(delta));
    });
    deltaArrow.exit().remove();
    deltaNumber.exit().remove();
  };
  Gauge2.prototype.getInnerRadius = function() {
    var radius = this.computeRadius();
    var arcWidth = Tools.getProperty(this.getOptions(), "gauge", "arcWidth");
    return radius - arcWidth;
  };
  Gauge2.prototype.addEventListeners = function() {
    var self2 = this;
    this.parent.selectAll("path.arc-foreground").on("mouseover", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Gauge.ARC_MOUSEOVER, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mousemove", function(event, datum2) {
      var hoveredElement = select(this);
      self2.services.events.dispatchEvent(Events$1.Gauge.ARC_MOUSEMOVE, {
        event,
        element: hoveredElement,
        datum: datum2
      });
    }).on("click", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Gauge.ARC_CLICK, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mouseout", function(event, datum2) {
      var hoveredElement = select(this);
      self2.services.events.dispatchEvent(Events$1.Gauge.ARC_MOUSEOUT, {
        event,
        element: hoveredElement,
        datum: datum2
      });
    });
  };
  Gauge2.prototype.computeRadius = function() {
    var options2 = this.getOptions();
    var arcType = Tools.getProperty(options2, "gauge", "type");
    var _a2 = DOMUtils.getSVGElementSize(this.parent, {
      useAttrs: true
    }), width = _a2.width, height = _a2.height;
    var radius = arcType === GaugeTypes.SEMI ? Math.min(width / 2, height) : Math.min(width / 2, height / 2);
    return radius;
  };
  return Gauge2;
}(Component);
var __extends$_ = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Donut = function(_super) {
  __extends$_(Donut2, _super);
  function Donut2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "donut";
    _this.renderType = RenderTypes.SVG;
    return _this;
  }
  Donut2.prototype.render = function(animate) {
    var _this = this;
    if (animate === void 0) {
      animate = true;
    }
    _super.prototype.render.call(this, animate);
    var self2 = this;
    if (this.model.isDataEmpty()) {
      this.getComponentContainer().select("g.center").remove();
      return;
    }
    var svg = DOMUtils.appendOrSelect(this.getComponentContainer(), "g.center");
    var options2 = this.getOptions();
    var radius = this.computeRadius();
    var donutTitle = Tools.getProperty(options2, "donut", "center", "label");
    DOMUtils.appendOrSelect(svg, "text.donut-figure").attr("text-anchor", "middle").style("dominant-baseline", function() {
      if (donutTitle === null || donutTitle === "") {
        return "central";
      }
      return "initial";
    }).style("font-size", function() {
      return options2.donut.center.numberFontSize(radius);
    }).transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "donut-figure-enter-update",
        animate
      });
    }).tween("text", function() {
      return self2.centerNumberTween(select(this));
    });
    if (donutTitle !== null && donutTitle !== "") {
      DOMUtils.appendOrSelect(svg, "text.donut-title").attr("text-anchor", "middle").style("font-size", function() {
        return options2.donut.center.titleFontSize(radius);
      }).attr("y", options2.donut.center.titleYPosition(radius)).text(donutTitle);
    }
  };
  Donut2.prototype.getInnerRadius = function() {
    var radius = this.computeRadius();
    return radius * (3 / 4);
  };
  Donut2.prototype.centerNumberTween = function(d3Ref) {
    var options2 = this.getOptions();
    var donutCenterFigure = Tools.getProperty(options2, "donut", "center", "number");
    if (donutCenterFigure === null) {
      donutCenterFigure = this.model.getDisplayData().reduce(function(accumulator, d) {
        return accumulator + d[options2.pie.valueMapsTo];
      }, 0);
    }
    var currentValue = parseInt(d3Ref.text().replace(/[, ]+/g, ""), 10) || 0;
    var interpolateFunction;
    if (currentValue % 1 === 0 && donutCenterFigure % 1 === 0) {
      interpolateFunction = interpolateRound;
    } else {
      interpolateFunction = interpolateNumber;
    }
    var i = interpolateFunction(currentValue, donutCenterFigure);
    return function(t) {
      var numberFormatter = options2.donut.center.numberFormatter;
      d3Ref.text(numberFormatter(i(t)));
    };
  };
  return Donut2;
}(Pie);
var __extends$Z = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Skeleton = function(_super) {
  __extends$Z(Skeleton2, _super);
  function Skeleton2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "skeleton";
    return _this;
  }
  Skeleton2.prototype.render = function() {
    var isDataLoading = Tools.getProperty(this.getOptions(), "data", "loading");
    if (isDataLoading) {
      this.renderSkeleton(isDataLoading);
    } else {
      this.removeSkeleton();
    }
  };
  Skeleton2.prototype.renderSkeleton = function(showShimmerEffect) {
    if (this.configs.skeleton === Skeletons.GRID) {
      this.renderGridSkeleton(showShimmerEffect);
    } else if (this.configs.skeleton === Skeletons.VERT_OR_HORIZ) {
      this.renderVertOrHorizSkeleton(showShimmerEffect);
    } else if (this.configs.skeleton === Skeletons.PIE) {
      this.renderPieSkeleton(showShimmerEffect);
    } else if (this.configs.skeleton === Skeletons.DONUT) {
      this.renderDonutSkeleton(showShimmerEffect);
    } else {
      throw new Error('"' + this.configs.skeleton + '" is not a valid Skeleton type.');
    }
  };
  Skeleton2.prototype.renderGridSkeleton = function(showShimmerEffect) {
    this.setScales();
    this.drawBackdrop(showShimmerEffect);
    this.drawXGrid(showShimmerEffect);
    this.drawYGrid(showShimmerEffect);
    if (showShimmerEffect) {
      this.setShimmerEffect("shimmer-lines");
    }
  };
  Skeleton2.prototype.renderVertOrHorizSkeleton = function(showShimmerEffect) {
    var orientation = this.services.cartesianScales.getOrientation();
    this.setScales();
    this.drawBackdrop(showShimmerEffect);
    if (orientation === CartesianOrientations.VERTICAL) {
      this.drawYGrid(showShimmerEffect);
    }
    if (orientation === CartesianOrientations.HORIZONTAL) {
      this.drawXGrid(showShimmerEffect);
    }
    this.setShimmerEffect("shimmer-lines");
  };
  Skeleton2.prototype.renderPieSkeleton = function(showShimmerEffect) {
    var outerRadius = this.computeOuterRadius();
    var innerRadius = 0;
    this.drawRing(outerRadius, innerRadius, showShimmerEffect);
    if (showShimmerEffect) {
      this.setShimmerEffect("shimmer-areas");
    }
  };
  Skeleton2.prototype.renderDonutSkeleton = function(showShimmerEffect) {
    var outerRadius = this.computeOuterRadius();
    var innerRadius = this.computeInnerRadius();
    this.drawRing(outerRadius, innerRadius, showShimmerEffect);
    if (showShimmerEffect) {
      this.setShimmerEffect("shimmer-areas");
    }
  };
  Skeleton2.prototype.setScales = function() {
    var xRange = this.services.cartesianScales.getMainXScale().range();
    var yRange = this.services.cartesianScales.getMainYScale().range();
    this.xScale = linear().domain([0, 1]).range(xRange);
    this.yScale = linear().domain([0, 1]).range(yRange);
  };
  Skeleton2.prototype.drawBackdrop = function(showShimmerEffect) {
    var svg = this.parent;
    var _a2 = DOMUtils.getSVGElementSize(svg, {
      useAttrs: true
    }), width = _a2.width, height = _a2.height;
    this.backdrop = DOMUtils.appendOrSelect(svg, "svg.chart-skeleton.DAII").attr("width", width).attr("height", height);
    var backdropRect = DOMUtils.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop");
    backdropRect.attr("width", "100%").attr("height", "100%");
    var _b = this.xScale.range(), xScaleStart = _b[0];
    _b[1];
    var _c = this.yScale.range();
    _c[0];
    var yScaleStart = _c[1];
    this.backdrop.merge(backdropRect).attr("x", xScaleStart).attr("y", yScaleStart);
    backdropRect.classed("shimmer-effect-lines", showShimmerEffect).classed("empty-state-lines", !showShimmerEffect).style("stroke", showShimmerEffect ? "url(#" + this.services.domUtils.generateElementIDString("shimmer-lines") + ")" : null);
  };
  Skeleton2.prototype.drawXGrid = function(showShimmerEffect) {
    var width = this.backdrop.attr("width");
    var ticksNumber = Tools.getProperty(this.getOptions(), "grid", "x", "numberOfTicks");
    var ticksValues = this.xScale.ticks(ticksNumber).map(function(d) {
      return d * width;
    });
    var xGridG = DOMUtils.appendOrSelect(this.backdrop, "g.x.skeleton");
    var update = xGridG.selectAll("line").data(ticksValues);
    update.enter().append("line").merge(update).attr("x1", function(d) {
      return d;
    }).attr("x2", function(d) {
      return d;
    }).attr("y1", 0).attr("y2", "100%");
    xGridG.selectAll("line").classed("shimmer-effect-lines", showShimmerEffect).classed("empty-state-lines", !showShimmerEffect).style("stroke", showShimmerEffect ? "url(#" + this.services.domUtils.generateElementIDString("shimmer-lines") + ")" : null);
  };
  Skeleton2.prototype.drawYGrid = function(showShimmerEffect) {
    var height = this.backdrop.attr("height");
    var width = this.backdrop.attr("width");
    var ticksNumber = Tools.getProperty(this.getOptions(), "grid", "y", "numberOfTicks");
    var ticksValues = this.xScale.ticks(ticksNumber).map(function(d) {
      return d * height;
    });
    var yGridG = DOMUtils.appendOrSelect(this.backdrop, "g.y.skeleton");
    var update = yGridG.selectAll("line").data(ticksValues);
    update.enter().append("line").merge(update).attr("x1", 0).attr("x2", width).attr("y1", function(d) {
      return d;
    }).attr("y2", function(d) {
      return d;
    });
    yGridG.selectAll("line").classed("shimmer-effect-lines", showShimmerEffect).classed("empty-state-lines", !showShimmerEffect).style("stroke", showShimmerEffect ? "url(#" + this.services.domUtils.generateElementIDString("shimmer-lines") + ")" : null);
  };
  Skeleton2.prototype.drawRing = function(outerRadius, innerRadius, shimmer) {
    if (shimmer === void 0) {
      shimmer = true;
    }
    var svg = this.parent;
    var _a2 = DOMUtils.getSVGElementSize(svg, {
      useAttrs: true
    }), width = _a2.width, height = _a2.height;
    var container = DOMUtils.appendOrSelect(svg, "svg.chart-skeleton").attr("width", width).attr("height", height);
    var optionName = innerRadius === 0 ? "pie" : "donut";
    var alignment = Tools.getProperty(this.getOptions(), optionName, "alignment");
    DOMUtils.appendOrSelect(container, "rect.chart-skeleton-area-container").attr("width", width).attr("height", height).attr("fill", "none");
    var arcPathGenerator = arc().innerRadius(innerRadius).outerRadius(outerRadius).startAngle(0).endAngle(Math.PI * 2);
    var tcx = outerRadius + Math.abs(pie$1.radiusOffset);
    var tcy = outerRadius + (Math.min(width, height) - outerRadius * 2) / 2;
    var skeletonAreaShape = DOMUtils.appendOrSelect(container, "path").attr("class", "skeleton-area-shape").attr("transform", "translate(" + tcx + ", " + tcy + ")").attr("d", arcPathGenerator).classed("shimmer-effect-areas", shimmer).classed("empty-state-areas", !shimmer).style("fill", shimmer ? "url(#" + this.services.domUtils.generateElementIDString("shimmer-areas") + ")" : null);
    var translateX2 = outerRadius + pie$1.xOffset;
    if (alignment === Alignments.CENTER) {
      translateX2 = width / 2;
    } else if (alignment === Alignments.RIGHT) {
      translateX2 = width - outerRadius - pie$1.xOffset;
    }
    var translateY2 = outerRadius + pie$1.yOffset;
    skeletonAreaShape.attr("transform", "translate(" + translateX2 + ", " + translateY2 + ")");
  };
  Skeleton2.prototype.computeOuterRadius = function() {
    var _a2 = DOMUtils.getSVGElementSize(this.parent, {
      useAttrs: true
    }), width = _a2.width, height = _a2.height;
    var radius = Math.min(width, height) / 2;
    return radius + pie$1.radiusOffset;
  };
  Skeleton2.prototype.computeInnerRadius = function() {
    return this.computeOuterRadius() * (3 / 4);
  };
  Skeleton2.prototype.setShimmerEffect = function(gradientId) {
    var animationDuration = 2e3;
    var delay = 1e3;
    var shimmerWidth = 0.2;
    var stopBgShimmerClass = "stop-bg-shimmer";
    var stopShimmerClass = "stop-shimmer";
    var container = this.parent.select(".chart-skeleton");
    var width = DOMUtils.getSVGElementSize(this.parent, {
      useAttrs: true
    }).width;
    var startPoint = 0;
    var endPoint = width;
    var defs = DOMUtils.appendOrSelect(container, "defs").lower();
    var linearGradient = DOMUtils.appendOrSelect(defs, "linearGradient").attr("id", this.services.domUtils.generateElementIDString(gradientId)).attr("class", gradientId).attr("x1", startPoint - 3 * shimmerWidth * width).attr("x2", endPoint).attr("y1", 0).attr("y2", 0).attr("gradientUnits", "userSpaceOnUse").attr("gradientTransform", "translate(0, 0)");
    var stops = '\n			<stop class="' + stopBgShimmerClass + '" offset="' + startPoint + '"></stop>\n			<stop class="' + stopShimmerClass + '" offset="' + (startPoint + shimmerWidth) + '"></stop>\n			<stop class="' + stopBgShimmerClass + '" offset="' + (startPoint + 2 * shimmerWidth) + '"></stop>\n		';
    linearGradient.html(stops);
    repeat();
    function repeat() {
      linearGradient.attr("gradientTransform", "translate(" + (startPoint - 3 * shimmerWidth * width) + ", 0)").transition().duration(animationDuration).delay(delay).ease(linear$2).attr("gradientTransform", "translate(" + (endPoint + 3 * shimmerWidth * width) + ", 0)").on("end", repeat);
    }
  };
  Skeleton2.prototype.removeSkeleton = function() {
    var container = this.parent.select(".chart-skeleton");
    container.remove();
  };
  return Skeleton2;
}(Component);
var __extends$Y = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SkeletonLines = function(_super) {
  __extends$Y(SkeletonLines2, _super);
  function SkeletonLines2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "skeleton-lines";
    return _this;
  }
  SkeletonLines2.prototype.render = function() {
    var isDataLoading = Tools.getProperty(this.getOptions(), "data", "loading");
    var isSparkline = !Tools.getProperty(this.getOptions(), "grid", "x", "enabled") && !Tools.getProperty(this.getOptions(), "grid", "y", "enabled") && !Tools.getProperty(this.getOptions(), "axes", "bottom", "visible") && !Tools.getProperty(this.getOptions(), "axes", "left", "visible");
    if (isDataLoading && !isSparkline) {
      _super.prototype.renderGridSkeleton.call(this, isDataLoading);
    } else if (isDataLoading && isSparkline) {
      this.renderSparklineSkeleton(isDataLoading);
    } else {
      this.removeSkeleton();
    }
  };
  SkeletonLines2.prototype.renderSparklineSkeleton = function(showShimmerEffect) {
    this.setScales();
    this.drawBackdrop(showShimmerEffect);
    this.drawSparkline(showShimmerEffect);
    this.updateBackdropStyle();
    if (showShimmerEffect) {
      this.setShimmerEffect("shimmer-lines");
    }
  };
  SkeletonLines2.prototype.drawSparkline = function(showShimmerEffect) {
    var width = this.backdrop.attr("width");
    var ticksValues = [100];
    var sparklineSkeleton = DOMUtils.appendOrSelect(this.backdrop, "g.y.skeleton");
    var update = sparklineSkeleton.selectAll("line").data(ticksValues);
    update.enter().append("line").merge(update).attr("x1", 0).attr("x2", width).attr("y1", function(d) {
      return d;
    }).attr("y2", function(d) {
      return d;
    });
    sparklineSkeleton.selectAll("line").classed("shimmer-effect-lines", showShimmerEffect).classed("empty-state-lines", !showShimmerEffect).style("stroke", showShimmerEffect ? "url(#" + this.services.domUtils.generateElementIDString("shimmer-lines") + ")" : null);
  };
  SkeletonLines2.prototype.updateBackdropStyle = function() {
    var svg = this.parent;
    this.backdrop = DOMUtils.appendOrSelect(svg, "svg.chart-skeleton.DAII");
    var backdropRect = DOMUtils.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop");
    backdropRect.classed("shimmer-effect-lines", false).classed("shimmer-effect-sparkline", true).style("stroke", null);
  };
  return SkeletonLines2;
}(Skeleton);
function defaultSeparation$1(a, b) {
  return a.parent === b.parent ? 1 : 2;
}
function meanX(children2) {
  return children2.reduce(meanXReduce, 0) / children2.length;
}
function meanXReduce(x2, c) {
  return x2 + c.x;
}
function maxY(children2) {
  return 1 + children2.reduce(maxYReduce, 0);
}
function maxYReduce(y2, c) {
  return Math.max(y2, c.y);
}
function leafLeft(node) {
  var children2;
  while (children2 = node.children)
    node = children2[0];
  return node;
}
function leafRight(node) {
  var children2;
  while (children2 = node.children)
    node = children2[children2.length - 1];
  return node;
}
function d3Cluster() {
  var separation = defaultSeparation$1, dx = 1, dy = 1, nodeSize = false;
  function cluster(root2) {
    var previousNode, x2 = 0;
    root2.eachAfter(function(node) {
      var children2 = node.children;
      if (children2) {
        node.x = meanX(children2);
        node.y = maxY(children2);
      } else {
        node.x = previousNode ? x2 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left2 = leafLeft(root2), right2 = leafRight(root2), x0 = left2.x - separation(left2, right2) / 2, x1 = right2.x + separation(right2, left2) / 2;
    return root2.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root2.x) * dx;
      node.y = (root2.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root2.y ? node.y / root2.y : 1)) * dy;
    });
  }
  cluster.separation = function(x2) {
    return arguments.length ? (separation = x2, cluster) : separation;
  };
  cluster.size = function(x2) {
    return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], cluster) : nodeSize ? null : [dx, dy];
  };
  cluster.nodeSize = function(x2) {
    return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], cluster) : nodeSize ? [dx, dy] : null;
  };
  return cluster;
}
function count(node) {
  var sum2 = 0, children2 = node.children, i = children2 && children2.length;
  if (!i)
    sum2 = 1;
  else
    while (--i >= 0)
      sum2 += children2[i].value;
  node.value = sum2;
}
function node_count() {
  return this.eachAfter(count);
}
function node_each(callback, that) {
  let index2 = -1;
  for (const node of this) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}
function node_eachBefore(callback, that) {
  var node = this, nodes = [node], children2, i, index2 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index2, this);
    if (children2 = node.children) {
      for (i = children2.length - 1; i >= 0; --i) {
        nodes.push(children2[i]);
      }
    }
  }
  return this;
}
function node_eachAfter(callback, that) {
  var node = this, nodes = [node], next = [], children2, i, n, index2 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children2 = node.children) {
      for (i = 0, n = children2.length; i < n; ++i) {
        nodes.push(children2[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}
function node_find(callback, that) {
  let index2 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index2, this)) {
      return node;
    }
  }
}
function node_sum(value2) {
  return this.eachAfter(function(node) {
    var sum2 = +value2(node.data) || 0, children2 = node.children, i = children2 && children2.length;
    while (--i >= 0)
      sum2 += children2[i].value;
    node.value = sum2;
  });
}
function node_sort(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}
function node_path(end) {
  var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes = [start2];
  while (start2 !== ancestor) {
    start2 = start2.parent;
    nodes.push(start2);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a, b) {
  if (a === b)
    return a;
  var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}
function node_ancestors() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}
function node_descendants() {
  return Array.from(this);
}
function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}
function node_links() {
  var root2 = this, links = [];
  root2.each(function(node) {
    if (node !== root2) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}
function* node_iterator() {
  var node = this, current, next = [node], children2, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children2 = node.children) {
        for (i = 0, n = children2.length; i < n; ++i) {
          next.push(children2[i]);
        }
      }
    }
  } while (next.length);
}
function hierarchy(data, children2) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children2 === void 0)
      children2 = mapChildren;
  } else if (children2 === void 0) {
    children2 = objectChildren;
  }
  var root2 = new Node$2(data), node, nodes = [root2], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children2(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node$2(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node$2(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node$2.prototype = hierarchy.prototype = {
  constructor: Node$2,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  find: node_find,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy,
  [Symbol.iterator]: node_iterator
};
function array(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
function shuffle(array2) {
  var m = array2.length, t, i;
  while (m) {
    i = Math.random() * m-- | 0;
    t = array2[m];
    array2[m] = array2[i];
    array2[i] = t;
  }
  return array2;
}
function enclose(circles) {
  var i = 0, n = (circles = shuffle(Array.from(circles))).length, B = [], p, e;
  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p))
      ++i;
    else
      e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }
  return e;
}
function extendBasis(B, p) {
  var i, j;
  if (enclosesWeakAll(p, B))
    return [p];
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a, b) {
  var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B) {
  switch (B.length) {
    case 1:
      return encloseBasis1(B[0]);
    case 2:
      return encloseBasis2(B[0], B[1]);
    case 3:
      return encloseBasis3(B[0], B[1], B[2]);
  }
}
function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}
function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x3 = c.x, y3 = c.y, r3 = c.r, a2 = x1 - x2, a3 = x1 - x3, b2 = y1 - y2, b3 = y1 - y3, c2 = r2 - r1, c3 = r3 - r1, d1 = x1 * x1 + y1 * y1 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b2 - a2 * b3, xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1, xb = (b3 * c2 - b2 * c3) / ab, ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1, yb = (a2 * c3 - a3 * c2) / ab, A = xb * xb + yb * yb - 1, B = 2 * (r1 + xa * xb + ya * yb), C = xa * xa + ya * ya - r1 * r1, r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r
  };
}
function place(b, a, c) {
  var dx = b.x - a.x, x2, a2, dy = b.y - a.y, y2, b2, d2 = dx * dx + dy * dy;
  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b2 = b.r + c.r, b2 *= b2;
    if (a2 > b2) {
      x2 = (d2 + b2 - a2) / (2 * d2);
      y2 = Math.sqrt(Math.max(0, b2 / d2 - x2 * x2));
      c.x = b.x - x2 * dx - y2 * dy;
      c.y = b.y - x2 * dy + y2 * dx;
    } else {
      x2 = (d2 + a2 - b2) / (2 * d2);
      y2 = Math.sqrt(Math.max(0, a2 / d2 - x2 * x2));
      c.x = a.x + x2 * dx - y2 * dy;
      c.y = a.y + x2 * dy + y2 * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}
function intersects(a, b) {
  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a = node._, b = node.next._, ab = a.r + b.r, dx = (a.x * b.r + b.x * a.r) / ab, dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}
function Node$1(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}
function packEnclose(circles) {
  if (!(n = (circles = array(circles)).length))
    return 0;
  var a, b, c, n, aa, ca, i, j, k, sj, sk;
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1))
    return a.r;
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2))
    return a.r + b.r;
  place(b, a, c = circles[2]);
  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;
  pack:
    for (i = 3; i < n; ++i) {
      place(a._, b._, c = circles[i]), c = new Node$1(c);
      j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c._)) {
            b = j, a.next = b, b.previous = a, --i;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k._, c._)) {
            a = k, a.next = b, b.previous = a, --i;
            continue pack;
          }
          sk += k._.r, k = k.previous;
        }
      } while (j !== k.next);
      c.previous = a, c.next = b, a.next = b.previous = b = c;
      aa = score(a);
      while ((c = c.next) !== b) {
        if ((ca = score(c)) < aa) {
          a = c, aa = ca;
        }
      }
      b = a.next;
    }
  a = [b._], c = b;
  while ((c = c.next) !== b)
    a.push(c._);
  c = enclose(a);
  for (i = 0; i < n; ++i)
    a = circles[i], a.x -= c.x, a.y -= c.y;
  return c.r;
}
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function")
    throw new Error();
  return f;
}
function constantZero() {
  return 0;
}
function constant$3(x2) {
  return function() {
    return x2;
  };
}
function defaultRadius(d) {
  return Math.sqrt(d.value);
}
function D3Pack() {
  var radius = null, dx = 1, dy = 1, padding = constantZero;
  function pack(root2) {
    root2.x = dx / 2, root2.y = dy / 2;
    if (radius) {
      root2.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding, 0.5)).eachBefore(translateChild(1));
    } else {
      root2.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding, root2.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root2.r)));
    }
    return root2;
  }
  pack.radius = function(x2) {
    return arguments.length ? (radius = optional(x2), pack) : radius;
  };
  pack.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], pack) : [dx, dy];
  };
  pack.padding = function(x2) {
    return arguments.length ? (padding = typeof x2 === "function" ? x2 : constant$3(+x2), pack) : padding;
  };
  return pack;
}
function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}
function packChildren(padding, k) {
  return function(node) {
    if (children2 = node.children) {
      var children2, i, n = children2.length, r = padding(node) * k || 0, e;
      if (r)
        for (i = 0; i < n; ++i)
          children2[i].r += r;
      e = packEnclose(children2);
      if (r)
        for (i = 0; i < n; ++i)
          children2[i].r -= r;
      node.r = e + r;
    }
  };
}
function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}
function roundNode(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}
function treemapDice(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x1 - x0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}
function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}
function nextLeft(v) {
  var children2 = v.children;
  return children2 ? children2[0] : v.t;
}
function nextRight(v) {
  var children2 = v.children;
  return children2 ? children2[children2.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v) {
  var shift = 0, change = 0, children2 = v.children, i = children2.length, w;
  while (--i >= 0) {
    w = children2[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node$2.prototype);
function treeRoot(root2) {
  var tree = new TreeNode(root2, 0), node, nodes = [tree], child, children2, i, n;
  while (node = nodes.pop()) {
    if (children2 = node._.children) {
      node.children = new Array(n = children2.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children2[i], i));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function d3Tree() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = null;
  function tree(root2) {
    var t = treeRoot(root2);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize)
      root2.eachBefore(sizeNode);
    else {
      var left2 = root2, right2 = root2, bottom2 = root2;
      root2.eachBefore(function(node) {
        if (node.x < left2.x)
          left2 = node;
        if (node.x > right2.x)
          right2 = node;
        if (node.depth > bottom2.depth)
          bottom2 = node;
      });
      var s = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s - left2.x, kx = dx / (right2.x + s + tx), ky = dy / (bottom2.depth || 1);
      root2.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }
    return root2;
  }
  function firstWalk(v) {
    var children2 = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
    if (children2) {
      executeShifts(v);
      var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x2) {
    return arguments.length ? (separation = x2, tree) : separation;
  };
  tree.size = function(x2) {
    return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x2) {
    return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}
function treemapSlice(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y1 - y0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value2 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      treemapDice(row, x0, y0, x1, value2 ? y0 += dy * sumValue / value2 : y1);
    else
      treemapSlice(row, x0, y0, value2 ? x0 += dx * sumValue / value2 : x1, y1);
    value2 -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify = function custom8(ratio) {
  function squarify2(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }
  squarify2.ratio = function(x2) {
    return custom8((x2 = +x2) > 1 ? x2 : 1);
  };
  return squarify2;
}(phi);
function d3Treemap() {
  var tile = squarify, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root2) {
    root2.x0 = root2.y0 = 0;
    root2.x1 = dx;
    root2.y1 = dy;
    root2.eachBefore(positionNode);
    paddingStack = [0];
    if (round)
      root2.eachBefore(roundNode);
    return root2;
  }
  function positionNode(node) {
    var p = paddingStack[node.depth], x0 = node.x0 + p, y0 = node.y0 + p, x1 = node.x1 - p, y1 = node.y1 - p;
    if (x1 < x0)
      x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0)
      y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0)
        x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0)
        y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }
  treemap.round = function(x2) {
    return arguments.length ? (round = !!x2, treemap) : round;
  };
  treemap.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x2) {
    return arguments.length ? (tile = required(x2), treemap) : tile;
  };
  treemap.padding = function(x2) {
    return arguments.length ? treemap.paddingInner(x2).paddingOuter(x2) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x2) {
    return arguments.length ? (paddingInner = typeof x2 === "function" ? x2 : constant$3(+x2), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x2) {
    return arguments.length ? treemap.paddingTop(x2).paddingRight(x2).paddingBottom(x2).paddingLeft(x2) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x2) {
    return arguments.length ? (paddingTop = typeof x2 === "function" ? x2 : constant$3(+x2), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x2) {
    return arguments.length ? (paddingRight = typeof x2 === "function" ? x2 : constant$3(+x2), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x2) {
    return arguments.length ? (paddingBottom = typeof x2 === "function" ? x2 : constant$3(+x2), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x2) {
    return arguments.length ? (paddingLeft = typeof x2 === "function" ? x2 : constant$3(+x2), treemap) : paddingLeft;
  };
  return treemap;
}
var __extends$X = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var NODE_OFFSET = 6;
var Tree = function(_super) {
  __extends$X(Tree2, _super);
  function Tree2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "tree";
    _this.renderType = RenderTypes.SVG;
    return _this;
  }
  Tree2.prototype.getLongestLabel = function(data) {
    var _this = this;
    var longestLabel = "";
    data.forEach(function(d) {
      var longestLabelInChildren = d.children ? _this.getLongestLabel(d.children) : "";
      if (longestLabelInChildren.length > longestLabel.length || d.name.length > longestLabel.length) {
        longestLabel = longestLabelInChildren.length > d.name.length ? longestLabelInChildren : d.name;
      }
    });
    return longestLabel;
  };
  Tree2.prototype.getMockLabelWidth = function(svg, label) {
    var mockLabel = svg.append("text").attr("dy", "0.31em").attr("x", 0).attr("text-anchor", "end").text(label);
    var mockLabelWidth = DOMUtils.getSVGElementSize(mockLabel.node(), {
      useBBox: true
    }).width;
    mockLabel.remove();
    return mockLabelWidth;
  };
  Tree2.prototype.render = function(animate) {
    var _this = this;
    var svg = this.getComponentContainer();
    svg.html("");
    var _a2 = DOMUtils.getSVGElementSize(this.parent, {
      useAttrs: true
    }), width = _a2.width, height = _a2.height;
    if (width < 1 || height < 1) {
      return;
    }
    var options2 = this.model.getOptions();
    var displayData = this.model.getDisplayData();
    var rootTitle = Tools.getProperty(options2, "tree", "rootTitle") || "Tree";
    var mockRootTitleWidth = this.getMockLabelWidth(svg, rootTitle);
    var longestLabel = this.getLongestLabel(displayData);
    var mockLongestLabelWidth = this.getMockLabelWidth(svg, longestLabel);
    var margin = {
      top: 0,
      right: 0,
      bottom: 0,
      left: mockRootTitleWidth > 0 ? mockRootTitleWidth + NODE_OFFSET : 30 - NODE_OFFSET
    };
    var root2 = hierarchy({
      name: rootTitle,
      children: displayData
    });
    var dx = 10;
    var dy = width / 6;
    var update = function(source) {
      var nodes = root2.descendants().reverse();
      var links = root2.links();
      var left2 = root2;
      var right2 = root2;
      root2.eachBefore(function(node) {
        if (node.x < left2.x)
          left2 = node;
        if (node.x > right2.x)
          right2 = node;
      });
      var height2 = right2.x - left2.x;
      var transition = svg.transition().call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "tree-update-viewbox",
          animate: true
        });
      }).attr("viewBox", [-margin.left, left2.x, width, height2]);
      var nodeGroups = nodeGroup.selectAll("g").data(nodes, function(d) {
        return d.id;
      });
      var self2 = _this;
      var nodeGroupsEnter = nodeGroups.enter().append("g").attr("transform", function() {
        return "translate(" + source.y0 + "," + source.x0 + ")";
      }).attr("class", function(d) {
        return d.depth !== 0 && d.children && d.children.length > 0 ? "clickable" : null;
      }).on("mouseover", function(event, d) {
        self2.services.events.dispatchEvent(Events$1.Tree.NODE_MOUSEOVER, {
          event,
          element: select(this),
          datum: d
        });
      }).on("click", function(event, d) {
        if (d.depth !== 0) {
          d.children = d.children ? null : d._children;
          update(d);
        }
        self2.services.events.dispatchEvent(Events$1.Tree.NODE_CLICK, {
          event,
          element: select(this),
          datum: d
        });
      }).on("mouseout", function(event, d) {
        self2.services.events.dispatchEvent(Events$1.Tree.NODE_MOUSEOUT, {
          event,
          element: select(this),
          datum: d
        });
      });
      nodeGroupsEnter.append("circle").attr("r", 2.5).attr("class", function(d) {
        return d._children ? "parent" : "child";
      }).attr("stroke-width", 10);
      nodeGroupsEnter.append("text").attr("dy", "0.31em").attr("x", function(d) {
        return d._children ? -NODE_OFFSET : NODE_OFFSET;
      }).attr("text-anchor", function(d) {
        return d._children ? "end" : "start";
      }).text(function(d) {
        return d.data.name;
      }).clone(true).attr("class", "text-stroke").lower();
      nodeGroups.merge(nodeGroupsEnter).transition(transition).attr("transform", function(d) {
        return "translate(" + d.y + "," + d.x + ")";
      }).attr("fill-opacity", 1).attr("stroke-opacity", 1);
      nodeGroups.exit().transition(transition).remove().attr("transform", function() {
        return "translate(" + source.y + "," + source.x + ")";
      }).attr("fill-opacity", 0).attr("stroke-opacity", 0);
      var linkPaths = linkGroup.selectAll("path").data(links, function(d) {
        return d.target.id;
      });
      var linkPathsEnter = linkPaths.enter().append("path").attr("d", function(d) {
        var o = { x: source.x0, y: source.y0 };
        return diagonal({ source: o, target: o });
      });
      linkPaths.merge(linkPathsEnter).transition(transition).attr("d", diagonal);
      linkPaths.exit().transition(transition).remove().attr("d", function() {
        var o = { x: source.x, y: source.y };
        return diagonal({ source: o, target: o });
      });
      root2.eachBefore(function(d) {
        d.x0 = d.x;
        d.y0 = d.y;
      });
    };
    var descendants = root2.descendants();
    var maxDepth = descendants[descendants.length - 1].depth;
    var tree = Tools.getProperty(options2, "tree", "type") === TreeTypes.DENDROGRAM ? d3Cluster().size([
      height,
      width - mockLongestLabelWidth - maxDepth * NODE_OFFSET - mockRootTitleWidth
    ]) : d3Tree().nodeSize([dx, dy]).size([
      height,
      width - mockLongestLabelWidth - maxDepth * NODE_OFFSET - mockRootTitleWidth
    ]);
    var diagonal = linkHorizontal$1().x(function(d) {
      return d.y;
    }).y(function(d) {
      return d.x;
    });
    root2.x0 = dy / 2;
    root2.y0 = 0;
    root2.descendants().forEach(function(d, i) {
      d.id = i;
      d._children = d.children;
    });
    tree(root2);
    svg.attr("viewBox", [-margin.left, -margin.top, width, dx]).style("user-select", "none");
    var linkGroup = svg.append("g").attr("class", "links");
    var nodeGroup = svg.append("g").attr("class", "nodes");
    update(root2);
  };
  return Tree2;
}(Component);
var black = "#000000";
var white = "#ffffff";
var yellow10 = "#fcf4d6";
var yellow20 = "#fddc69";
var yellow30 = "#f1c21b";
var yellow40 = "#d2a106";
var yellow50 = "#b28600";
var yellow60 = "#8e6a00";
var yellow70 = "#684e00";
var yellow80 = "#483700";
var yellow90 = "#302400";
var yellow100 = "#1c1500";
var unstable_yellow = {
  10: yellow10,
  20: yellow20,
  30: yellow30,
  40: yellow40,
  50: yellow50,
  60: yellow60,
  70: yellow70,
  80: yellow80,
  90: yellow90,
  100: yellow100
};
var orange10 = "#fff2e8";
var orange20 = "#ffd9be";
var orange30 = "#ffb784";
var orange40 = "#ff832b";
var orange50 = "#eb6200";
var orange60 = "#ba4e00";
var orange70 = "#8a3800";
var orange80 = "#5e2900";
var orange90 = "#3e1a00";
var orange100 = "#231000";
var unstable_orange = {
  10: orange10,
  20: orange20,
  30: orange30,
  40: orange40,
  50: orange50,
  60: orange60,
  70: orange70,
  80: orange80,
  90: orange90,
  100: orange100
};
var red10 = "#fff1f1";
var red20 = "#ffd7d9";
var red30 = "#ffb3b8";
var red40 = "#ff8389";
var red50 = "#fa4d56";
var red60 = "#da1e28";
var red70 = "#a2191f";
var red80 = "#750e13";
var red90 = "#520408";
var red100 = "#2d0709";
var red = {
  10: red10,
  20: red20,
  30: red30,
  40: red40,
  50: red50,
  60: red60,
  70: red70,
  80: red80,
  90: red90,
  100: red100
};
var magenta10 = "#fff0f7";
var magenta20 = "#ffd6e8";
var magenta30 = "#ffafd2";
var magenta40 = "#ff7eb6";
var magenta50 = "#ee5396";
var magenta60 = "#d02670";
var magenta70 = "#9f1853";
var magenta80 = "#740937";
var magenta90 = "#510224";
var magenta100 = "#2a0a18";
var magenta = {
  10: magenta10,
  20: magenta20,
  30: magenta30,
  40: magenta40,
  50: magenta50,
  60: magenta60,
  70: magenta70,
  80: magenta80,
  90: magenta90,
  100: magenta100
};
var purple10 = "#f6f2ff";
var purple20 = "#e8daff";
var purple30 = "#d4bbff";
var purple40 = "#be95ff";
var purple50 = "#a56eff";
var purple60 = "#8a3ffc";
var purple70 = "#6929c4";
var purple80 = "#491d8b";
var purple90 = "#31135e";
var purple100 = "#1c0f30";
var purple = {
  10: purple10,
  20: purple20,
  30: purple30,
  40: purple40,
  50: purple50,
  60: purple60,
  70: purple70,
  80: purple80,
  90: purple90,
  100: purple100
};
var blue10 = "#edf5ff";
var blue20 = "#d0e2ff";
var blue30 = "#a6c8ff";
var blue40 = "#78a9ff";
var blue50 = "#4589ff";
var blue60 = "#0f62fe";
var blue70 = "#0043ce";
var blue80 = "#002d9c";
var blue90 = "#001d6c";
var blue100 = "#001141";
var blue = {
  10: blue10,
  20: blue20,
  30: blue30,
  40: blue40,
  50: blue50,
  60: blue60,
  70: blue70,
  80: blue80,
  90: blue90,
  100: blue100
};
var cyan10 = "#e5f6ff";
var cyan20 = "#bae6ff";
var cyan30 = "#82cfff";
var cyan40 = "#33b1ff";
var cyan50 = "#1192e8";
var cyan60 = "#0072c3";
var cyan70 = "#00539a";
var cyan80 = "#003a6d";
var cyan90 = "#012749";
var cyan100 = "#061727";
var cyan = {
  10: cyan10,
  20: cyan20,
  30: cyan30,
  40: cyan40,
  50: cyan50,
  60: cyan60,
  70: cyan70,
  80: cyan80,
  90: cyan90,
  100: cyan100
};
var teal10 = "#d9fbfb";
var teal20 = "#9ef0f0";
var teal30 = "#3ddbd9";
var teal40 = "#08bdba";
var teal50 = "#009d9a";
var teal60 = "#007d79";
var teal70 = "#005d5d";
var teal80 = "#004144";
var teal90 = "#022b30";
var teal100 = "#081a1c";
var teal = {
  10: teal10,
  20: teal20,
  30: teal30,
  40: teal40,
  50: teal50,
  60: teal60,
  70: teal70,
  80: teal80,
  90: teal90,
  100: teal100
};
var green10 = "#defbe6";
var green20 = "#a7f0ba";
var green30 = "#6fdc8c";
var green40 = "#42be65";
var green50 = "#24a148";
var green60 = "#198038";
var green70 = "#0e6027";
var green80 = "#044317";
var green90 = "#022d0d";
var green100 = "#071908";
var green = {
  10: green10,
  20: green20,
  30: green30,
  40: green40,
  50: green50,
  60: green60,
  70: green70,
  80: green80,
  90: green90,
  100: green100
};
var coolGray10 = "#f2f4f8";
var coolGray20 = "#dde1e6";
var coolGray30 = "#c1c7cd";
var coolGray40 = "#a2a9b0";
var coolGray50 = "#878d96";
var coolGray60 = "#697077";
var coolGray70 = "#4d5358";
var coolGray80 = "#343a3f";
var coolGray90 = "#21272a";
var coolGray100 = "#121619";
var coolGray = {
  10: coolGray10,
  20: coolGray20,
  30: coolGray30,
  40: coolGray40,
  50: coolGray50,
  60: coolGray60,
  70: coolGray70,
  80: coolGray80,
  90: coolGray90,
  100: coolGray100
};
var gray10 = "#f4f4f4";
var gray20 = "#e0e0e0";
var gray30 = "#c6c6c6";
var gray40 = "#a8a8a8";
var gray50 = "#8d8d8d";
var gray60 = "#6f6f6f";
var gray70 = "#525252";
var gray80 = "#393939";
var gray90 = "#262626";
var gray100 = "#161616";
var gray = {
  10: gray10,
  20: gray20,
  30: gray30,
  40: gray40,
  50: gray50,
  60: gray60,
  70: gray70,
  80: gray80,
  90: gray90,
  100: gray100
};
var warmGray10 = "#f7f3f2";
var warmGray20 = "#e5e0df";
var warmGray30 = "#cac5c4";
var warmGray40 = "#ada8a8";
var warmGray50 = "#8f8b8b";
var warmGray60 = "#726e6e";
var warmGray70 = "#565151";
var warmGray80 = "#3c3838";
var warmGray90 = "#272525";
var warmGray100 = "#171414";
var warmGray = {
  10: warmGray10,
  20: warmGray20,
  30: warmGray30,
  40: warmGray40,
  50: warmGray50,
  60: warmGray60,
  70: warmGray70,
  80: warmGray80,
  90: warmGray90,
  100: warmGray100
};
var colors = {
  black: {
    100: black
  },
  blue,
  coolGray,
  cyan,
  gray,
  green,
  magenta,
  orange: unstable_orange,
  purple,
  red,
  teal,
  warmGray,
  white: {
    0: white
  },
  yellow: unstable_yellow
};
var __extends$W = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var findColorShade = function(hex2) {
  if (!hex2) {
    return null;
  }
  for (var _i = 0, _a2 = Object.keys(colors); _i < _a2.length; _i++) {
    var colorName = _a2[_i];
    var colorShades = colors[colorName];
    for (var _b = 0, _c = Object.keys(colorShades); _b < _c.length; _b++) {
      var colorShadeLevel = _c[_b];
      var colorShade = colorShades[colorShadeLevel];
      if (colorShade === hex2) {
        return colorShadeLevel;
      }
    }
  }
  return null;
};
var textFillColor = function() {
  var correspondingLeaf = select(this.parentNode).select("rect.leaf");
  var correspondingLeafFill = getComputedStyle(correspondingLeaf.node(), null).getPropertyValue("fill");
  var cl = color(correspondingLeafFill);
  var colorShade;
  if (cl) {
    colorShade = findColorShade(cl ? cl.hex() : null);
  }
  if (colorShade === null || colorShade === void 0) {
    var lightness = hsl(cl).l;
    colorShade = Math.abs(lightness * 100 - 100);
  }
  return colorShade > 50 ? "white" : "black";
};
var uidCounter = 0;
var Treemap = function(_super) {
  __extends$W(Treemap2, _super);
  function Treemap2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "treemap";
    _this.renderType = RenderTypes.SVG;
    _this.handleLegendOnHover = function(event) {
      var hoveredElement = event.detail.hoveredElement;
      _this.parent.selectAll("g[data-name='leaf']").transition("legend-hover-treemap").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-hover-treemap"
        });
      }).attr("opacity", function(d) {
        return d.parent.data.name === hoveredElement.datum()["name"] ? 1 : 0.3;
      });
    };
    _this.handleLegendMouseOut = function(event) {
      _this.parent.selectAll("g[data-name='leaf']").transition("legend-mouseout-treemap").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-treemap"
        });
      }).attr("opacity", 1);
    };
    return _this;
  }
  Treemap2.prototype.init = function() {
    var events = this.services.events;
    events.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    events.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  Treemap2.prototype.render = function(animate) {
    var _this = this;
    if (animate === void 0) {
      animate = true;
    }
    var svg = this.getComponentContainer();
    this.model.getData();
    var displayData = this.model.getDisplayData();
    var options2 = this.model.getOptions();
    var windowLocation = Tools.getProperty(window, "location");
    var _a2 = DOMUtils.getSVGElementSize(svg, {
      useAttrs: true
    }), width = _a2.width, height = _a2.height;
    var hierarchy$1 = hierarchy({
      name: options2.title || "Treemap",
      children: displayData
    }).sum(function(d) {
      return d.value;
    }).sort(function(a, b) {
      return b.value - a.value;
    });
    var root2 = d3Treemap().size([width, height]).paddingInner(1).paddingOuter(0).round(true)(hierarchy$1);
    this.services.transitions;
    var leafGroups = svg.selectAll("g[data-name='leaf']").data(root2.leaves(), function(leaf) {
      return leaf.data.name;
    });
    leafGroups.exit().attr("opacity", 0).remove();
    var enteringLeafGroups = leafGroups.enter().append("g").attr("data-name", "leaf").attr("data-uid", function() {
      return uidCounter++;
    });
    var allLeafGroups = enteringLeafGroups.merge(leafGroups);
    allLeafGroups.attr("data-name", "leaf").transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "treemap-group-update",
        animate
      });
    }).attr("transform", function(d) {
      return "translate(" + d.x0 + "," + d.y0 + ")";
    });
    var rects = allLeafGroups.selectAll("rect.leaf").data(function(d) {
      return [d];
    });
    rects.exit().attr("width", 0).attr("height", 0).remove();
    var enteringRects = rects.enter().append("rect").classed("leaf", true);
    enteringRects.merge(rects).attr("width", 0).attr("height", 0).attr("id", function() {
      var uid = select(this.parentNode).attr("data-uid");
      return options2.style.prefix + "-leaf-" + uid;
    }).attr("class", function(d) {
      while (d.depth > 1)
        d = d.parent;
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.FILL],
        dataGroupName: d.data.name,
        originalClassName: "leaf"
      });
    }).transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "treemap-leaf-update-enter",
        animate
      });
    }).attr("width", function(d) {
      return d.x1 - d.x0;
    }).attr("height", function(d) {
      return d.y1 - d.y0;
    }).style("fill", function(d) {
      while (d.depth > 1)
        d = d.parent;
      return _this.model.getFillColor(d.data.name);
    });
    allLeafGroups.selectAll("clipPath").data(function(d) {
      if (d.data.showLabel !== true) {
        return [];
      }
      return [1];
    }, function(d) {
      return d;
    }).join(function(enter) {
      enter.append("clipPath").attr("id", function() {
        var uid = select(this.parentNode).attr("data-uid");
        return options2.style.prefix + "-clip-" + uid;
      }).append("use").attr("xlink:href", function() {
        var uid = select(this.parentNode.parentNode).attr("data-uid");
        var leafID = options2.style.prefix + "-leaf-" + uid;
        return new URL("#" + leafID, windowLocation) + "";
      });
    }, function(update) {
      return null;
    }, function(exit) {
      return exit.remove();
    });
    allLeafGroups.selectAll("text").data(function(d) {
      if (d.data.showLabel !== true) {
        return [];
      }
      var parent = d;
      while (parent.depth > 1)
        parent = parent.parent;
      var color2 = hsl(_this.model.getFillColor(parent.data.name));
      return [
        {
          text: d.data.name,
          color: color2.l < 0.5 ? "white" : "black"
        }
      ];
    }, function(d) {
      return d;
    }).join(function(enter) {
      var addedText = enter.append("text").text(function(d) {
        return d.text;
      }).style("fill", textFillColor).attr("x", 7).attr("y", 18);
      if (windowLocation) {
        addedText.attr("clip-path", function() {
          var uid = select(this.parentNode).attr("data-uid");
          var clipPathID = options2.style.prefix + "-clip-" + uid;
          return "url(" + (new URL("#" + clipPathID, windowLocation) + "") + ")";
        });
      }
    }, function(update) {
      return update.text(function(d) {
        return d.text;
      }).style("fill", textFillColor);
    }, function(exit) {
      return exit.remove();
    });
    this.addEventListeners();
  };
  Treemap2.prototype.addEventListeners = function() {
    var self2 = this;
    this.parent.selectAll("rect.leaf").on("mouseover", function(event, datum2) {
      var hoveredElement = select(this);
      var fillColor = getComputedStyle(this, null).getPropertyValue("fill");
      var parent = datum2;
      while (parent.depth > 1)
        parent = parent.parent;
      hoveredElement.transition("graph_element_mouseover_fill_update").call(function(t) {
        return self2.services.transitions.setupTransition({
          transition: t,
          name: "graph_element_mouseover_fill_update"
        });
      }).style("fill", function(d) {
        var customColor = self2.model.getFillColor(d.parent.data.name);
        if (customColor) {
          fillColor = customColor;
        }
        return color(fillColor).darker(0.7).toString();
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
        event,
        hoveredElement,
        items: [
          {
            color: fillColor,
            label: parent.data.name,
            bold: true
          },
          {
            label: datum2.data.name,
            value: datum2.data.value
          }
        ]
      });
      self2.services.events.dispatchEvent(Events$1.Treemap.LEAF_MOUSEOVER, {
        event,
        element: hoveredElement,
        datum: datum2
      });
    }).on("mousemove", function(event, datum2) {
      var hoveredElement = select(this);
      self2.services.events.dispatchEvent(Events$1.Treemap.LEAF_MOUSEMOVE, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("click", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Treemap.LEAF_CLICK, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mouseout", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", false);
      var parent = datum2;
      while (parent.depth > 1)
        parent = parent.parent;
      hoveredElement.transition().call(function(t) {
        return self2.services.transitions.setupTransition({
          transition: t,
          name: "graph_element_mouseout_fill_update"
        });
      }).style("fill", function(d) {
        return self2.model.getFillColor(d.parent.data.name);
      });
      self2.services.events.dispatchEvent(Events$1.Treemap.LEAF_MOUSEOUT, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
        hoveredElement
      });
    });
  };
  return Treemap2;
}(Component);
function radialLabelPlacement(angleRadians) {
  var angle = mod(radToDeg(angleRadians), 360);
  if (isInRange(angle, [0, 10]) || isInRange(angle, [350, 0])) {
    return {
      textAnchor: TextAnchor.START,
      dominantBaseline: DominantBaseline.MIDDLE
    };
  } else if (isInRange(angle, [10, 80])) {
    return {
      textAnchor: TextAnchor.START,
      dominantBaseline: DominantBaseline.HANGING
    };
  } else if (isInRange(angle, [80, 100])) {
    return {
      textAnchor: TextAnchor.MIDDLE,
      dominantBaseline: DominantBaseline.HANGING
    };
  } else if (isInRange(angle, [100, 170])) {
    return {
      textAnchor: TextAnchor.END,
      dominantBaseline: DominantBaseline.HANGING
    };
  } else if (isInRange(angle, [170, 190])) {
    return {
      textAnchor: TextAnchor.END,
      dominantBaseline: DominantBaseline.MIDDLE
    };
  } else if (isInRange(angle, [190, 260])) {
    return {
      textAnchor: TextAnchor.END,
      dominantBaseline: DominantBaseline.BASELINE
    };
  } else if (isInRange(angle, [260, 280])) {
    return {
      textAnchor: TextAnchor.MIDDLE,
      dominantBaseline: DominantBaseline.BASELINE
    };
  } else {
    return {
      textAnchor: TextAnchor.START,
      dominantBaseline: DominantBaseline.BASELINE
    };
  }
}
function mod(n, m) {
  return (n % m + m) % m;
}
function isInRange(x2, _a2) {
  var min2 = _a2[0], max2 = _a2[1];
  return x2 >= min2 && x2 <= max2;
}
function radToDeg(rad) {
  return rad * (180 / Math.PI);
}
function polarToCartesianCoords(a, r, t) {
  if (t === void 0) {
    t = { x: 0, y: 0 };
  }
  var x2 = r * Math.cos(a) + t.x;
  var y2 = r * Math.sin(a) + t.y;
  return { x: isNaN(x2) ? 0 : x2, y: isNaN(y2) ? 0 : y2 };
}
function distanceBetweenPointOnCircAndVerticalDiameter(a, r) {
  return r * Math.sin(a - Math.PI / 2);
}
var __extends$V = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Radar = function(_super) {
  __extends$V(Radar2, _super);
  function Radar2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "radar";
    _this.renderType = RenderTypes.SVG;
    _this.getLabelDimensions = function(label) {
      var tmpTick = DOMUtils.appendOrSelect(_this.getComponentContainer(), "g.tmp-tick");
      var tmpTickText = DOMUtils.appendOrSelect(tmpTick, "text").text(label);
      var _a2 = DOMUtils.getSVGElementSize(tmpTickText.node(), { useBBox: true }), width = _a2.width, height = _a2.height;
      tmpTick.remove();
      return { width, height };
    };
    _this.normalizeFlatData = function(dataset) {
      var options2 = _this.getOptions();
      var _a2 = Tools.getProperty(options2, "radar", "axes"), angle = _a2.angle, value2 = _a2.value;
      var groupMapsTo = Tools.getProperty(options2, "data", "groupMapsTo");
      var completeBlankData = Tools.flatMapDeep(_this.uniqueKeys.map(function(key) {
        return _this.uniqueGroups.map(function(group) {
          var _a3;
          return _a3 = {}, _a3[angle] = key, _a3[groupMapsTo] = group, _a3[value2] = null, _a3;
        });
      }));
      return Tools.merge(completeBlankData, dataset);
    };
    _this.normalizeGroupedData = function(dataset) {
      var options2 = _this.getOptions();
      var _a2 = Tools.getProperty(options2, "radar", "axes"), angle = _a2.angle, value2 = _a2.value;
      var groupMapsTo = Tools.getProperty(options2, "data", "groupMapsTo");
      return dataset.map(function(_a3) {
        var name = _a3.name, data = _a3.data;
        var completeBlankData = _this.uniqueKeys.map(function(k) {
          var _a4;
          return _a4 = {}, _a4[groupMapsTo] = name, _a4[angle] = k, _a4[value2] = null, _a4;
        });
        return { name, data: Tools.merge(completeBlankData, data) };
      });
    };
    _this.handleLegendOnHover = function(event) {
      var hoveredElement = event.detail.hoveredElement;
      _this.parent.selectAll("g.blobs path").transition("legend-hover-blob").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-hover-blob"
        });
      }).style("fill-opacity", function(group) {
        if (group.name !== hoveredElement.datum().name) {
          return radar.opacity.unselected;
        }
        return radar.opacity.selected;
      }).style("stroke-opacity", function(group) {
        if (group.name !== hoveredElement.datum().name) {
          return radar.opacity.unselected;
        }
        return 1;
      });
    };
    _this.handleLegendMouseOut = function(event) {
      _this.parent.selectAll("g.blobs path").transition("legend-mouseout-blob").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-blob"
        });
      }).style("fill-opacity", radar.opacity.selected).style("stroke-opacity", 1);
    };
    return _this;
  }
  Radar2.prototype.init = function() {
    var events = this.services.events;
    events.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    events.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  Radar2.prototype.render = function(animate) {
    var _this = this;
    if (animate === void 0) {
      animate = true;
    }
    var svg = this.getComponentContainer();
    var _a2 = DOMUtils.getSVGElementSize(svg, {
      useAttrs: true
    }), width = _a2.width, height = _a2.height;
    var data = this.model.getData();
    var groupedData = this.model.getGroupedData();
    var options2 = this.getOptions();
    var groupMapsTo = Tools.getProperty(options2, "data", "groupMapsTo");
    var valueMapsTo = Tools.getProperty(options2, "radar", "axes", "value");
    var _b = Tools.getProperty(options2, "radar", "axes"), angle = _b.angle, value2 = _b.value;
    var _c = radar, xLabelPadding = _c.xLabelPadding, yLabelPadding = _c.yLabelPadding, yTicksNumber = _c.yTicksNumber, minRange = _c.minRange, xAxisRectHeight = _c.xAxisRectHeight;
    this.uniqueKeys = Array.from(new Set(data.map(function(d) {
      return d[angle];
    })));
    this.uniqueGroups = Array.from(new Set(data.map(function(d) {
      return d[groupMapsTo];
    })));
    this.fullDataNormalized = this.normalizeFlatData(data);
    this.groupedDataNormalized = this.normalizeGroupedData(groupedData);
    var labelHeight = this.getLabelDimensions(this.uniqueKeys[0]).height;
    var margin = 2 * (labelHeight + yLabelPadding);
    var size = Math.min(width, height);
    var diameter = size - margin;
    var radius = diameter / 2;
    if (radius <= 0) {
      return;
    }
    var xScale = band().domain(this.fullDataNormalized.map(function(d) {
      return d[angle];
    })).range([0, 2 * Math.PI].map(function(a) {
      return a - Math.PI / 2;
    }));
    var centerPointMinValue = min$3(this.fullDataNormalized.map(function(d) {
      return d[value2];
    }));
    var yScale = linear().domain([
      centerPointMinValue >= 0 ? 0 : centerPointMinValue,
      max$3(this.fullDataNormalized.map(function(d) {
        return d[value2];
      }))
    ]).range([minRange, radius]).nice(yTicksNumber);
    var yTicks = yScale.ticks(yTicksNumber);
    var colorScale = function(group) {
      return _this.model.getFillColor(group);
    };
    var radialLineGenerator = lineRadial$1().angle(function(d) {
      return xScale(d[angle]) + Math.PI / 2;
    }).radius(function(d) {
      return yScale(d[value2]);
    }).curve(curveLinearClosed);
    var horizSpaceNeededByEachXLabel = this.uniqueKeys.map(function(key) {
      var tickWidth = _this.getLabelDimensions(key).width;
      var distanceFromDiameter = distanceBetweenPointOnCircAndVerticalDiameter(xScale(key), radius);
      return tickWidth + distanceFromDiameter;
    });
    var leftPadding = max$3(horizSpaceNeededByEachXLabel);
    var c = {
      x: leftPadding + xLabelPadding,
      y: height / 2
    };
    var yAxes = DOMUtils.appendOrSelect(svg, "g.y-axes").attr("role", Roles.GROUP);
    var yAxisUpdate = yAxes.selectAll("path").data(yTicks, function(tick) {
      return tick;
    });
    var shapeData = function(tick) {
      return _this.uniqueKeys.map(function(key) {
        var _a3;
        return _a3 = {}, _a3[angle] = key, _a3[value2] = tick, _a3;
      });
    };
    yAxisUpdate.join(function(enter) {
      return enter.append("path").attr("opacity", 0).attr("transform", "translate(" + c.x + ", " + c.y + ")").attr("fill", "none").call(function(selection2) {
        return selection2.transition().call(function(t) {
          return _this.services.transitions.setupTransition({
            transition: t,
            name: "radar_y_axes_enter",
            animate
          });
        }).attr("opacity", 1).attr("d", function(tick) {
          return radialLineGenerator(shapeData(tick));
        });
      });
    }, function(update) {
      return update.call(function(selection2) {
        return selection2.transition().call(function(t) {
          return _this.services.transitions.setupTransition({
            transition: t,
            name: "radar_y_axes_update",
            animate
          });
        }).attr("opacity", 1).attr("transform", "translate(" + c.x + ", " + c.y + ")").attr("d", function(tick) {
          return radialLineGenerator(shapeData(tick));
        });
      });
    }, function(exit) {
      return exit.call(function(selection2) {
        return selection2.transition().call(function(t) {
          return _this.services.transitions.setupTransition({
            transition: t,
            name: "radar_y_axes_exit",
            animate
          });
        }).attr("d", function(tick) {
          return radialLineGenerator(shapeData(tick));
        }).attr("opacity", 0).remove();
      });
    });
    var xAxes = DOMUtils.appendOrSelect(svg, "g.x-axes").attr("role", Roles.GROUP);
    var xAxisUpdate = xAxes.selectAll("line").data(this.uniqueKeys, function(key) {
      return key;
    });
    xAxisUpdate.join(function(enter) {
      return enter.append("line").attr("opacity", 0).attr("class", function(key) {
        return "x-axis-" + Tools.kebabCase(key);
      }).attr("stroke-dasharray", "0").attr("x1", function(key) {
        return polarToCartesianCoords(xScale(key), 0, c).x;
      }).attr("y1", function(key) {
        return polarToCartesianCoords(xScale(key), 0, c).y;
      }).attr("x2", function(key) {
        return polarToCartesianCoords(xScale(key), 0, c).x;
      }).attr("y2", function(key) {
        return polarToCartesianCoords(xScale(key), 0, c).y;
      }).call(function(selection2) {
        return selection2.transition().call(function(t) {
          return _this.services.transitions.setupTransition({
            transition: t,
            name: "radar_x_axes_enter",
            animate
          });
        }).attr("opacity", 1).attr("x1", function(key) {
          return polarToCartesianCoords(xScale(key), yScale.range()[0], c).x;
        }).attr("y1", function(key) {
          return polarToCartesianCoords(xScale(key), yScale.range()[0], c).y;
        }).attr("x2", function(key) {
          return polarToCartesianCoords(xScale(key), yScale.range()[1], c).x;
        }).attr("y2", function(key) {
          return polarToCartesianCoords(xScale(key), yScale.range()[1], c).y;
        });
      });
    }, function(update) {
      return update.call(function(selection2) {
        return selection2.transition().call(function(t) {
          return _this.services.transitions.setupTransition({
            transition: t,
            name: "radar_x_axes_update",
            animate
          });
        }).attr("opacity", 1).attr("x1", function(key) {
          return polarToCartesianCoords(xScale(key), yScale.range()[0], c).x;
        }).attr("y1", function(key) {
          return polarToCartesianCoords(xScale(key), yScale.range()[0], c).y;
        }).attr("x2", function(key) {
          return polarToCartesianCoords(xScale(key), yScale.range()[1], c).x;
        }).attr("y2", function(key) {
          return polarToCartesianCoords(xScale(key), yScale.range()[1], c).y;
        });
      });
    }, function(exit) {
      return exit.call(function(selection2) {
        return selection2.transition().call(function(t) {
          return _this.services.transitions.setupTransition({
            transition: t,
            name: "radar_x_axes_exit",
            animate
          });
        }).attr("opacity", 0).remove();
      });
    });
    var xLabels = DOMUtils.appendOrSelect(svg, "g.x-labels").attr("role", Roles.GROUP);
    var xLabelUpdate = xLabels.selectAll("text").data(this.uniqueKeys);
    xLabelUpdate.join(function(enter) {
      return enter.append("text").text(function(key) {
        return key;
      }).attr("opacity", 0).attr("x", function(key) {
        return polarToCartesianCoords(xScale(key), yScale.range()[1] + xLabelPadding, c).x;
      }).attr("y", function(key) {
        return polarToCartesianCoords(xScale(key), yScale.range()[1] + xLabelPadding, c).y;
      }).style("text-anchor", function(key) {
        return radialLabelPlacement(xScale(key)).textAnchor;
      }).style("dominant-baseline", function(key) {
        return radialLabelPlacement(xScale(key)).dominantBaseline;
      }).call(function(selection2) {
        return selection2.transition().call(function(t) {
          return _this.services.transitions.setupTransition({
            transition: t,
            name: "radar_x_labels_enter",
            animate
          });
        }).attr("opacity", 1);
      });
    }, function(update) {
      return update.call(function(selection2) {
        return selection2.transition().call(function(t) {
          return _this.services.transitions.setupTransition({
            transition: t,
            name: "radar_x_labels_update",
            animate
          });
        }).attr("opacity", 1).attr("x", function(key) {
          return polarToCartesianCoords(xScale(key), yScale.range()[1] + xLabelPadding, c).x;
        }).attr("y", function(key) {
          return polarToCartesianCoords(xScale(key), yScale.range()[1] + xLabelPadding, c).y;
        }).end().finally(function() {
          var alignment = Tools.getProperty(options2, "radar", "alignment");
          var alignmentXOffset = _this.getAlignmentXOffset(alignment, svg, _this.getParent());
          svg.attr("x", alignmentXOffset);
        });
      });
    }, function(exit) {
      return exit.call(function(selection2) {
        return selection2.transition().call(function(t) {
          return _this.services.transitions.setupTransition({
            transition: t,
            name: "radar_x_labels_exit",
            animate
          });
        }).attr("opacity", 0).remove();
      });
    });
    var blobs = DOMUtils.appendOrSelect(svg, "g.blobs").attr("role", Roles.GROUP);
    var blobUpdate = blobs.selectAll("path").data(this.groupedDataNormalized, function(group) {
      return group.name;
    });
    blobUpdate.join(function(enter) {
      return enter.append("path").attr("class", function(group) {
        return _this.model.getColorClassName({
          classNameTypes: [
            ColorClassNameTypes.FILL,
            ColorClassNameTypes.STROKE
          ],
          dataGroupName: group.name,
          originalClassName: "blob"
        });
      }).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-label", function(d) {
        return d["name"];
      }).attr("opacity", 0).attr("transform", animate ? function() {
        return "translate(" + c.x + ", " + c.y + ") scale(" + (1 + Math.random() * 0.35) + ")";
      } : "translate(" + c.x + ", " + c.y + ")").style("fill", function(group) {
        return colorScale(group.name);
      }).style("fill-opacity", radar.opacity.selected).style("stroke", function(group) {
        return colorScale(group.name);
      }).call(function(selection2) {
        var selectionUpdate = selection2.transition().call(function(t) {
          return _this.services.transitions.setupTransition({
            transition: t,
            name: "radar_blobs_enter",
            animate
          });
        });
        if (animate) {
          selectionUpdate.delay(function() {
            return Math.random() * 30;
          }).attr("transform", "translate(" + c.x + ", " + c.y + ")");
        }
        selectionUpdate.attr("opacity", 1).attr("d", function(group) {
          return radialLineGenerator(group.data);
        });
      });
    }, function(update) {
      update.attr("class", function(group) {
        return _this.model.getColorClassName({
          classNameTypes: [
            ColorClassNameTypes.FILL,
            ColorClassNameTypes.STROKE
          ],
          dataGroupName: group.name,
          originalClassName: "blob"
        });
      }).style("fill", function(group) {
        return colorScale(group.name);
      }).style("stroke", function(group) {
        return colorScale(group.name);
      });
      update.call(function(selection2) {
        return selection2.transition().call(function(t) {
          return _this.services.transitions.setupTransition({
            transition: t,
            name: "radar_blobs_update",
            animate
          });
        }).attr("opacity", 1).attr("transform", "translate(" + c.x + ", " + c.y + ")").attr("d", function(group) {
          return radialLineGenerator(group.data);
        });
      });
    }, function(exit) {
      return exit.call(function(selection2) {
        var selectionUpdate = selection2.transition().call(function(t) {
          return _this.services.transitions.setupTransition({
            transition: t,
            name: "radar_blobs_exit",
            animate
          });
        });
        if (animate) {
          selectionUpdate.delay(function() {
            return Math.random() * 30;
          }).attr("transform", function() {
            return "translate(" + c.x + ", " + c.y + ") scale(" + (1 + Math.random() * 0.35) + ")";
          });
        }
        selectionUpdate.attr("opacity", 0).remove();
      });
    });
    var dots = DOMUtils.appendOrSelect(svg, "g.dots").attr("role", Roles.GROUP);
    var dotsUpdate = dots.selectAll("circle").data(this.fullDataNormalized.filter(function(d) {
      return Tools.getProperty(d, value2) !== null;
    }));
    dotsUpdate.join(function(enter) {
      return enter.append("circle").attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-label", function(d) {
        return d[valueMapsTo];
      });
    }, function(update) {
      return update;
    }, function(exit) {
      return exit.remove();
    }).attr("class", function(d) {
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.FILL],
        dataGroupName: d[groupMapsTo],
        originalClassName: Tools.kebabCase(d[angle])
      });
    }).attr("cx", function(d) {
      return polarToCartesianCoords(xScale(d[angle]), yScale(d[value2]), c).x;
    }).attr("cy", function(d) {
      return polarToCartesianCoords(xScale(d[angle]), yScale(d[value2]), c).y;
    }).attr("r", 0).attr("opacity", 0).style("fill", function(d) {
      return colorScale(d[groupMapsTo]);
    });
    var xAxesRect = DOMUtils.appendOrSelect(svg, "g.x-axes-rect").attr("role", Roles.GROUP);
    var xAxisRectUpdate = xAxesRect.selectAll("rect").data(this.uniqueKeys);
    xAxisRectUpdate.join(function(enter) {
      return enter.append("rect");
    }, function(update) {
      return update;
    }, function(exit) {
      return exit.remove();
    }).attr("x", c.x).attr("y", c.y - xAxisRectHeight / 2).attr("width", yScale.range()[1]).attr("height", xAxisRectHeight).style("fill", "red").style("fill-opacity", 0).attr("transform", function(key) {
      return "rotate(" + radToDeg(xScale(key)) + ", " + c.x + ", " + c.y + ")";
    });
    var yLabels = DOMUtils.appendOrSelect(svg, "g.y-labels").attr("role", Roles.GROUP);
    var yLabelUpdate = yLabels.selectAll("text").data(extent(yTicks));
    yLabelUpdate.join(function(enter) {
      return enter.append("text").attr("opacity", 0).text(function(tick) {
        return tick;
      }).attr("x", function(tick) {
        return polarToCartesianCoords(-Math.PI / 2, yScale(tick), c).x + yLabelPadding;
      }).attr("y", function(tick) {
        return polarToCartesianCoords(-Math.PI / 2, yScale(tick), c).y;
      }).style("text-anchor", "start").style("dominant-baseline", "middle").call(function(selection2) {
        return selection2.transition().call(function(t) {
          return _this.services.transitions.setupTransition({
            transition: t,
            name: "radar_y_labels_enter",
            animate
          });
        }).attr("opacity", 1);
      });
    }, function(update) {
      return update.call(function(selection2) {
        return selection2.transition().call(function(t) {
          return _this.services.transitions.setupTransition({
            transition: t,
            name: "radar_y_labels_update",
            animate
          });
        }).text(function(tick) {
          return tick;
        }).attr("opacity", 1).attr("x", function(tick) {
          return polarToCartesianCoords(-Math.PI / 2, yScale(tick), c).x + yLabelPadding;
        }).attr("y", function(tick) {
          return polarToCartesianCoords(-Math.PI / 2, yScale(tick), c).y;
        });
      });
    }, function(exit) {
      return exit.call(function(selection2) {
        return selection2.transition().call(function(t) {
          return _this.services.transitions.setupTransition({
            transition: t,
            name: "radar_y_labels_exit",
            animate
          });
        }).attr("opacity", 0).remove();
      });
    });
    this.addEventListeners();
  };
  Radar2.prototype.getAlignmentXOffset = function(alignment, svg, parent) {
    var svgDimensions = DOMUtils.getSVGElementSize(svg, {
      useBBox: true
    });
    var width = DOMUtils.getSVGElementSize(parent, {
      useAttrs: true
    }).width;
    var alignmentOffset = 0;
    if (alignment === Alignments.CENTER) {
      alignmentOffset = Math.floor((width - svgDimensions.width) / 2);
    } else if (alignment === Alignments.RIGHT) {
      alignmentOffset = width - svgDimensions.width;
    }
    return alignmentOffset;
  };
  Radar2.prototype.destroy = function() {
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    var eventsFragment = this.services.events;
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  Radar2.prototype.addEventListeners = function() {
    var self2 = this;
    var angle = Tools.getProperty(this.getOptions(), "radar").axes.angle;
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", function(event, datum2) {
      var hoveredElement = select(this);
      self2.services.events.dispatchEvent(Events$1.Radar.X_AXIS_MOUSEOVER, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      var axisLine = self2.parent.select(".x-axes .x-axis-" + Tools.kebabCase(datum2));
      var dots = self2.parent.selectAll(".dots circle." + Tools.kebabCase(datum2));
      var activeDataGroupNames = self2.model.getActiveDataGroupNames();
      var options2 = self2.getOptions();
      var groupMapsTo = options2.data.groupMapsTo;
      var valueMapsTo = Tools.getProperty(options2, "radar", "axes", "value");
      axisLine.classed("hovered", true).attr("stroke-dasharray", "4 4");
      dots.classed("hovered", true).attr("opacity", function(d) {
        return activeDataGroupNames.indexOf(d[groupMapsTo]) !== -1 ? 1 : 0;
      }).attr("r", radar.dotsRadius);
      var itemsToHighlight = self2.fullDataNormalized.filter(function(d) {
        return d[angle] === datum2 && activeDataGroupNames.indexOf(d[groupMapsTo]) !== -1;
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
        event,
        hoveredElement,
        items: itemsToHighlight.filter(function(datum3) {
          return typeof datum3[valueMapsTo] === "number";
        }).map(function(datum3) {
          return {
            label: datum3[groupMapsTo],
            value: datum3[valueMapsTo],
            color: self2.model.getFillColor(datum3[groupMapsTo]),
            class: self2.model.getColorClassName({
              classNameTypes: [ColorClassNameTypes.TOOLTIP],
              dataGroupName: datum3[groupMapsTo]
            })
          };
        })
      });
    }).on("mousemove", function(event, datum2) {
      var hoveredElement = select(this);
      self2.services.events.dispatchEvent(Events$1.Radar.X_AXIS_MOUSEMOVE, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("click", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Radar.X_AXIS_CLICK, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mouseout", function(event, datum2) {
      var hoveredElement = select(this);
      var axisLine = self2.parent.select(".x-axes .x-axis-" + Tools.kebabCase(datum2));
      var dots = self2.parent.selectAll(".dots circle." + Tools.kebabCase(datum2));
      axisLine.classed("hovered", false).attr("stroke-dasharray", "0");
      dots.classed("hovered", false).attr("opacity", 0).attr("r", 0);
      self2.services.events.dispatchEvent(Events$1.Radar.X_AXIS_MOUSEOUT, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE);
    });
  };
  return Radar2;
}(Component);
var __extends$U = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays$h = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var CirclePack = function(_super) {
  __extends$U(CirclePack2, _super);
  function CirclePack2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "circle-pack";
    _this.renderType = RenderTypes.SVG;
    _this.handleLegendOnHover = function(event) {
      var hoveredElement = event.detail.hoveredElement;
      _this.parent.selectAll("circle.node").transition("legend-hover-circlepack").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-hover-circlepack"
        });
      }).attr("opacity", function(d) {
        return d.data.dataGroupName === hoveredElement.datum()["name"] ? 1 : circlePack.circles.fillOpacity;
      });
    };
    _this.handleLegendMouseOut = function(event) {
      _this.parent.selectAll("circle.node").transition("legend-mouseout-circlepack").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-circlepack"
        });
      }).attr("opacity", 1);
    };
    return _this;
  }
  CirclePack2.prototype.render = function(animate) {
    var _this = this;
    var svg = this.getComponentContainer({ withinChartClip: true });
    var _a2 = DOMUtils.getSVGElementSize(this.parent, {
      useAttrs: true
    }), width = _a2.width, height = _a2.height;
    if (width < 1 || height < 1) {
      return;
    }
    var displayData = this.model.getDisplayData();
    var parentNode = this.model.hasParentNode();
    var hierarchyLevel = this.model.getHierarchyLevel();
    var options2 = this.getOptions();
    var canvasZoomEnabled = Tools.getProperty(options2, "canvasZoom", "enabled");
    if (parentNode && Tools.getProperty(displayData, 0, "children")) {
      displayData = Tools.getProperty(displayData, 0, "children");
    }
    var root2 = hierarchy({ children: displayData }).sum(function(d) {
      return d.value;
    }).sort(function(a, b) {
      return b.value - a.value;
    });
    var packLayout = D3Pack().size([width, height]).padding(function(d) {
      return d.depth >= 1 ? circlePack.padding.children + 3 : circlePack.padding.mainGroup + 3;
    });
    var nodeData = packLayout(root2).descendants().splice(1).filter(function(node) {
      return node.depth <= hierarchyLevel;
    });
    var circles = svg.selectAll("circle.node").data(nodeData);
    circles.exit().attr("width", 0).attr("height", 0).remove();
    var enteringCircles = circles.enter().append("circle").classed("node", true);
    enteringCircles.merge(circles).attr("class", function(d) {
      var originalClass = canvasZoomEnabled && hierarchyLevel === 3 ? _this.getZoomClass(d) : "";
      return _this.model.getColorClassName({
        classNameTypes: [
          ColorClassNameTypes.FILL,
          ColorClassNameTypes.STROKE
        ],
        dataGroupName: d.data.dataGroupName,
        originalClassName: d.children ? "node " + originalClass : "node node-leaf " + originalClass
      });
    }).style("fill", function(d) {
      return _this.model.getFillColor(d.data.dataGroupName);
    }).style("stroke", function(d) {
      return _this.model.getFillColor(d.data.dataGroupName);
    }).attr("cx", function(d) {
      return d.x;
    }).attr("cy", function(d) {
      return d.y;
    }).transition("circlepack-leaf-update-enter").call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "circlepack-leaf-update-enter"
      });
    }).attr("r", function(d) {
      return d.r;
    }).attr("opacity", 1).attr("fill-opacity", circlePack.circles.fillOpacity);
    if (canvasZoomEnabled === true && this.focal) {
      this.services.canvasZoom.zoomIn(this.focal, enteringCircles, canvasZoomSettings);
      this.setBackgroundListeners();
    }
    if (!parentNode) {
      this.addLegendListeners();
    }
    this.addEventListeners();
  };
  CirclePack2.prototype.unhighlightChildren = function(childData) {
    var _this = this;
    var data = childData.map(function(d) {
      return d.data;
    });
    this.parent.selectAll("circle.node").filter(function(d) {
      return data.some(function(datum2) {
        return datum2 === d.data;
      }) && d.depth > 1;
    }).style("stroke", function(d) {
      return _this.model.getFillColor(d.data.dataGroupName);
    });
  };
  CirclePack2.prototype.highlightChildren = function(childData) {
    var data = childData.map(function(d) {
      return d.data;
    });
    this.parent.selectAll("circle.node").filter(function(d) {
      return data.some(function(datum2) {
        return datum2 === d.data;
      }) && d.depth > 1;
    }).style("stroke", circlePack.circles.hover.stroke);
  };
  CirclePack2.prototype.getZoomClass = function(node) {
    if (this.model.getHierarchyLevel() === 3 && this.focal) {
      if (node.data === this.focal.data || this.focal.children.some(function(d) {
        return d.data === node.data;
      })) {
        return "focal";
      }
    }
    return "non-focal";
  };
  CirclePack2.prototype.addLegendListeners = function() {
    var events = this.services.events;
    events.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    events.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  CirclePack2.prototype.removeBackgroundListeners = function() {
    var chartSvg = select(this.services.domUtils.getMainContainer());
    chartSvg.on("click", function() {
      return null;
    });
  };
  CirclePack2.prototype.setBackgroundListeners = function() {
    var chartSvg = select(this.services.domUtils.getMainContainer());
    var self2 = this;
    var canvasSelection = this.parent.selectAll("circle.node");
    var zoomSetting = Tools.getProperty(Configuration, "canvasZoomSettings");
    chartSvg.on("click", function() {
      self2.focal = null;
      self2.model.updateHierarchyLevel(2);
      chartSvg.classed("zoomed-in", false);
      self2.services.canvasZoom.zoomOut(canvasSelection, zoomSetting);
    });
  };
  CirclePack2.prototype.getZoomIcon = function() {
    return '\n		<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10">\n			<polygon points="5.93 3.71 4.45 3.71 4.45 2.23 3.71 2.23 3.71 3.71 2.23 3.71 2.23 4.45 3.71 4.45 3.71 5.93 4.45 5.93 4.45 4.45 5.93 4.45 5.93 3.71"/>\n			<path d="M7.2,6.67a4,4,0,0,0,1-2.59A4.08,4.08,0,1,0,4.07,8.15h0a4,4,0,0,0,2.59-1L9.48,10,10,9.48Zm-3.12.77A3.34,3.34,0,1,1,7.41,4.08,3.34,3.34,0,0,1,4.08,7.44Z"/>\n		</svg>';
  };
  CirclePack2.prototype.addEventListeners = function() {
    var self2 = this;
    this.parent.selectAll("circle.node").on("mouseover", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", true);
      var hierarchyLevel = self2.model.getHierarchyLevel();
      var disabled = hierarchyLevel > 2 && !hoveredElement.classed("focal");
      var canvasZoomEnabled = Tools.getProperty(self2.model.getOptions(), "canvasZoom", "enabled");
      var zoomable = false;
      if (!disabled) {
        var childrenData = [];
        var totalValue = [];
        var parentValue = null;
        if (datum2.children) {
          if (datum2.depth > 1 && canvasZoomEnabled) {
            zoomable = true;
            hoveredElement.classed("clickable", true);
          }
          childrenData = datum2.children.map(function(child) {
            if (child !== null) {
              if (typeof child.data.value === "number") {
                return {
                  label: child.data.name,
                  value: child.data.value
                };
              } else {
                return {
                  label: child.data.name,
                  labelIcon: canvasZoomEnabled && hierarchyLevel <= 2 ? self2.getZoomIcon() : null,
                  value: child.value
                };
              }
            }
          });
          var options2 = self2.model.getOptions();
          totalValue = [
            {
              label: get$3(options2, "tooltip.totalLabel") || "Total",
              value: datum2.value,
              bold: true
            }
          ];
          self2.highlightChildren(datum2.children);
        } else {
          parentValue = datum2.value;
        }
        var fillColor = getComputedStyle(this, null).getPropertyValue("fill");
        self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
          event,
          hoveredElement,
          items: __spreadArrays$h([
            {
              color: fillColor,
              label: datum2.data.name,
              labelIcon: zoomable && canvasZoomEnabled && hierarchyLevel <= 2 ? self2.getZoomIcon() : null,
              value: parentValue
            }
          ], childrenData, totalValue)
        });
      }
      self2.services.events.dispatchEvent(Events$1.CirclePack.CIRCLE_MOUSEOVER, {
        event,
        element: hoveredElement,
        datum: datum2
      });
    }).on("mousemove", function(event, datum2) {
      var hoveredElement = select(this);
      self2.services.events.dispatchEvent(Events$1.CirclePack.CIRCLE_MOUSEMOVE, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("mouseout", function(event, datum2) {
      var hoveredElement = select(this);
      hoveredElement.classed("hovered", false);
      if (datum2.children) {
        self2.unhighlightChildren(datum2.children);
      }
      self2.services.events.dispatchEvent(Events$1.CirclePack.CIRCLE_MOUSEOUT, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
        hoveredElement
      });
    }).on("click", function(event, datum2) {
      var hoveredElement = select(this);
      var disabled = hoveredElement.classed("non-focal");
      var canvasZoomEnabled = Tools.getProperty(self2.model.getOptions(), "canvasZoom", "enabled");
      if (canvasZoomEnabled && self2.model.getHierarchyLevel() > 2) {
        var canvasSelection = self2.parent.selectAll("circle.node");
        var chartSvg = select(self2.services.domUtils.getMainContainer());
        chartSvg.classed("zoomed-in", false);
        self2.focal = null;
        self2.model.updateHierarchyLevel(2);
        self2.services.canvasZoom.zoomOut(canvasSelection, canvasZoomSettings);
      } else if (datum2.depth === 2 && datum2.children && !disabled && canvasZoomEnabled) {
        var canvasSelection = self2.parent.selectAll("circle.node");
        var chartSvg = select(self2.services.domUtils.getMainContainer());
        chartSvg.classed("zoomed-in", true);
        self2.focal = datum2;
        self2.model.updateHierarchyLevel(3);
        self2.services.canvasZoom.zoomIn(datum2, canvasSelection, canvasZoomSettings);
        event.stopPropagation();
      }
      self2.services.events.dispatchEvent(Events$1.CirclePack.CIRCLE_CLICK, {
        event,
        element: hoveredElement,
        datum: datum2
      });
    });
  };
  CirclePack2.prototype.destroy = function() {
    this.parent.selectAll("circle.node").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
    var eventsFragment = this.services.events;
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
    this.removeBackgroundListeners();
  };
  return CirclePack2;
}(Component);
var noop$1 = { value: function() {
} };
function dispatch$2() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch$1(_);
}
function Dispatch$1(_) {
  this._ = _;
}
function parseTypenames$1(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch$1.prototype = dispatch$2.prototype = {
  constructor: Dispatch$1,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames$1(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get$2(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set$2(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set$2(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _ = this._;
    for (var t in _)
      copy2[t] = _[t].slice();
    return new Dispatch$1(copy2);
  },
  call: function(type2, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get$2(type2, name) {
  for (var i = 0, n = type2.length, c; i < n; ++i) {
    if ((c = type2[i]).name === name) {
      return c.value;
    }
  }
}
function set$2(type2, name, callback) {
  for (var i = 0, n = type2.length; i < n; ++i) {
    if (type2[i].name === name) {
      type2[i] = noop$1, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name, value: callback });
  return type2;
}
var src = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  dispatch: dispatch$2
});
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(src);
var dispatch$1 = require$$0.dispatch;
var cloudRadians = Math.PI / 180, cw = 1 << 11 >> 5, ch = 1 << 11;
var d3Cloud = function() {
  var size = [256, 256], text = cloudText, font = cloudFont, fontSize = cloudFontSize, fontStyle = cloudFontNormal, fontWeight = cloudFontNormal, rotate = cloudRotate, padding = cloudPadding, spiral = archimedeanSpiral, words2 = [], timeInterval = Infinity, event = dispatch$1("word", "end"), timer2 = null, random = Math.random, cloud = {}, canvas = cloudCanvas;
  cloud.canvas = function(_) {
    return arguments.length ? (canvas = functor(_), cloud) : canvas;
  };
  cloud.start = function() {
    var contextAndRatio = getContext2(canvas()), board = zeroArray((size[0] >> 5) * size[1]), bounds = null, n = words2.length, i = -1, tags = [], data = words2.map(function(d, i2) {
      d.text = text.call(this, d, i2);
      d.font = font.call(this, d, i2);
      d.style = fontStyle.call(this, d, i2);
      d.weight = fontWeight.call(this, d, i2);
      d.rotate = rotate.call(this, d, i2);
      d.size = ~~fontSize.call(this, d, i2);
      d.padding = padding.call(this, d, i2);
      return d;
    }).sort(function(a, b) {
      return b.size - a.size;
    });
    if (timer2)
      clearInterval(timer2);
    timer2 = setInterval(step, 0);
    step();
    return cloud;
    function step() {
      var start2 = Date.now();
      while (Date.now() - start2 < timeInterval && ++i < n && timer2) {
        var d = data[i];
        d.x = size[0] * (random() + 0.5) >> 1;
        d.y = size[1] * (random() + 0.5) >> 1;
        cloudSprite(contextAndRatio, d, data, i);
        if (d.hasText && place2(board, d, bounds)) {
          tags.push(d);
          event.call("word", cloud, d);
          if (bounds)
            cloudBounds(bounds, d);
          else
            bounds = [{ x: d.x + d.x0, y: d.y + d.y0 }, { x: d.x + d.x1, y: d.y + d.y1 }];
          d.x -= size[0] >> 1;
          d.y -= size[1] >> 1;
        }
      }
      if (i >= n) {
        cloud.stop();
        event.call("end", cloud, tags, bounds);
      }
    }
  };
  cloud.stop = function() {
    if (timer2) {
      clearInterval(timer2);
      timer2 = null;
    }
    return cloud;
  };
  function getContext2(canvas2) {
    canvas2.width = canvas2.height = 1;
    var ratio = Math.sqrt(canvas2.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas2.width = (cw << 5) / ratio;
    canvas2.height = ch / ratio;
    var context = canvas2.getContext("2d");
    context.fillStyle = context.strokeStyle = "red";
    context.textAlign = "center";
    return { context, ratio };
  }
  function place2(board, tag, bounds) {
    [{ x: 0, y: 0 }, { x: size[0], y: size[1] }];
    var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), s = spiral(size), dt = random() < 0.5 ? 1 : -1, t = -dt, dxdy, dx, dy;
    while (dxdy = s(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
        break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1])
        continue;
      if (!bounds || !cloudCollide(tag, board, size[0])) {
        if (!bounds || collideRects(tag, bounds)) {
          var sprite = tag.sprite, w = tag.width >> 5, sw = size[0] >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0, x2 = (tag.y + tag.y0) * sw + (lx >> 5), last2;
          for (var j = 0; j < h; j++) {
            last2 = 0;
            for (var i = 0; i <= w; i++) {
              board[x2 + i] |= last2 << msx | (i < w ? (last2 = sprite[j * w + i]) >>> sx : 0);
            }
            x2 += sw;
          }
          delete tag.sprite;
          return true;
        }
      }
    }
    return false;
  }
  cloud.timeInterval = function(_) {
    return arguments.length ? (timeInterval = _ == null ? Infinity : _, cloud) : timeInterval;
  };
  cloud.words = function(_) {
    return arguments.length ? (words2 = _, cloud) : words2;
  };
  cloud.size = function(_) {
    return arguments.length ? (size = [+_[0], +_[1]], cloud) : size;
  };
  cloud.font = function(_) {
    return arguments.length ? (font = functor(_), cloud) : font;
  };
  cloud.fontStyle = function(_) {
    return arguments.length ? (fontStyle = functor(_), cloud) : fontStyle;
  };
  cloud.fontWeight = function(_) {
    return arguments.length ? (fontWeight = functor(_), cloud) : fontWeight;
  };
  cloud.rotate = function(_) {
    return arguments.length ? (rotate = functor(_), cloud) : rotate;
  };
  cloud.text = function(_) {
    return arguments.length ? (text = functor(_), cloud) : text;
  };
  cloud.spiral = function(_) {
    return arguments.length ? (spiral = spirals[_] || _, cloud) : spiral;
  };
  cloud.fontSize = function(_) {
    return arguments.length ? (fontSize = functor(_), cloud) : fontSize;
  };
  cloud.padding = function(_) {
    return arguments.length ? (padding = functor(_), cloud) : padding;
  };
  cloud.random = function(_) {
    return arguments.length ? (random = _, cloud) : random;
  };
  cloud.on = function() {
    var value2 = event.on.apply(event, arguments);
    return value2 === event ? cloud : value2;
  };
  return cloud;
};
function cloudText(d) {
  return d.text;
}
function cloudFont() {
  return "serif";
}
function cloudFontNormal() {
  return "normal";
}
function cloudFontSize(d) {
  return Math.sqrt(d.value);
}
function cloudRotate() {
  return (~~(Math.random() * 6) - 3) * 30;
}
function cloudPadding() {
  return 1;
}
function cloudSprite(contextAndRatio, d, data, di) {
  if (d.sprite)
    return;
  var c = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x2 = 0, y2 = 0, maxh = 0, n = data.length;
  --di;
  while (++di < n) {
    d = data[di];
    c.save();
    c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
    var w = c.measureText(d.text + "m").width * ratio, h = d.size << 1;
    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians), cr = Math.cos(d.rotate * cloudRadians), wcr = w * cr, wsr = w * sr, hcr = h * cr, hsr = h * sr;
      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w = w + 31 >> 5 << 5;
    }
    if (h > maxh)
      maxh = h;
    if (x2 + w >= cw << 5) {
      x2 = 0;
      y2 += maxh;
      maxh = 0;
    }
    if (y2 + h >= ch)
      break;
    c.translate((x2 + (w >> 1)) / ratio, (y2 + (h >> 1)) / ratio);
    if (d.rotate)
      c.rotate(d.rotate * cloudRadians);
    c.fillText(d.text, 0, 0);
    if (d.padding)
      c.lineWidth = 2 * d.padding, c.strokeText(d.text, 0, 0);
    c.restore();
    d.width = w;
    d.height = h;
    d.xoff = x2;
    d.yoff = y2;
    d.x1 = w >> 1;
    d.y1 = h >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x2 += w;
  }
  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di >= 0) {
    d = data[di];
    if (!d.hasText)
      continue;
    var w = d.width, w32 = w >> 5, h = d.y1 - d.y0;
    for (var i = 0; i < h * w32; i++)
      sprite[i] = 0;
    x2 = d.xoff;
    if (x2 == null)
      return;
    y2 = d.yoff;
    var seen = 0, seenRow = -1;
    for (var j = 0; j < h; j++) {
      for (var i = 0; i < w; i++) {
        var k = w32 * j + (i >> 5), m = pixels[(y2 + j) * (cw << 5) + (x2 + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k] |= m;
        seen |= m;
      }
      if (seen)
        seenRow = j;
      else {
        d.y0++;
        h--;
        j--;
        y2++;
      }
    }
    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0, x2 = (tag.y + tag.y0) * sw + (lx >> 5), last2;
  for (var j = 0; j < h; j++) {
    last2 = 0;
    for (var i = 0; i <= w; i++) {
      if ((last2 << msx | (i < w ? (last2 = sprite[j * w + i]) >>> sx : 0)) & board[x2 + i])
        return true;
    }
    x2 += sw;
  }
  return false;
}
function cloudBounds(bounds, d) {
  var b0 = bounds[0], b1 = bounds[1];
  if (d.x + d.x0 < b0.x)
    b0.x = d.x + d.x0;
  if (d.y + d.y0 < b0.y)
    b0.y = d.y + d.y0;
  if (d.x + d.x1 > b1.x)
    b1.x = d.x + d.x1;
  if (d.y + d.y1 > b1.y)
    b1.y = d.y + d.y1;
}
function collideRects(a, b) {
  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
}
function archimedeanSpiral(size) {
  var e = size[0] / size[1];
  return function(t) {
    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}
function rectangularSpiral(size) {
  var dy = 4, dx = dy * size[0] / size[1], x2 = 0, y2 = 0;
  return function(t) {
    var sign2 = t < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign2 * t) - sign2 & 3) {
      case 0:
        x2 += dx;
        break;
      case 1:
        y2 += dy;
        break;
      case 2:
        x2 -= dx;
        break;
      default:
        y2 -= dy;
        break;
    }
    return [x2, y2];
  };
}
function zeroArray(n) {
  var a = [], i = -1;
  while (++i < n)
    a[i] = 0;
  return a;
}
function cloudCanvas() {
  return document.createElement("canvas");
}
function functor(d) {
  return typeof d === "function" ? d : function() {
    return d;
  };
}
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
var __extends$T = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var WordCloud = function(_super) {
  __extends$T(WordCloud2, _super);
  function WordCloud2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "wordcloud";
    _this.renderType = RenderTypes.SVG;
    _this.handleLegendOnHover = function(event) {
      var hoveredElement = event.detail.hoveredElement;
      var groupMapsTo = _this.getOptions().data.groupMapsTo;
      _this.parent.selectAll("text.word").transition("legend-hover-wordcloud").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-hover-wordcloud"
        });
      }).attr("opacity", function(d) {
        return d[groupMapsTo] !== hoveredElement.datum()["name"] ? 0.3 : 1;
      });
    };
    _this.handleLegendMouseOut = function(event) {
      _this.parent.selectAll("text.word").transition("legend-mouseout-wordcloud").call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-wordcloud"
        });
      }).attr("opacity", 1);
    };
    return _this;
  }
  WordCloud2.prototype.init = function() {
    var eventsFragment = this.services.events;
    eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
    eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  };
  WordCloud2.prototype.render = function(animate) {
    if (animate === void 0) {
      animate = true;
    }
    var self2 = this;
    var svg = this.getComponentContainer().attr("width", "100%").attr("height", "100%");
    var displayData = this.model.getDisplayData();
    var fontSizeScale = this.getFontSizeScale(displayData);
    var options2 = this.getOptions();
    var _a2 = options2.wordCloud, fontSizeMapsTo = _a2.fontSizeMapsTo, wordMapsTo = _a2.wordMapsTo;
    var groupMapsTo = options2.data.groupMapsTo;
    var _b = DOMUtils.getSVGElementSize(svg, {
      useAttrs: true
    }), width = _b.width, height = _b.height;
    if (width === 0 || height === 0) {
      return;
    }
    var layout = d3Cloud().size([width, height]).words(displayData.map(function(d) {
      var _a3;
      return _a3 = {}, _a3[groupMapsTo] = d[groupMapsTo], _a3.text = d[wordMapsTo], _a3.size = d[fontSizeMapsTo], _a3.value = d[fontSizeMapsTo], _a3;
    })).padding(5).rotate(0).fontSize(function(d) {
      return fontSizeScale(d.size);
    }).on("end", draw);
    layout.start();
    function draw(words2) {
      var textGroup = DOMUtils.appendOrSelect(svg, "g.words");
      textGroup.attr("transform", "translate(" + layout.size()[0] / 2 + ", " + layout.size()[1] / 2 + ")");
      var allText = textGroup.selectAll("text").data(words2, function(d) {
        return d[groupMapsTo] + "-" + d.text;
      });
      allText.exit().attr("opacity", 0).remove();
      var enteringText = allText.enter().append("text").attr("opacity", 0);
      enteringText.merge(allText).style("font-size", function(d) {
        return d.size + "px";
      }).text(function(d) {
        return d.text;
      }).attr("class", function(d) {
        return self2.model.getColorClassName({
          classNameTypes: [ColorClassNameTypes.FILL],
          dataGroupName: d[groupMapsTo],
          originalClassName: "word " + (d.size > 32 ? "light" : "")
        });
      }).style("fill", function(d) {
        return self2.model.getFillColor(d[groupMapsTo], d.text, d);
      }).attr("text-anchor", "middle").transition().call(function(t) {
        return self2.services.transitions.setupTransition({
          transition: t,
          name: "wordcloud-text-update-enter",
          animate
        });
      }).attr("transform", function(d) {
        return "translate(" + d.x + ", " + d.y + ")";
      }).attr("opacity", 1);
    }
    this.addEventListeners();
  };
  WordCloud2.prototype.getFontSizeScale = function(data) {
    var options2 = this.getOptions();
    var fontSizeMapsTo = options2.wordCloud.fontSizeMapsTo;
    var allOccurences = data.map(function(d) {
      return d[fontSizeMapsTo];
    }).filter(function(size) {
      return size;
    });
    var chartSize = DOMUtils.getHTMLElementSize(this.services.domUtils.getMainContainer());
    var sizeDataIsValid = allOccurences.length > 0;
    var domain = sizeDataIsValid ? extent(allOccurences) : [1, 1];
    return linear().domain(domain).range(sizeDataIsValid ? options2.wordCloud.fontSizeRange(chartSize, data) : [4, 4]);
  };
  WordCloud2.prototype.addEventListeners = function() {
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var self2 = this;
    var debouncedHighlight = Tools.debounce(function(word) {
      var allWords = self2.parent.selectAll("text.word").transition("wordcloud-word-mouse-highlight").call(function(t) {
        return self2.services.transitions.setupTransition({
          transition: t,
          name: "wordcloud-word-mouse-highlight"
        });
      });
      if (word === null) {
        allWords.attr("opacity", 1);
      } else {
        allWords.attr("opacity", function() {
          if (word === this) {
            return 1;
          }
          return 0.3;
        });
      }
    }, 6);
    this.parent.selectAll("text.word").on("mouseover", function(event, datum2) {
      var hoveredElement = this;
      debouncedHighlight(hoveredElement);
      self2.services.events.dispatchEvent(Events$1.WordCloud.WORD_MOUSEOVER, {
        event,
        element: select(this),
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
        event,
        hoveredElement,
        items: [
          {
            label: options2.tooltip.wordLabel,
            value: datum2.text
          },
          {
            label: options2.tooltip.valueLabel,
            value: datum2.value
          },
          {
            label: options2.tooltip.groupLabel,
            value: datum2[groupMapsTo],
            class: self2.model.getColorClassName({
              classNameTypes: [ColorClassNameTypes.TOOLTIP],
              dataGroupName: datum2[groupMapsTo]
            })
          }
        ]
      });
    }).on("mousemove", function(event, datum2) {
      var hoveredElement = select(this);
      self2.services.events.dispatchEvent(Events$1.WordCloud.WORD_MOUSEMOVE, {
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("click", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.WordCloud.WORD_CLICK, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mouseout", function(event, datum2) {
      var hoveredElement = select(this);
      debouncedHighlight(null);
      self2.services.events.dispatchEvent(Events$1.WordCloud.WORD_MOUSEOUT, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
        hoveredElement
      });
    });
  };
  return WordCloud2;
}(Component);
function max$1(values, valueof) {
  let max2;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
        max2 = value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index2, values)) != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
        max2 = value2;
      }
    }
  }
  return max2;
}
function min$1(values, valueof) {
  let min2;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
        min2 = value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index2, values)) != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
        min2 = value2;
      }
    }
  }
  return min2;
}
function sum(values, valueof) {
  let sum2 = 0;
  if (valueof === void 0) {
    for (let value2 of values) {
      if (value2 = +value2) {
        sum2 += value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values) {
      if (value2 = +valueof(value2, ++index2, values)) {
        sum2 += value2;
      }
    }
  }
  return sum2;
}
function justify(node, n) {
  return node.sourceLinks.length ? node.depth : n - 1;
}
function constant$2(x2) {
  return function() {
    return x2;
  };
}
function ascendingSourceBreadth(a, b) {
  return ascendingBreadth(a.source, b.source) || a.index - b.index;
}
function ascendingTargetBreadth(a, b) {
  return ascendingBreadth(a.target, b.target) || a.index - b.index;
}
function ascendingBreadth(a, b) {
  return a.y0 - b.y0;
}
function value(d) {
  return d.value;
}
function defaultId(d) {
  return d.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find(nodeById, id2) {
  const node = nodeById.get(id2);
  if (!node)
    throw new Error("missing: " + id2);
  return node;
}
function computeLinkBreadths({ nodes }) {
  for (const node of nodes) {
    let y0 = node.y0;
    let y1 = y0;
    for (const link2 of node.sourceLinks) {
      link2.y0 = y0 + link2.width / 2;
      y0 += link2.width;
    }
    for (const link2 of node.targetLinks) {
      link2.y1 = y1 + link2.width / 2;
      y1 += link2.width;
    }
  }
}
function Sankey() {
  let x0 = 0, y0 = 0, x1 = 1, y1 = 1;
  let dx = 24;
  let dy = 8, py;
  let id2 = defaultId;
  let align = justify;
  let sort;
  let linkSort;
  let nodes = defaultNodes;
  let links = defaultLinks;
  let iterations = 6;
  function sankey() {
    const graph = { nodes: nodes.apply(null, arguments), links: links.apply(null, arguments) };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_) {
    return arguments.length ? (id2 = typeof _ === "function" ? _ : constant$2(_), sankey) : id2;
  };
  sankey.nodeAlign = function(_) {
    return arguments.length ? (align = typeof _ === "function" ? _ : constant$2(_), sankey) : align;
  };
  sankey.nodeSort = function(_) {
    return arguments.length ? (sort = _, sankey) : sort;
  };
  sankey.nodeWidth = function(_) {
    return arguments.length ? (dx = +_, sankey) : dx;
  };
  sankey.nodePadding = function(_) {
    return arguments.length ? (dy = py = +_, sankey) : dy;
  };
  sankey.nodes = function(_) {
    return arguments.length ? (nodes = typeof _ === "function" ? _ : constant$2(_), sankey) : nodes;
  };
  sankey.links = function(_) {
    return arguments.length ? (links = typeof _ === "function" ? _ : constant$2(_), sankey) : links;
  };
  sankey.linkSort = function(_) {
    return arguments.length ? (linkSort = _, sankey) : linkSort;
  };
  sankey.size = function(_) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];
  };
  sankey.extent = function(_) {
    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];
  };
  sankey.iterations = function(_) {
    return arguments.length ? (iterations = +_, sankey) : iterations;
  };
  function computeNodeLinks({ nodes: nodes2, links: links2 }) {
    for (const [i, node] of nodes2.entries()) {
      node.index = i;
      node.sourceLinks = [];
      node.targetLinks = [];
    }
    const nodeById = new Map(nodes2.map((d, i) => [id2(d, i, nodes2), d]));
    for (const [i, link2] of links2.entries()) {
      link2.index = i;
      let { source, target } = link2;
      if (typeof source !== "object")
        source = link2.source = find(nodeById, source);
      if (typeof target !== "object")
        target = link2.target = find(nodeById, target);
      source.sourceLinks.push(link2);
      target.targetLinks.push(link2);
    }
    if (linkSort != null) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(linkSort);
        targetLinks.sort(linkSort);
      }
    }
  }
  function computeNodeValues({ nodes: nodes2 }) {
    for (const node of nodes2) {
      node.value = node.fixedValue === void 0 ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value)) : node.fixedValue;
    }
  }
  function computeNodeDepths({ nodes: nodes2 }) {
    const n = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x2 = 0;
    while (current.size) {
      for (const node of current) {
        node.depth = x2;
        for (const { target } of node.sourceLinks) {
          next.add(target);
        }
      }
      if (++x2 > n)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeHeights({ nodes: nodes2 }) {
    const n = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x2 = 0;
    while (current.size) {
      for (const node of current) {
        node.height = x2;
        for (const { source } of node.targetLinks) {
          next.add(source);
        }
      }
      if (++x2 > n)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeLayers({ nodes: nodes2 }) {
    const x2 = max$1(nodes2, (d) => d.depth) + 1;
    const kx = (x1 - x0 - dx) / (x2 - 1);
    const columns = new Array(x2);
    for (const node of nodes2) {
      const i = Math.max(0, Math.min(x2 - 1, Math.floor(align.call(null, node, x2))));
      node.layer = i;
      node.x0 = x0 + i * kx;
      node.x1 = node.x0 + dx;
      if (columns[i])
        columns[i].push(node);
      else
        columns[i] = [node];
    }
    if (sort)
      for (const column of columns) {
        column.sort(sort);
      }
    return columns;
  }
  function initializeNodeBreadths(columns) {
    const ky = min$1(columns, (c) => (y1 - y0 - (c.length - 1) * py) / sum(c, value));
    for (const nodes2 of columns) {
      let y2 = y0;
      for (const node of nodes2) {
        node.y0 = y2;
        node.y1 = y2 + node.value * ky;
        y2 = node.y1 + py;
        for (const link2 of node.sourceLinks) {
          link2.width = link2.value * ky;
        }
      }
      y2 = (y1 - y2 + py) / (nodes2.length + 1);
      for (let i = 0; i < nodes2.length; ++i) {
        const node = nodes2[i];
        node.y0 += y2 * (i + 1);
        node.y1 += y2 * (i + 1);
      }
      reorderLinks(nodes2);
    }
  }
  function computeNodeBreadths(graph) {
    const columns = computeNodeLayers(graph);
    py = Math.min(dy, (y1 - y0) / (max$1(columns, (c) => c.length) - 1));
    initializeNodeBreadths(columns);
    for (let i = 0; i < iterations; ++i) {
      const alpha = Math.pow(0.99, i);
      const beta = Math.max(1 - alpha, (i + 1) / iterations);
      relaxRightToLeft(columns, alpha, beta);
      relaxLeftToRight(columns, alpha, beta);
    }
  }
  function relaxLeftToRight(columns, alpha, beta) {
    for (let i = 1, n = columns.length; i < n; ++i) {
      const column = columns[i];
      for (const target of column) {
        let y2 = 0;
        let w = 0;
        for (const { source, value: value2 } of target.targetLinks) {
          let v = value2 * (target.layer - source.layer);
          y2 += targetTop(source, target) * v;
          w += v;
        }
        if (!(w > 0))
          continue;
        let dy2 = (y2 / w - target.y0) * alpha;
        target.y0 += dy2;
        target.y1 += dy2;
        reorderNodeLinks(target);
      }
      if (sort === void 0)
        column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  }
  function relaxRightToLeft(columns, alpha, beta) {
    for (let n = columns.length, i = n - 2; i >= 0; --i) {
      const column = columns[i];
      for (const source of column) {
        let y2 = 0;
        let w = 0;
        for (const { target, value: value2 } of source.sourceLinks) {
          let v = value2 * (target.layer - source.layer);
          y2 += sourceTop(source, target) * v;
          w += v;
        }
        if (!(w > 0))
          continue;
        let dy2 = (y2 / w - source.y0) * alpha;
        source.y0 += dy2;
        source.y1 += dy2;
        reorderNodeLinks(source);
      }
      if (sort === void 0)
        column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  }
  function resolveCollisions(nodes2, alpha) {
    const i = nodes2.length >> 1;
    const subject = nodes2[i];
    resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i + 1, alpha);
    resolveCollisionsBottomToTop(nodes2, y1, nodes2.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, y0, 0, alpha);
  }
  function resolveCollisionsTopToBottom(nodes2, y2, i, alpha) {
    for (; i < nodes2.length; ++i) {
      const node = nodes2[i];
      const dy2 = (y2 - node.y0) * alpha;
      if (dy2 > 1e-6)
        node.y0 += dy2, node.y1 += dy2;
      y2 = node.y1 + py;
    }
  }
  function resolveCollisionsBottomToTop(nodes2, y2, i, alpha) {
    for (; i >= 0; --i) {
      const node = nodes2[i];
      const dy2 = (node.y1 - y2) * alpha;
      if (dy2 > 1e-6)
        node.y0 -= dy2, node.y1 -= dy2;
      y2 = node.y0 - py;
    }
  }
  function reorderNodeLinks({ sourceLinks, targetLinks }) {
    if (linkSort === void 0) {
      for (const { source: { sourceLinks: sourceLinks2 } } of targetLinks) {
        sourceLinks2.sort(ascendingTargetBreadth);
      }
      for (const { target: { targetLinks: targetLinks2 } } of sourceLinks) {
        targetLinks2.sort(ascendingSourceBreadth);
      }
    }
  }
  function reorderLinks(nodes2) {
    if (linkSort === void 0) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(ascendingTargetBreadth);
        targetLinks.sort(ascendingSourceBreadth);
      }
    }
  }
  function targetTop(source, target) {
    let y2 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target)
        break;
      y2 += width + py;
    }
    for (const { source: node, width } of target.targetLinks) {
      if (node === source)
        break;
      y2 -= width;
    }
    return y2;
  }
  function sourceTop(source, target) {
    let y2 = target.y0 - (target.targetLinks.length - 1) * py / 2;
    for (const { source: node, width } of target.targetLinks) {
      if (node === source)
        break;
      y2 += width + py;
    }
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target)
        break;
      y2 -= width;
    }
    return y2;
  }
  return sankey;
}
var pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
function Path() {
  this._x0 = this._y0 = this._x1 = this._y1 = null;
  this._ = "";
}
function path() {
  return new Path();
}
Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x2, y2) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x2, y2) {
    this._ += "L" + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  quadraticCurveTo: function(x1, y1, x2, y2) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else if (!(l01_2 > epsilon))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else {
      var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }
      this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw2 = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }
    if (!r)
      return;
    if (da < 0)
      da = da % tau + tau;
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw2 + "," + (x2 - dx) + "," + (y2 - dy) + "A" + r + "," + r + ",0,1," + cw2 + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    } else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw2 + "," + (this._x1 = x2 + r * Math.cos(a1)) + "," + (this._y1 = y2 + r * Math.sin(a1));
    }
  },
  rect: function(x2, y2, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2) + "h" + +w + "v" + +h + "h" + -w + "Z";
  },
  toString: function() {
    return this._;
  }
};
function constant$1(x2) {
  return function constant2() {
    return x2;
  };
}
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}
var slice = Array.prototype.slice;
function linkSource(d) {
  return d.source;
}
function linkTarget(d) {
  return d.target;
}
function link(curve) {
  var source = linkSource, target = linkTarget, x$12 = x, y$12 = y, context = null;
  function link2() {
    var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
    if (!context)
      context = buffer = path();
    curve(context, +x$12.apply(this, (argv[0] = s, argv)), +y$12.apply(this, argv), +x$12.apply(this, (argv[0] = t, argv)), +y$12.apply(this, argv));
    if (buffer)
      return context = null, buffer + "" || null;
  }
  link2.source = function(_) {
    return arguments.length ? (source = _, link2) : source;
  };
  link2.target = function(_) {
    return arguments.length ? (target = _, link2) : target;
  };
  link2.x = function(_) {
    return arguments.length ? (x$12 = typeof _ === "function" ? _ : constant$1(+_), link2) : x$12;
  };
  link2.y = function(_) {
    return arguments.length ? (y$12 = typeof _ === "function" ? _ : constant$1(+_), link2) : y$12;
  };
  link2.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, link2) : context;
  };
  return link2;
}
function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}
function linkHorizontal() {
  return link(curveHorizontal);
}
function horizontalSource(d) {
  return [d.source.x1, d.y0];
}
function horizontalTarget(d) {
  return [d.target.x0, d.y1];
}
function sankeyLinkHorizontal() {
  return linkHorizontal().source(horizontalSource).target(horizontalTarget);
}
var __extends$S = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Alluvial = function(_super) {
  __extends$S(Alluvial2, _super);
  function Alluvial2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "alluvial";
    _this.renderType = RenderTypes.SVG;
    _this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999);
    return _this;
  }
  Alluvial2.prototype.render = function(animate) {
    var _this = this;
    var svg = this.getComponentContainer({ withinChartClip: true });
    svg.html("");
    var _a2 = DOMUtils.getSVGElementSize(svg, {
      useAttrs: true
    }), width = _a2.width, height = _a2.height;
    if (width < 1 || height < 1) {
      return;
    }
    var options2 = this.model.getOptions();
    var data = this.model.getDisplayData();
    var isGradientAllowed = Tools.getProperty(this.getOptions(), "color", "gradient", "enabled");
    var nodePadding = alluvial.minNodePadding;
    if (options2.alluvial.nodePadding > alluvial.minNodePadding) {
      nodePadding = options2.alluvial.nodePadding;
    }
    var sankey = Sankey().nodeId(function(d) {
      return d.name;
    }).nodeWidth(alluvial.nodeWidth).nodePadding(nodePadding).extent([
      [2, 30],
      [width - 2, height]
    ]);
    this.graph = sankey({
      nodes: options2.alluvial.nodes.map(function(d) {
        return Object.assign({}, d);
      }),
      links: data.map(function(d) {
        return Object.assign({}, d);
      })
    });
    this.graph.nodes = this.graph.nodes.filter(function(node2) {
      return node2.value !== 0;
    });
    var nodeCoordinates = {};
    this.graph.nodes.forEach(function(element) {
      var _a3;
      var point2 = element.x0;
      if (element.category) {
        nodeCoordinates[point2] = (_a3 = element) === null || _a3 === void 0 ? void 0 : _a3.category;
      }
    });
    var alluvialCategory = svg.append("g").classed("header-arrows", true).selectAll("g").data(Object.keys(nodeCoordinates)).join("g").attr("transform", function(d) {
      return "translate(" + d + ", 0)";
    });
    alluvialCategory.append("text").attr("id", function(d, i) {
      return _this.services.domUtils.generateElementIDString("alluvial-category-" + i);
    }).style("font-size", "14px").text(function(d) {
      if (nodeCoordinates[d]) {
        return nodeCoordinates[d];
      }
      return "";
    }).attr("y", 20).attr("x", function(d, i) {
      var elementID = _this.services.domUtils.generateElementIDString("alluvial-category-" + i);
      var width2 = DOMUtils.getSVGElementSize(select("text#" + elementID), { useBBox: true }).width;
      var x2 = 0;
      if (d + x2 >= width2) {
        x2 = -width2 + 4;
      }
      return x2;
    });
    var links = svg.append("g").attr("fill", "none").selectAll("g").data(this.graph.links);
    links.exit().remove();
    if (isGradientAllowed) {
      var scale_1 = Tools.getProperty(this.getOptions(), "color", "scale");
      if (scale_1) {
        links.enter().append("linearGradient").attr("id", function(d) {
          return _this.gradient_id + "-link-" + d.index;
        }).attr("gradientUnits", "userSpaceOnUse").call(function(gradient) {
          return gradient.append("stop").attr("offset", "0%").attr("stop-color", function(d) {
            return scale_1[d.source.name];
          });
        }).call(function(gradient) {
          return gradient.append("stop").attr("offset", "100%").attr("stop-color", function(d) {
            return scale_1[d.target.name];
          });
        });
      }
      links.exit().remove();
    }
    links.enter().append("path").classed("link", true).attr("d", sankeyLinkHorizontal()).attr("id", function(d) {
      return _this.services.domUtils.generateElementIDString("alluvial-line-" + d.index);
    }).attr("class", function(d) {
      if (options2.alluvial.monochrome) {
        return _this.model.getColorClassName({
          classNameTypes: [ColorClassNameTypes.STROKE],
          dataGroupName: 0,
          originalClassName: "link"
        });
      }
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.STROKE],
        dataGroupName: d.source.index,
        originalClassName: "link"
      });
    }).style("stroke", function(d) {
      if (isGradientAllowed) {
        return "url(#" + _this.gradient_id + "-link-" + d.index + ")";
      }
      return _this.model.getFillColor(d.source.name);
    }).attr("stroke-width", function(d) {
      return Math.max(1, d.width);
    }).style("stroke-opacity", alluvial.opacity.default).attr("aria-label", function(d) {
      return d.source.name + " \u2192 " + d.target.name + " (" + d.value + (options2.alluvial.units ? " " + options2.alluvial.units : "") + ")";
    });
    var node = svg.append("g").selectAll("g").data(this.graph.nodes).enter().append("g").attr("id", function(d) {
      return _this.services.domUtils.generateElementIDString("alluvial-node-" + d.index);
    }).classed("node-group", true).attr("transform", function(d) {
      return "translate(" + d.x0 + ", " + d.y0 + ")";
    });
    node.append("rect").classed("node", true).attr("height", function(d) {
      return d.y1 - d.y0;
    }).attr("width", function(d) {
      return d.x1 - d.x0;
    }).attr("fill", "black");
    var textNode = node.append("g").attr("id", function(d) {
      return _this.services.domUtils.generateElementIDString("alluvial-node-title-" + d.index);
    });
    textNode.append("text").attr("id", function(d) {
      return _this.services.domUtils.generateElementIDString("alluvial-node-text-" + d.index);
    }).attr("class", "node-text").style("font-size", "12px").attr("text-anchor", "start").attr("fill", "white").attr("x", 4).attr("dy", 13).text(function(d) {
      return d.name + " (" + d.value + ")";
    }).attr("aria-label", function(d) {
      return d.name + " (" + d.value + ")";
    });
    textNode.append("rect").classed("node-text-bg", true).attr("width", function(d, i) {
      var elementID = _this.services.domUtils.generateElementIDString("alluvial-node-text-" + i);
      var width2 = DOMUtils.getSVGElementSize(select("text#" + elementID), { useBBox: true }).width;
      return width2 + 8;
    }).attr("height", 18).attr("stroke-width", 2).lower();
    textNode.attr("transform", function(d, i) {
      var elementID = _this.services.domUtils.generateElementIDString("alluvial-node-text-" + i);
      var width2 = DOMUtils.getSVGElementSize(select("text#" + elementID), { useBBox: true }).width;
      var y2 = (d.y1 - d.y0) / 2 - 9;
      var x2 = d.x1 - d.x0;
      if (d.x1 >= width2) {
        x2 = x2 - (width2 + 16);
      } else {
        x2 += 4;
      }
      return "translate(" + x2 + ", " + y2 + ")";
    });
    this.addLineEventListener();
    this.addNodeEventListener();
  };
  Alluvial2.prototype.addLineEventListener = function() {
    var options2 = this.getOptions();
    var self2 = this;
    var debouncedLineHighlight = Tools.debounce(function(link2, event) {
      if (event === void 0) {
        event = "mouseover";
      }
      var allLinks = self2.parent.selectAll("path.link").transition().call(function(t) {
        return self2.services.transitions.setupTransition({
          transition: t,
          name: "alluvial-links-mouse-highlight"
        });
      });
      if (event === "mouseout") {
        select(link2).lower();
        allLinks.style("stroke-opacity", alluvial.opacity.default);
      } else {
        allLinks.style("stroke-opacity", function() {
          if (link2 === this) {
            select(this).raise();
            return alluvial.opacity.selected;
          }
          return alluvial.opacity.unfocus;
        });
      }
    }, 33);
    this.parent.selectAll("path.link").on("mouseover", function(event, datum2) {
      var hoveredElement = select(this);
      debouncedLineHighlight(this, "mouseover");
      hoveredElement.classed("link-hovered", true);
      var strokeColor = getComputedStyle(this).getPropertyValue("stroke");
      self2.services.events.dispatchEvent(Events$1.Alluvial.LINE_MOUSEOVER, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
        event,
        hoveredElement,
        items: [
          {
            label: datum2.target.name,
            value: datum2.value + (options2.alluvial.units ? " " + options2.alluvial.units : ""),
            color: strokeColor,
            labelIcon: self2.getRightArrowIcon()
          }
        ]
      });
    }).on("mousemove", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Alluvial.LINE_MOUSEMOVE, {
        event,
        element: select(this),
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("click", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Alluvial.LINE_CLICK, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mouseout", function(event, datum2) {
      var hoveredElement = select(this);
      debouncedLineHighlight(this, "mouseout");
      hoveredElement.classed("link-hovered", false);
      self2.services.events.dispatchEvent(Events$1.Alluvial.LINE_MOUSEOUT, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
        event,
        hoveredElement
      });
    });
  };
  Alluvial2.prototype.addNodeEventListener = function() {
    var _this = this;
    var self2 = this;
    var debouncedLineHighlight = Tools.debounce(function(links, event) {
      if (links === void 0) {
        links = [];
      }
      if (event === void 0) {
        event = "mouseover";
      }
      if (event === "mouseout" || links.length === 0) {
        self2.parent.selectAll("path.link").classed("link-hovered", false).data(_this.graph.links, function(d) {
          return d.index;
        }).order().style("stroke-opacity", alluvial.opacity.default);
        return;
      }
      var allLinks = self2.parent.selectAll("path.link").transition().call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "alluvial-link-mouse-highlight"
        });
      });
      allLinks.style("stroke-opacity", function(d) {
        if (links.some(function(element) {
          return element === d.index;
        })) {
          select(this).classed("link-hovered", true).raise();
          return alluvial.opacity.selected;
        }
        return alluvial.opacity.unfocus;
      });
    }, 66);
    self2.parent.selectAll(".node-group").on("mouseover", function(event, datum2) {
      var hoveredElement = select(this);
      var paths = [];
      self2.traverse({ link: "sourceLinks", node: "target" }, datum2, paths);
      self2.traverse({ link: "targetLinks", node: "source" }, datum2, paths);
      if (paths.length) {
        var nodeMatrix = Tools.getTranformOffsets(hoveredElement.attr("transform"));
        hoveredElement.attr("transform", "translate(" + (nodeMatrix.x - 2) + ", " + nodeMatrix.y + ")");
        hoveredElement.classed("node-hovered", true).selectAll("rect.node").attr("width", 8);
        if (datum2.x0 - 2 === 0) {
          var elementID_1 = self2.services.domUtils.generateElementIDString("alluvial-node-title-" + datum2.index);
          var titleContainer = self2.parent.select("g#" + elementID_1);
          var titleMatrix = Tools.getTranformOffsets(titleContainer.attr("transform"));
          titleContainer.attr("transform", "translate(" + (titleMatrix.x + 4) + "," + titleMatrix.y + ")");
        }
        var elementID = self2.services.domUtils.generateElementIDString("alluvial-node-text-" + datum2.index);
        self2.parent.select("text#" + elementID).style("font-weight", "bold");
        debouncedLineHighlight(paths, "mouseover");
        self2.services.events.dispatchEvent(Events$1.Alluvial.NODE_MOUSEOVER, {
          event,
          element: hoveredElement,
          datum: datum2
        });
      }
    }).on("mousemove", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Alluvial.NODE_MOUSEMOVE, {
        event,
        element: select(this),
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("click", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Alluvial.NODE_CLICK, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mouseout", function(event, datum2) {
      var hoveredElement = select(this);
      var nodeMatrix = Tools.getTranformOffsets(hoveredElement.attr("transform"));
      hoveredElement.classed("node-hovered", false).attr("transform", "translate(" + (nodeMatrix.x + 2) + ", " + nodeMatrix.y + ")").select("rect.node").attr("width", alluvial.nodeWidth);
      if (datum2.x0 - 2 === 0) {
        var elementID_2 = self2.services.domUtils.generateElementIDString("alluvial-node-title-" + datum2.index);
        var titleContainer = self2.parent.select("g#" + elementID_2);
        var titleMatrix = Tools.getTranformOffsets(titleContainer.attr("transform"));
        titleContainer.attr("transform", "translate(" + (titleMatrix.x - 4) + "," + titleMatrix.y + ")");
      }
      var elementID = self2.services.domUtils.generateElementIDString("alluvial-node-text-" + datum2.index);
      self2.parent.select("text#" + elementID).style("font-weight", "normal");
      debouncedLineHighlight([], "mouseout");
      self2.services.events.dispatchEvent(Events$1.Alluvial.NODE_MOUSEOUT, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
        hoveredElement
      });
    });
  };
  Alluvial2.prototype.traverse = function(direction, node, visited) {
    var _this = this;
    if (visited === void 0) {
      visited = [];
    }
    var links = node[direction.link].map(function(element) {
      visited.push(element.index);
      return element[direction.node];
    });
    links.forEach(function(element) {
      return _this.traverse(direction, element, visited);
    });
  };
  Alluvial2.prototype.getRightArrowIcon = function() {
    return '\n		<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">\n			<polygon points="18 6 16.57 7.393 24.15 15 4 15 4 17 24.15 17 16.57 24.573 18 26 28 16 18 6"/>\n			<rect  data-name="&lt;Transparent Rectangle&gt;" style="fill: none;" width="32" height="32"/>\n		</svg>';
  };
  Alluvial2.prototype.destroy = function() {
    this.parent.selectAll("path.line,.node-group").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
  };
  return Alluvial2;
}(Component);
var __extends$R = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Heatmap = function(_super) {
  __extends$R(Heatmap2, _super);
  function Heatmap2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "heatmap";
    _this.renderType = RenderTypes.SVG;
    _this.matrix = {};
    _this.xBandwidth = 0;
    _this.yBandwidth = 0;
    _this.translationUnits = {
      x: 0,
      y: 0
    };
    _this.handleAxisOnHover = function(event) {
      var detail = event.detail;
      var datum2 = detail.datum;
      var ranges = _this.model.getUniqueRanges();
      var domains = _this.model.getUniqueDomain();
      var domainLabel = _this.services.cartesianScales.getDomainLabel();
      var rangeLabel = _this.services.cartesianScales.getRangeLabel();
      var mainXScale = _this.services.cartesianScales.getMainXScale();
      var mainYScale = _this.services.cartesianScales.getMainYScale();
      var label = "", sum2 = 0, minimum = 0, maximum = 0;
      if (_this.matrix[datum2] !== void 0) {
        label = domainLabel;
        ranges.forEach(function(element) {
          var value2 = _this.matrix[datum2][element].value || 0;
          sum2 += value2;
          minimum = value2 < minimum ? value2 : minimum;
          maximum = value2 > maximum ? value2 : maximum;
        });
      } else {
        label = rangeLabel;
        domains.forEach(function(element) {
          var value2 = _this.matrix[element][datum2].value || 0;
          sum2 += value2;
          minimum = value2 < minimum ? value2 : minimum;
          maximum = value2 > maximum ? value2 : maximum;
        });
      }
      if (mainXScale(datum2) !== void 0) {
        _this.parent.select("g.multi-cell.column-highlight").classed("highlighter-hidden", false).attr("transform", "translate(" + mainXScale(datum2) + ", " + min$3(mainYScale.range()) + ")");
      } else if (mainYScale(datum2) !== void 0) {
        _this.parent.select("g.multi-cell.row-highlight").classed("highlighter-hidden", false).attr("transform", "translate(" + min$3(mainXScale.range()) + "," + mainYScale(datum2) + ")");
      }
      _this.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
        event: detail.event,
        hoveredElement: select(event.detail.element),
        items: [
          {
            label,
            value: datum2,
            bold: true
          },
          {
            label: "Min",
            value: minimum
          },
          {
            label: "Max",
            value: maximum
          },
          {
            label: "Average",
            value: sum2 / domains.length
          }
        ]
      });
    };
    _this.handleAxisMouseOut = function(event) {
      _this.parent.selectAll("g.multi-cell").classed("highlighter-hidden", true);
      _this.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
        event
      });
    };
    return _this;
  }
  Heatmap2.prototype.init = function() {
    var eventsFragment = this.services.events;
    eventsFragment.addEventListener(Events$1.Axis.LABEL_MOUSEOVER, this.handleAxisOnHover);
    eventsFragment.addEventListener(Events$1.Axis.LABEL_MOUSEOUT, this.handleAxisMouseOut);
    eventsFragment.addEventListener(Events$1.Axis.LABEL_FOCUS, this.handleAxisOnHover);
    eventsFragment.addEventListener(Events$1.Axis.LABEL_BLUR, this.handleAxisMouseOut);
  };
  Heatmap2.prototype.render = function(animate) {
    var _this = this;
    var svg = this.getComponentContainer({ withinChartClip: true });
    svg.lower();
    var cartesianScales = this.services.cartesianScales;
    this.matrix = this.model.getMatrix();
    svg.html("");
    if (Tools.getProperty(this.getOptions(), "data", "loading")) {
      return;
    }
    var mainXScale = cartesianScales.getMainXScale();
    var mainYScale = cartesianScales.getMainYScale();
    var domainIdentifier = cartesianScales.getDomainIdentifier();
    var rangeIdentifier = cartesianScales.getRangeIdentifier();
    var uniqueDomain = this.model.getUniqueDomain();
    var uniqueRange = this.model.getUniqueRanges();
    var matrixArray = this.model.getMatrixAsArray();
    var xRange = mainXScale.range();
    var yRange = mainYScale.range();
    this.xBandwidth = Math.abs((xRange[1] - xRange[0]) / uniqueDomain.length);
    this.yBandwidth = Math.abs((yRange[1] - yRange[0]) / uniqueRange.length);
    var patternID = this.services.domUtils.generateElementIDString("heatmap-pattern-stripes");
    svg.append("defs").append("pattern").attr("id", patternID).attr("width", 3).attr("height", 3).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("rect").classed("pattern-fill", true).attr("width", 0.5).attr("height", 8);
    var rectangles = svg.selectAll().data(matrixArray).enter().append("g").attr("class", function(d) {
      return "heat-" + d.index;
    }).classed("cell", true).attr("transform", function(d) {
      return "translate(" + mainXScale(d[domainIdentifier]) + ", " + mainYScale(d[rangeIdentifier]) + ")";
    }).append("rect").attr("class", function(d) {
      return _this.model.getColorClassName({
        value: d.value,
        originalClassName: "heat-" + d.index
      });
    }).classed("heat", true).classed("null-state", function(d) {
      return d.index === -1 || d.value === null ? true : false;
    }).attr("width", this.xBandwidth).attr("height", this.yBandwidth).style("fill", function(d) {
      if (d.index === -1 || d.value === null) {
        return "url(#" + patternID + ")";
      }
      return _this.model.getFillColor(Number(d.value));
    }).attr("aria-label", function(d) {
      return d.value;
    });
    this.createOuterBox("g.cell-highlight", this.xBandwidth, this.yBandwidth);
    this.createOuterBox("g.multi-cell.column-highlight", this.xBandwidth, Math.abs(yRange[1] - yRange[0]));
    this.createOuterBox("g.multi-cell.row-highlight", Math.abs(xRange[1] - xRange[0]), this.yBandwidth);
    if (this.determineDividerStatus()) {
      rectangles.style("stroke-width", "1px");
      this.parent.select("g.cell-highlight").classed("cell-2", true);
    }
    this.addEventListener();
  };
  Heatmap2.prototype.createOuterBox = function(parentTag, xBandwidth, yBandwidth) {
    var highlight = DOMUtils.appendOrSelect(this.parent, parentTag).classed("shadows", true).classed("highlighter-hidden", true);
    DOMUtils.appendOrSelect(highlight, "line.top").attr("x1", -1).attr("x2", xBandwidth + 1);
    DOMUtils.appendOrSelect(highlight, "line.left").attr("x1", 0).attr("y1", -1).attr("x2", 0).attr("y2", yBandwidth + 1);
    DOMUtils.appendOrSelect(highlight, "line.down").attr("x1", -1).attr("x2", xBandwidth + 1).attr("y1", yBandwidth).attr("y2", yBandwidth);
    DOMUtils.appendOrSelect(highlight, "line.right").attr("x1", xBandwidth).attr("x2", xBandwidth).attr("y1", -1).attr("y2", yBandwidth + 1);
  };
  Heatmap2.prototype.determineDividerStatus = function() {
    var dividerStatus = Tools.getProperty(this.getOptions(), "heatmap", "divider", "state");
    if (dividerStatus !== DividerStatus.OFF) {
      if (dividerStatus === DividerStatus.AUTO && heatmap.minCellDividerDimension <= this.xBandwidth && heatmap.minCellDividerDimension <= this.yBandwidth || dividerStatus === DividerStatus.ON) {
        return true;
      }
    }
    return false;
  };
  Heatmap2.prototype.addEventListener = function() {
    var self2 = this;
    var cartesianScales = this.services.cartesianScales;
    var options2 = this.getOptions();
    var totalLabel = get$3(options2, "tooltip.totalLabel");
    var domainIdentifier = cartesianScales.getDomainIdentifier();
    var rangeIdentifier = cartesianScales.getRangeIdentifier();
    var domainLabel = cartesianScales.getDomainLabel();
    var rangeLabel = cartesianScales.getRangeLabel();
    this.parent.selectAll("g.cell").on("mouseover", function(event, datum2) {
      var cell = select(this);
      var hoveredElement = cell.select("rect.heat");
      var nullState = hoveredElement.classed("null-state");
      if (!nullState) {
        var transform = Tools.getTranformOffsets(cell.attr("transform"));
        select("g.cell-highlight").attr("transform", "translate(" + (transform.x + self2.translationUnits.x) + ", " + (transform.y + self2.translationUnits.y) + ")").classed("highlighter-hidden", false);
        self2.services.events.dispatchEvent(Events$1.Heatmap.HEATMAP_MOUSEOVER, {
          event,
          element: hoveredElement,
          datum: datum2
        });
        self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
          event,
          items: [
            {
              label: domainLabel,
              value: datum2[domainIdentifier]
            },
            {
              label: rangeLabel,
              value: datum2[rangeIdentifier]
            },
            {
              label: totalLabel || "Total",
              value: datum2["value"],
              color: hoveredElement.style("fill")
            }
          ]
        });
      }
    }).on("mousemove", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Heatmap.HEATMAP_MOUSEMOVE, {
        event,
        element: select(this),
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("click", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Heatmap.HEATMAP_CLICK, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mouseout", function(event, datum2) {
      var cell = select(this);
      var hoveredElement = cell.select("rect.heat");
      var nullState = hoveredElement.classed("null-state");
      select("g.cell-highlight").classed("highlighter-hidden", true);
      if (!nullState) {
        self2.services.events.dispatchEvent(Events$1.Heatmap.HEATMAP_MOUSEOUT, {
          event,
          element: hoveredElement,
          datum: datum2
        });
        self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
          event,
          hoveredElement
        });
      }
    });
  };
  Heatmap2.prototype.destroy = function() {
    this.parent.selectAll("rect.heat").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
    var eventsFragment = this.services.events;
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleAxisOnHover);
    eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleAxisMouseOut);
  };
  return Heatmap2;
}(Component);
var __extends$Q = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Spacer = function(_super) {
  __extends$Q(Spacer2, _super);
  function Spacer2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "spacer";
    return _this;
  }
  Spacer2.prototype.render = function() {
    this.getComponentContainer().style("width", (this.configs.size || spacers.default.size) + "px").style("height", (this.configs.size || spacers.default.size) + "px").attr("opacity", 0);
  };
  return Spacer2;
}(Component);
var __extends$P = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var LayoutComponent = function(_super) {
  __extends$P(LayoutComponent2, _super);
  function LayoutComponent2(model, services, children2, configs) {
    var _this = _super.call(this, model, services, configs) || this;
    _this.type = "layout";
    _this.configs = configs;
    _this.children = children2;
    _this._instanceID = LayoutComponent2.instanceID++;
    _this.init();
    return _this;
  }
  LayoutComponent2.prototype.init = function() {
    this.children.forEach(function(child) {
      child.components.forEach(function(component) {
        component.init();
      });
    });
  };
  LayoutComponent2.prototype.getPreferedAndFixedSizeSum = function() {
    var svg = this.parent;
    var sum2 = 0;
    svg.selectAll("div.layout-child-" + this._instanceID).filter(function(d) {
      var growth = Tools.getProperty(d, "growth");
      return growth === LayoutGrowth.PREFERRED || growth === LayoutGrowth.FIXED;
    }).each(function(d) {
      sum2 += d.size;
    });
    return sum2;
  };
  LayoutComponent2.prototype.getNumOfStretchChildren = function() {
    var svg = this.parent;
    return svg.selectAll("div.layout-child-" + this._instanceID).filter(function(d) {
      return Tools.getProperty(d, "growth") === LayoutGrowth.STRETCH;
    }).size();
  };
  LayoutComponent2.prototype.render = function(animate) {
    var _this = this;
    if (animate === void 0) {
      animate = true;
    }
    var parent = this.parent;
    var _a2 = DOMUtils.getHTMLElementSize(parent.node()), width = _a2.width, height = _a2.height;
    var horizontal = this.configs.direction === LayoutDirection.ROW || this.configs.direction === LayoutDirection.ROW_REVERSE;
    var chartprefix = Tools.getProperty(this.model.getOptions(), "style", "prefix");
    var updatedBoxes = parent.classed(settings$1.prefix + "--" + chartprefix + "--layout-row", this.configs.direction === LayoutDirection.ROW).classed(settings$1.prefix + "--" + chartprefix + "--layout-row-reverse", this.configs.direction === LayoutDirection.ROW_REVERSE).classed(settings$1.prefix + "--" + chartprefix + "--layout-column", this.configs.direction === LayoutDirection.COLUMN).classed(settings$1.prefix + "--" + chartprefix + "--layout-column-reverse", this.configs.direction === LayoutDirection.COLUMN_REVERSE).classed(settings$1.prefix + "--" + chartprefix + "--layout-alignitems-center", this.configs.alignItems === LayoutAlignItems.CENTER).selectAll("div.layout-child-" + this._instanceID).data(this.children, function(d) {
      return d.id;
    });
    var enteringBoxes = updatedBoxes.enter().append("div");
    enteringBoxes.merge(parent.selectAll("div.layout-child-" + this._instanceID)).attr("class", function(d) {
      return "layout-child layout-child-" + _this._instanceID + " " + d.id;
    }).each(function(d) {
      var _this2 = this;
      d.components.forEach(function(itemComponent) {
        var selection2 = select(_this2);
        var renderType = Tools.getProperty(d, "renderType");
        var isRenderingSVG = renderType === RenderTypes.SVG;
        itemComponent.setParent(isRenderingSVG ? DOMUtils.appendOrSelect(selection2, "svg.layout-svg-wrapper").attr("width", "100%").attr("height", "100%") : selection2);
        var growth = Tools.getProperty(d, "growth");
        if (growth === LayoutGrowth.PREFERRED || growth === LayoutGrowth.FIXED) {
          itemComponent.render(animate);
        }
      });
    });
    parent.selectAll("div.layout-child-" + this._instanceID).style("height", null).style("width", null).each(function(d) {
      var growth = Tools.getProperty(d, "growth");
      var renderType = Tools.getProperty(d, "renderType");
      var matchingElementDimensions = renderType === RenderTypes.SVG ? DOMUtils.getSVGElementSize(select(this).select("svg.layout-svg-wrapper"), {
        useBBox: true
      }) : DOMUtils.getHTMLElementSize(this);
      if (growth === LayoutGrowth.PREFERRED) {
        var matchingElementWidth = horizontal ? matchingElementDimensions.width : matchingElementDimensions.height;
        var elementWidth = horizontal ? width : height;
        d.size = matchingElementWidth / elementWidth * 100;
      }
    });
    updatedBoxes.exit().remove();
    this.children.filter(function(child) {
      var growth = Tools.getProperty(child, "growth");
      return growth === LayoutGrowth.STRETCH;
    }).forEach(function(child, i) {
      child.size = (100 - +_this.getPreferedAndFixedSizeSum()) / +_this.getNumOfStretchChildren();
    });
    var allUpdatedBoxes = parent.selectAll("div.layout-child-" + this._instanceID).data(this.children, function(d) {
      return d.id;
    });
    if (horizontal) {
      allUpdatedBoxes.style("width", function(d) {
        return d.size / 100 * width + "px";
      }).style("height", "100%");
    } else {
      allUpdatedBoxes.style("height", function(d) {
        return d.size / 100 * height + "px";
      }).style("width", "100%");
    }
    allUpdatedBoxes.each(function(d, i) {
      d.components.forEach(function(itemComponent) {
        var growth = Tools.getProperty(d, "growth");
        if (growth === LayoutGrowth.STRETCH) {
          itemComponent.render(animate);
        }
      });
    });
  };
  LayoutComponent2.prototype.setModel = function(newObj) {
    _super.prototype.setModel.call(this, newObj);
    this.children.forEach(function(child) {
      child.components.forEach(function(component) {
        return component.setModel(newObj);
      });
    });
  };
  LayoutComponent2.prototype.setServices = function(newObj) {
    _super.prototype.setServices.call(this, newObj);
    this.children.forEach(function(child) {
      child.components.forEach(function(component) {
        return component.setServices(newObj);
      });
    });
  };
  LayoutComponent2.prototype.destroy = function() {
    this.children.forEach(function(child) {
      child.components.forEach(function(component) {
        return component.destroy();
      });
    });
  };
  LayoutComponent2.instanceID = Math.floor(Math.random() * 99999999999);
  return LayoutComponent2;
}(Component);
var __extends$O = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Axis = function(_super) {
  __extends$O(Axis2, _super);
  function Axis2(model, services, configs) {
    var _a2;
    var _this = _super.call(this, model, services, configs) || this;
    _this.type = "axes";
    _this.renderType = RenderTypes.SVG;
    _this.truncation = (_a2 = {}, _a2[AxisPositions.LEFT] = false, _a2[AxisPositions.RIGHT] = false, _a2[AxisPositions.TOP] = false, _a2[AxisPositions.BOTTOM] = false, _a2);
    if (configs) {
      _this.configs = configs;
    }
    _this.margins = _this.configs.margins;
    return _this;
  }
  Axis2.prototype.render = function(animate) {
    var _this = this;
    if (animate === void 0) {
      animate = true;
    }
    var axisPosition = this.configs.position;
    var options2 = this.getOptions();
    var isAxisVisible = Tools.getProperty(options2, "axes", axisPosition, "visible");
    var svg = this.getComponentContainer();
    var _a2 = DOMUtils.getSVGElementSize(svg, {
      useAttrs: true
    }), width = _a2.width, height = _a2.height;
    var container = DOMUtils.appendOrSelect(svg, "g.axis." + axisPosition);
    var startPosition, endPosition;
    if (axisPosition === AxisPositions.BOTTOM || axisPosition === AxisPositions.TOP) {
      startPosition = this.configs.axes[AxisPositions.LEFT] ? this.margins.left : 0;
      endPosition = this.configs.axes[AxisPositions.RIGHT] ? width - this.margins.right : width;
    } else {
      startPosition = height - this.margins.bottom;
      endPosition = this.margins.top;
    }
    var scale = this.services.cartesianScales.getScaleByPosition(axisPosition);
    if (this.scaleType === ScaleTypes.LABELS || this.scaleType === ScaleTypes.LABELS_RATIO) {
      scale.rangeRound([startPosition, endPosition]);
    } else {
      scale.range([startPosition, endPosition]);
    }
    var axisFunction;
    switch (axisPosition) {
      case AxisPositions.LEFT:
        axisFunction = axisLeft;
        break;
      case AxisPositions.BOTTOM:
        axisFunction = axisBottom;
        break;
      case AxisPositions.RIGHT:
        axisFunction = axisRight;
        break;
      case AxisPositions.TOP:
        axisFunction = axisTop;
        break;
    }
    container.attr("aria-label", axisPosition + " axis");
    var axisRefExists = !container.select("g.ticks").empty();
    var axisRef = DOMUtils.appendOrSelect(container, "g.ticks");
    if (!axisRefExists) {
      axisRef.attr("role", Roles.GRAPHICS_OBJECT + " " + Roles.GROUP);
      axisRef.attr("aria-label", axisPosition + " ticks");
    }
    var invisibleAxisRef = DOMUtils.appendOrSelect(container, "g.ticks.invisible").style("opacity", "0").style("pointer-events", "none").attr("aria-hidden", true).attr("aria-label", "invisible " + axisPosition + " ticks");
    var axisOptions = Tools.getProperty(options2, "axes", axisPosition);
    var isTimeScaleType = this.scaleType === ScaleTypes.TIME || axisOptions.scaleType === ScaleTypes.TIME;
    var isVerticalAxis = axisPosition === AxisPositions.LEFT || axisPosition === AxisPositions.RIGHT;
    var zoomDomain = this.model.get("zoomDomain");
    if (zoomDomain && isTimeScaleType && !isVerticalAxis) {
      scale.domain(zoomDomain);
    }
    if (!isAxisVisible) {
      axisRef.attr("aria-hidden", true);
      return;
    }
    var axisScaleType = Tools.getProperty(axisOptions, "scaleType");
    var isDataLoading = Tools.getProperty(options2, "data", "loading");
    var numberOfTicksProvided = Tools.getProperty(axisOptions, "ticks", "number");
    var userProvidedTickValues = Tools.getProperty(axisOptions, "ticks", "values");
    var truncationType = Tools.getProperty(axisOptions, "truncation", "type");
    var truncationThreshold = Tools.getProperty(axisOptions, "truncation", "threshold");
    var truncationNumCharacter = Tools.getProperty(axisOptions, "truncation", "numCharacter");
    var isNumberOfTicksProvided = numberOfTicksProvided !== null;
    var timeScaleOptions = Tools.getProperty(options2, "timeScale");
    var fakeTick = DOMUtils.appendOrSelect(invisibleAxisRef, "g.tick");
    var fakeTickText = DOMUtils.appendOrSelect(fakeTick, "text").text("0");
    var tickHeight = DOMUtils.getSVGElementSize(fakeTickText.node(), {
      useBBox: true
    }).height;
    fakeTick.remove();
    var scaleType = this.scaleType || axisOptions.scaleType || ScaleTypes.LINEAR;
    var axis2 = axisFunction(scale).tickSizeOuter(0);
    if (scale.ticks) {
      var numberOfTicks = void 0;
      if (isNumberOfTicksProvided) {
        numberOfTicks = numberOfTicksProvided;
      } else {
        numberOfTicks = axis$1.ticks.number;
        if (isVerticalAxis) {
          numberOfTicks = this.getNumberOfFittingTicks(height, tickHeight, axis$1.ticks.verticalSpaceRatio);
        }
      }
      if (scale.ticks().length === 1 && scale.ticks()[0] === 0) {
        numberOfTicks = 0;
      }
      axis2.ticks(numberOfTicks);
      if (isTimeScaleType) {
        if (!scale.ticks(numberOfTicks).length) {
          axis2.tickValues([]);
        } else {
          var addSpaceOnEdges = Tools.getProperty(options2, "timeScale", "addSpaceOnEdges");
          var customDomain = Tools.getProperty(options2, "axes", axisPosition, "domain");
          var tickValues = void 0;
          var tempScale = scale.copy();
          if (addSpaceOnEdges && !customDomain) {
            tempScale.nice(numberOfTicks);
          }
          tickValues = tempScale.ticks(numberOfTicks);
          if (addSpaceOnEdges && tickValues.length > 2 && !customDomain) {
            tickValues.splice(tickValues.length - 1, 1);
            tickValues.splice(0, 1);
          }
          axis2.tickValues(tickValues);
        }
      }
    }
    var formatter;
    var userProvidedFormatter = Tools.getProperty(axisOptions, "ticks", "formatter");
    if (isTimeScaleType) {
      var timeInterval_1 = computeTimeIntervalName(axis2.tickValues());
      if (userProvidedFormatter === null) {
        formatter = function(t, i) {
          return formatTick(t, i, axis2.tickValues(), timeInterval_1, timeScaleOptions);
        };
      } else {
        formatter = function(t, i) {
          var defaultFormattedValue = formatTick(t, i, axis2.tickValues(), timeInterval_1, timeScaleOptions);
          return userProvidedFormatter(t, i, defaultFormattedValue);
        };
      }
    } else {
      if (userProvidedFormatter === null) {
        if (scaleType === ScaleTypes.LINEAR) {
          formatter = function(t) {
            return t.toLocaleString();
          };
        }
      } else {
        formatter = userProvidedFormatter;
      }
    }
    axis2.tickFormat(formatter);
    var _b = this.services.cartesianScales.getScaleByPosition(axisPosition).domain(), lowerBound = _b[0], upperBound = _b[1];
    var validTicks;
    if (userProvidedTickValues) {
      if (isTimeScaleType) {
        userProvidedTickValues.forEach(function(userProvidedTickValue, i) {
          if (userProvidedTickValue.getTime === void 0) {
            userProvidedTickValues[i] = new Date(userProvidedTickValue);
          }
        });
        validTicks = userProvidedTickValues.filter(function(tick) {
          var tickTimestamp = tick.getTime();
          return tickTimestamp >= new Date(lowerBound).getTime() && tickTimestamp <= new Date(upperBound).getTime();
        });
      } else if (axisScaleType === ScaleTypes.LABELS) {
        var discreteDomain_1 = this.services.cartesianScales.getScaleByPosition(axisPosition).domain();
        validTicks = userProvidedTickValues.filter(function(tick) {
          return discreteDomain_1.includes(tick);
        });
      } else {
        validTicks = userProvidedTickValues.filter(function(tick) {
          return tick >= lowerBound && tick <= upperBound;
        });
      }
      axis2.tickValues(validTicks);
    }
    switch (axisPosition) {
      case AxisPositions.LEFT:
        axisRef.attr("transform", "translate(" + this.margins.left + ", 0)");
        break;
      case AxisPositions.BOTTOM:
        axisRef.attr("transform", "translate(0, " + (height - this.margins.bottom) + ")");
        break;
      case AxisPositions.RIGHT:
        axisRef.attr("transform", "translate(" + (width - this.margins.right) + ", 0)");
        break;
      case AxisPositions.TOP:
        axisRef.attr("transform", "translate(0, " + this.margins.top + ")");
        break;
    }
    var isDataEmpty = this.model.isDataEmpty();
    if (axisOptions.title) {
      var axisTitleRef = DOMUtils.appendOrSelect(container, "text.axis-title").html(isDataEmpty || isDataLoading ? "" : axisOptions.title);
      var titleOrientation = Tools.getProperty(axisOptions, "titleOrientation");
      switch (axisPosition) {
        case AxisPositions.LEFT:
          if (titleOrientation === AxisTitleOrientations.RIGHT) {
            axisTitleRef.attr("transform", "rotate(90)").attr("y", 0).attr("x", scale.range()[0] / 2).attr("dy", "-0.5em").style("text-anchor", "middle");
          } else {
            axisTitleRef.attr("transform", "rotate(-90)").attr("y", 0).attr("x", -(scale.range()[0] / 2)).attr("dy", "0.75em").style("text-anchor", "middle");
          }
          break;
        case AxisPositions.BOTTOM:
          axisTitleRef.attr("transform", "translate(" + (this.margins.left / 2 + scale.range()[1] / 2) + ", " + (height + 4) + ")").style("text-anchor", "middle");
          break;
        case AxisPositions.RIGHT:
          if (titleOrientation === AxisTitleOrientations.LEFT) {
            axisTitleRef.attr("transform", "rotate(-90)").attr("y", width).attr("x", -(scale.range()[0] / 2)).style("text-anchor", "middle");
          } else {
            axisTitleRef.attr("transform", "rotate(90)").attr("y", -width).attr("x", scale.range()[0] / 2).attr("dy", "0.75em").style("text-anchor", "middle");
          }
          break;
        case AxisPositions.TOP:
          var titleHeight = DOMUtils.getSVGElementSize(axisTitleRef, {
            useBBox: true
          }).height;
          axisTitleRef.attr("transform", "translate(" + (this.margins.left / 2 + scale.range()[1] / 2) + ", " + titleHeight / 2 + ")").style("text-anchor", "middle");
          break;
      }
    }
    if (isTimeScaleType) {
      var timeInterval_2 = computeTimeIntervalName(axis2.tickValues());
      var showDayName_1 = timeScaleOptions.showDayName;
      var axisRefSelection = axisRef;
      if (animate) {
        axisRef = axisRef.transition().call(function(t) {
          return _this.services.transitions.setupTransition({
            transition: t,
            name: "axis-update",
            animate
          });
        });
      }
      axisRef = axisRef.call(axis2);
      var ticks2 = axisRefSelection.selectAll(".tick").data(axis2.tickValues(), scale).order().select("text");
      ticks2.style("font-weight", function(tick, i) {
        return isTickPrimary(tick, i, axis2.tickValues(), timeInterval_2, showDayName_1) ? "bold" : "normal";
      });
    } else {
      if (!animate || !axisRefExists) {
        axisRef = axisRef.call(axis2);
      } else {
        axisRef = axisRef.transition().call(function(t) {
          return _this.services.transitions.setupTransition({
            transition: t,
            name: "axis-update",
            animate
          });
        }).call(axis2);
      }
    }
    invisibleAxisRef.call(axis2);
    if (axisPosition === AxisPositions.BOTTOM || axisPosition === AxisPositions.TOP) {
      var shouldRotateTicks_1 = false;
      var tickRotation = Tools.getProperty(axisOptions, "ticks", "rotation");
      if (tickRotation === TickRotations.ALWAYS) {
        shouldRotateTicks_1 = true;
      } else if (tickRotation === TickRotations.NEVER) {
        shouldRotateTicks_1 = false;
      } else if (!tickRotation || tickRotation === TickRotations.AUTO) {
        if (scale.step) {
          var textNodes = invisibleAxisRef.selectAll("g.tick text").nodes();
          shouldRotateTicks_1 = textNodes.some(function(textNode) {
            return DOMUtils.getSVGElementSize(textNode, {
              useBBox: true
            }).width >= scale.step();
          });
        } else {
          shouldRotateTicks_1 = false;
          var mockTextPiece = invisibleAxisRef.append("text").text("A");
          var averageLetterWidth_1 = DOMUtils.getSVGElementSize(mockTextPiece.node(), {
            useBBox: true
          }).width;
          var lastStartPosition_1;
          invisibleAxisRef.selectAll("g.tick").each(function() {
            var selection2 = select(this);
            var xTransformation = parseFloat(Tools.getProperty(Tools.getTranslationValues(this), "tx"));
            if (xTransformation !== null && lastStartPosition_1 + selection2.text().length * averageLetterWidth_1 * 0.8 >= xTransformation) {
              shouldRotateTicks_1 = true;
            }
            lastStartPosition_1 = xTransformation;
          });
        }
      }
      if (shouldRotateTicks_1) {
        if (!isNumberOfTicksProvided) {
          axis2.ticks(this.getNumberOfFittingTicks(width, tickHeight, axis$1.ticks.horizontalSpaceRatio));
          invisibleAxisRef.call(axis2);
          axisRef.call(axis2);
        }
        container.selectAll("g.ticks g.tick text").attr("transform", "rotate(-45)").style("text-anchor", axisPosition === AxisPositions.TOP ? "start" : "end");
      } else {
        container.selectAll("g.ticks g.tick text").attr("transform", null).style("text-anchor", null);
      }
    }
    if (isDataLoading) {
      container.attr("opacity", 0);
    } else {
      container.attr("opacity", 1);
    }
    axisRef.selectAll("g.tick").attr("aria-label", function(d) {
      return d;
    });
    invisibleAxisRef.selectAll("g.tick").attr("aria-label", function(d) {
      return d;
    });
    if (truncationType !== TruncationTypes.NONE && axisScaleType === ScaleTypes.LABELS && !userProvidedTickValues) {
      var axisTickLabels = this.services.cartesianScales.getScaleDomain(axisPosition);
      if (axisTickLabels.length > 0) {
        var tick_html = svg.select("g.axis." + axisPosition + " g.ticks g.tick").html();
        container.selectAll("g.ticks g.tick").html(tick_html);
        var self_1 = this;
        container.selectAll("g.tick text").data(axisTickLabels).text(function(d) {
          if (d.length > truncationThreshold) {
            self_1.truncation[axisPosition] = true;
            return Tools.truncateLabel(d, truncationType, truncationNumCharacter);
          } else {
            return d;
          }
        });
        this.getInvisibleAxisRef().selectAll("g.tick text").data(axisTickLabels).text(function(d) {
          if (d.length > truncationThreshold) {
            return Tools.truncateLabel(d, truncationType, truncationNumCharacter);
          } else {
            return d;
          }
        });
        container.selectAll("g.ticks").html(this.getInvisibleAxisRef().html());
        container.selectAll("g.tick text").data(axisTickLabels);
      }
    }
    this.addEventListeners();
  };
  Axis2.prototype.addEventListeners = function() {
    var svg = this.getComponentContainer();
    var axisPosition = this.configs.position;
    var container = DOMUtils.appendOrSelect(svg, "g.axis." + axisPosition);
    var options2 = this.getOptions();
    var axisOptions = Tools.getProperty(options2, "axes", axisPosition);
    var axisScaleType = Tools.getProperty(axisOptions, "scaleType");
    var truncationThreshold = Tools.getProperty(axisOptions, "truncation", "threshold");
    var self2 = this;
    container.selectAll("g.tick text").on("mouseover", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Axis.LABEL_MOUSEOVER, {
        event,
        element: select(this),
        datum: datum2
      });
      if (axisScaleType === ScaleTypes.LABELS && datum2.length > truncationThreshold) {
        self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
          event,
          hoveredElement: select(this),
          content: datum2
        });
      }
    }).on("mousemove", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Axis.LABEL_MOUSEMOVE, {
        event,
        element: select(this),
        datum: datum2
      });
      if (axisScaleType === ScaleTypes.LABELS && datum2.length > truncationThreshold) {
        self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
          event
        });
      }
    }).on("click", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Axis.LABEL_CLICK, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mouseout", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Axis.LABEL_MOUSEOUT, {
        event,
        element: select(this),
        datum: datum2
      });
      if (axisScaleType === ScaleTypes.LABELS) {
        self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE);
      }
    });
  };
  Axis2.prototype.getInvisibleAxisRef = function() {
    var axisPosition = this.configs.position;
    return this.getComponentContainer().select("g.axis." + axisPosition + " g.ticks.invisible");
  };
  Axis2.prototype.getTitleRef = function() {
    var axisPosition = this.configs.position;
    return this.getComponentContainer().select("g.axis." + axisPosition + " text.axis-title");
  };
  Axis2.prototype.getNumberOfFittingTicks = function(size, tickSize, spaceRatio) {
    var numberOfTicksFit = Math.floor(size / (tickSize * spaceRatio));
    return Tools.clamp(numberOfTicksFit, 2, axis$1.ticks.number);
  };
  Axis2.prototype.destroy = function() {
    var svg = this.getComponentContainer();
    var axisPosition = this.configs.position;
    var container = DOMUtils.appendOrSelect(svg, "g.axis." + axisPosition);
    container.selectAll("g.tick text").on("mouseover", null).on("mousemove", null).on("mouseout", null);
  };
  return Axis2;
}(Component);
var __extends$N = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$2 = globalThis && globalThis.__assign || function() {
  __assign$2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$2.apply(this, arguments);
};
var HoverAxis = function(_super) {
  __extends$N(HoverAxis2, _super);
  function HoverAxis2(model, services, configs) {
    return _super.call(this, model, services, configs) || this;
  }
  HoverAxis2.prototype.render = function(animate) {
    if (animate === void 0) {
      animate = true;
    }
    _super.prototype.render.call(this, animate);
    _super.prototype.destroy.call(this);
    var axisPosition = this.configs.position;
    var svg = this.getComponentContainer();
    var container = DOMUtils.appendOrSelect(svg, "g.axis." + axisPosition);
    var self2 = this;
    container.selectAll("g.tick").each(function(_, index2) {
      var g = select(this);
      g.classed("tick-hover", true).attr("tabindex", index2 === 0 ? 0 : -1);
      var textNode = g.select("text");
      var _a2 = DOMUtils.getSVGElementSize(textNode, {
        useBBox: true
      }), width = _a2.width, height = _a2.height;
      var rectangle = DOMUtils.appendOrSelect(g, "rect.axis-holder");
      var x2 = 0, y2 = 0;
      switch (axisPosition) {
        case AxisPositions.LEFT:
          x2 = -width + Number(textNode.attr("x"));
          y2 = -(height / 2);
          break;
        case AxisPositions.RIGHT:
          x2 = Math.abs(Number(textNode.attr("x")));
          y2 = -(height / 2);
          break;
        case AxisPositions.TOP:
          x2 = -(width / 2);
          y2 = -height + Number(textNode.attr("y")) / 2;
          if (self2.truncation[axisPosition]) {
            x2 = 0;
            rectangle.attr("transform", "rotate(-45)");
          }
          break;
        case AxisPositions.BOTTOM:
          x2 = -(width / 2);
          y2 = height / 2 - 2;
          if (self2.truncation[axisPosition]) {
            x2 = -width;
            rectangle.attr("transform", "rotate(-45)");
          }
          break;
      }
      rectangle.attr("x", x2 - axis$1.hover.rectanglePadding).attr("y", y2).attr("width", width + axis$1.hover.rectanglePadding * 2).attr("height", height).lower();
      g.on("keydown", function(event) {
        if (axisPosition === AxisPositions.LEFT || axisPosition === AxisPositions.RIGHT) {
          if (event.key && event.key === "ArrowUp") {
            self2.goNext(this, event);
          } else if (event.key && event.key === "ArrowDown") {
            self2.goPrevious(this, event);
          }
        } else {
          if (event.key && event.key === "ArrowLeft") {
            self2.goPrevious(this, event);
          } else if (event.key && event.key === "ArrowRight") {
            self2.goNext(this, event);
          }
        }
      });
    });
    this.addEventListeners();
  };
  HoverAxis2.prototype.addEventListeners = function() {
    var svg = this.getComponentContainer();
    var axisPosition = this.configs.position;
    var container = DOMUtils.appendOrSelect(svg, "g.axis." + axisPosition);
    var options2 = this.getOptions();
    var axisOptions = Tools.getProperty(options2, "axes", axisPosition);
    var axisScaleType = Tools.getProperty(axisOptions, "scaleType");
    var truncationThreshold = Tools.getProperty(axisOptions, "truncation", "threshold");
    var self2 = this;
    container.selectAll("g.tick.tick-hover").on("mouseover", function(event) {
      var hoveredElement = select(this).select("text");
      var datum2 = hoveredElement.datum();
      self2.services.events.dispatchEvent(Events$1.Axis.LABEL_MOUSEOVER, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      if (axisScaleType === ScaleTypes.LABELS && datum2.length > truncationThreshold) {
        self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
          event,
          element: hoveredElement,
          datum: datum2
        });
      }
    }).on("mousemove", function(event) {
      var hoveredElement = select(this).select("text");
      var datum2 = hoveredElement.datum();
      self2.services.events.dispatchEvent(Events$1.Axis.LABEL_MOUSEMOVE, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        event
      });
    }).on("click", function(event) {
      self2.services.events.dispatchEvent(Events$1.Axis.LABEL_CLICK, {
        event,
        element: select(this).select("text"),
        datum: select(this).select("text").datum()
      });
    }).on("mouseout", function(event) {
      self2.services.events.dispatchEvent(Events$1.Axis.LABEL_MOUSEOUT, {
        event,
        element: select(this).select("text"),
        datum: select(this).select("text").datum()
      });
      if (axisScaleType === ScaleTypes.LABELS) {
        self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE);
      }
    }).on("focus", function(event) {
      var coordinates = { clientX: 0, clientY: 0 };
      if (event.target) {
        event.target.focus();
        var boundingRect = event.target.getBoundingClientRect();
        coordinates.clientX = boundingRect.x;
        coordinates.clientY = boundingRect.y;
      }
      self2.services.events.dispatchEvent(Events$1.Axis.LABEL_FOCUS, {
        event: __assign$2(__assign$2({}, event), coordinates),
        element: select(this),
        datum: select(this).select("text").datum()
      });
    }).on("blur", function(event) {
      self2.services.events.dispatchEvent(Events$1.Axis.LABEL_BLUR, {
        event,
        element: select(this),
        datum: select(this).select("text").datum()
      });
    });
  };
  HoverAxis2.prototype.goNext = function(element, event) {
    if (element.nextElementSibling && element.nextElementSibling.tagName !== "path") {
      element.nextElementSibling.dispatchEvent(new Event("focus"));
    }
    event.preventDefault();
  };
  HoverAxis2.prototype.goPrevious = function(element, event) {
    if (element.previousElementSibling && element.previousElementSibling.tagName !== "path") {
      element.previousElementSibling.dispatchEvent(new Event("focus"));
    }
    event.preventDefault();
  };
  HoverAxis2.prototype.destroy = function() {
    var svg = this.getComponentContainer();
    var axisPosition = this.configs.position;
    var container = DOMUtils.appendOrSelect(svg, "g.axis." + axisPosition);
    container.selectAll("g.tick.tick-hover").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("focus", null).on("blur", null);
  };
  return HoverAxis2;
}(Axis);
var __extends$M = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TwoDimensionalAxes = function(_super) {
  __extends$M(TwoDimensionalAxes2, _super);
  function TwoDimensionalAxes2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "2D-axes";
    _this.renderType = RenderTypes.SVG;
    _this.children = {};
    _this.thresholds = [];
    _this.margins = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
    return _this;
  }
  TwoDimensionalAxes2.prototype.render = function(animate) {
    var _this = this;
    if (animate === void 0) {
      animate = false;
    }
    var axes2 = {};
    var axisPositions = Object.keys(AxisPositions);
    var axesOptions = Tools.getProperty(this.getOptions(), "axes");
    axisPositions.forEach(function(axisPosition) {
      var axisOptions = axesOptions[AxisPositions[axisPosition]];
      if (axisOptions) {
        axes2[AxisPositions[axisPosition]] = true;
      }
    });
    this.configs.axes = axes2;
    axisPositions.forEach(function(axisPositionKey) {
      var axisPosition = AxisPositions[axisPositionKey];
      if (_this.configs.axes[axisPosition] && !_this.children[axisPosition]) {
        var configs = {
          position: axisPosition,
          axes: _this.configs.axes,
          margins: _this.margins
        };
        var axisComponent = _this.model.axisFlavor === AxisFlavor.DEFAULT ? new Axis(_this.model, _this.services, configs) : new HoverAxis(_this.model, _this.services, configs);
        axisComponent.setModel(_this.model);
        axisComponent.setServices(_this.services);
        axisComponent.setParent(_this.parent);
        _this.children[axisPosition] = axisComponent;
      }
    });
    Object.keys(this.children).forEach(function(childKey) {
      var child = _this.children[childKey];
      child.render(animate);
    });
    var margins = {};
    Object.keys(this.children).forEach(function(childKey) {
      var child = _this.children[childKey];
      var axisPosition = child.configs.position;
      var invisibleAxisRef = child.getInvisibleAxisRef();
      var _a2 = DOMUtils.getSVGElementSize(invisibleAxisRef, { useBBox: true }), width = _a2.width, height = _a2.height;
      var offset;
      if (child.getTitleRef().empty()) {
        offset = 0;
      } else {
        offset = DOMUtils.getSVGElementSize(child.getTitleRef(), {
          useBBox: true
        }).height;
        if (axisPosition === AxisPositions.LEFT || axisPosition === AxisPositions.RIGHT) {
          offset += 5;
        }
      }
      switch (axisPosition) {
        case AxisPositions.TOP:
          margins.top = height + offset;
          break;
        case AxisPositions.BOTTOM:
          margins.bottom = height + offset;
          break;
        case AxisPositions.LEFT:
          margins.left = width + offset;
          break;
        case AxisPositions.RIGHT:
          margins.right = width + offset;
          break;
      }
    });
    this.services.events.dispatchEvent(Events$1.Axis.RENDER_COMPLETE);
    var isNotEqual = Object.keys(margins).some(function(marginKey) {
      return _this.margins[marginKey] !== margins[marginKey];
    });
    if (isNotEqual) {
      this.margins = Object.assign(this.margins, margins);
      this.model.set({ axesMargins: this.margins }, { skipUpdate: true });
      this.services.events.dispatchEvent(Events$1.ZoomBar.UPDATE);
      Object.keys(this.children).forEach(function(childKey) {
        var child = _this.children[childKey];
        child.margins = _this.margins;
      });
      this.render(true);
    }
  };
  return TwoDimensionalAxes2;
}(Component);
var noop = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set$1(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set$1(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _ = this._;
    for (var t in _)
      copy2[t] = _[t].slice();
    return new Dispatch(copy2);
  },
  call: function(type2, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get$1(type2, name) {
  for (var i = 0, n = type2.length, c; i < n; ++i) {
    if ((c = type2[i]).name === name) {
      return c.value;
    }
  }
}
function set$1(type2, name, callback) {
  for (var i = 0, n = type2.length; i < n; ++i) {
    if (type2[i].name === name) {
      type2[i] = noop, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name, value: callback });
  return type2;
}
const nonpassivecapture = { capture: true, passive: false };
function noevent$1(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function dragDisable(view) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", noevent$1, nonpassivecapture);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent$1, nonpassivecapture);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent$1, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}
var frame = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time2) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time2;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time2) {
  var t = new Timer();
  t.restart(callback, delay, time2);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t2, time2 = Infinity;
  while (t12) {
    if (t12._call) {
      if (time2 > t12._time)
        time2 = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t2 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t2 : taskHead = t2;
    }
  }
  taskTail = t02;
  sleep(time2);
}
function sleep(time2) {
  if (frame)
    return;
  if (timeout$1)
    timeout$1 = clearTimeout(timeout$1);
  var delay = time2 - clockNow;
  if (delay > 24) {
    if (time2 < Infinity)
      timeout$1 = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
function timeout(callback, delay, time2) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time2);
  return t;
}
var emptyOn = dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule(node, name, id2, index2, group, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create(node, id2, {
    name,
    index: index2,
    group,
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id2) {
  var schedule2 = get(node, id2);
  if (schedule2.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule2;
}
function set(node, id2) {
  var schedule2 = get(node, id2);
  if (schedule2.state > STARTED)
    throw new Error("too late; already running");
  return schedule2;
}
function get(node, id2) {
  var schedule2 = node.__transition;
  if (!schedule2 || !(schedule2 = schedule2[id2]))
    throw new Error("transition not found");
  return schedule2;
}
function create(node, id2, self2) {
  var schedules = node.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule2, 0, self2.time);
  function schedule2(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed)
      start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self2.state !== SCHEDULED)
      return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self2.name)
        continue;
      if (o.state === STARTED)
        return timeout(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick, self2.delay, self2.time);
        tick(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node, node.__data__, self2.index, self2.group);
    if (self2.state !== STARTING)
      return;
    self2.state = STARTED;
    tween = new Array(n = self2.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self2.tween[i].value.call(node, node.__data__, self2.index, self2.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node, node.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i in schedules)
      return;
    delete node.__transition;
  }
}
function interrupt(node, name) {
  var schedules = node.__transition, schedule2, active, empty2 = true, i;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule2 = schedules[i]).name !== name) {
      empty2 = false;
      continue;
    }
    active = schedule2.state > STARTING && schedule2.state < ENDING;
    schedule2.state = ENDED;
    schedule2.timer.stop();
    schedule2.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule2.index, schedule2.group);
    delete schedules[i];
  }
  if (empty2)
    delete node.__transition;
}
function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule2 = set(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule2.tween = tween1;
  };
}
function tweenFunction(id2, name, value2) {
  var tween0, tween1;
  if (typeof value2 !== "function")
    throw new Error();
  return function() {
    var schedule2 = set(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name, value: value2 }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n)
        tween1.push(t);
    }
    schedule2.tween = tween1;
  };
}
function transition_tween(name, value2) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value2 == null ? tweenRemove : tweenFunction)(id2, name, value2));
}
function tweenValue(transition, name, value2) {
  var id2 = transition._id;
  transition.each(function() {
    var schedule2 = set(this, id2);
    (schedule2.value || (schedule2.value = {}))[name] = value2.apply(this, arguments);
  });
  return function(node) {
    return get(node, id2).value[name];
  };
}
function interpolate(a, b) {
  var c;
  return (typeof b === "number" ? interpolateNumber : b instanceof color ? interpolateRgb : (c = color(b)) ? (b = c, interpolateRgb) : interpolateString)(a, b);
}
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction(name, interpolate2, value2) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value2(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function attrFunctionNS(fullname, interpolate2, value2) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value2(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function transition_attr(name, value2) {
  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value2 === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value2)) : value2 == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value2));
}
function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value2) {
  var t02, i0;
  function tween() {
    var i = value2.apply(this, arguments);
    if (i !== i0)
      t02 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t02;
  }
  tween._value = value2;
  return tween;
}
function attrTween(name, value2) {
  var t02, i0;
  function tween() {
    var i = value2.apply(this, arguments);
    if (i !== i0)
      t02 = (i0 = i) && attrInterpolate(name, i);
    return t02;
  }
  tween._value = value2;
  return tween;
}
function transition_attrTween(name, value2) {
  var key = "attr." + name;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value2 == null)
    return this.tween(key, null);
  if (typeof value2 !== "function")
    throw new Error();
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value2));
}
function delayFunction(id2, value2) {
  return function() {
    init(this, id2).delay = +value2.apply(this, arguments);
  };
}
function delayConstant(id2, value2) {
  return value2 = +value2, function() {
    init(this, id2).delay = value2;
  };
}
function transition_delay(value2) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value2 === "function" ? delayFunction : delayConstant)(id2, value2)) : get(this.node(), id2).delay;
}
function durationFunction(id2, value2) {
  return function() {
    set(this, id2).duration = +value2.apply(this, arguments);
  };
}
function durationConstant(id2, value2) {
  return value2 = +value2, function() {
    set(this, id2).duration = value2;
  };
}
function transition_duration(value2) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value2 === "function" ? durationFunction : durationConstant)(id2, value2)) : get(this.node(), id2).duration;
}
function easeConstant(id2, value2) {
  if (typeof value2 !== "function")
    throw new Error();
  return function() {
    set(this, id2).ease = value2;
  };
}
function transition_ease(value2) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value2)) : get(this.node(), id2).ease;
}
function easeVarying(id2, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (typeof v !== "function")
      throw new Error();
    set(this, id2).ease = v;
  };
}
function transition_easeVarying(value2) {
  if (typeof value2 !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value2));
}
function transition_filter(match2) {
  if (typeof match2 !== "function")
    match2 = matcher(match2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match2.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}
function transition_merge(transition) {
  if (transition._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge2[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0)
      t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set;
  return function() {
    var schedule2 = sit(this, id2), on2 = schedule2.on;
    if (on2 !== on0)
      (on1 = (on0 = on2).copy()).on(name, listener);
    schedule2.on = on1;
  };
}
function transition_on(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition)
      if (+i !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}
function transition_select(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select2.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id2, i, subgroup, get(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}
function transition_selectAll(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children2 = select2.call(node, node.__data__, i, group), child, inherit2 = get(node, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child = children2[k]) {
            schedule(child, name, id2, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}
var Selection = selection.prototype.constructor;
function transition_selection() {
  return new Selection(this._groups, this._parents);
}
function styleNull(name, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction(name, interpolate2, value2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value2(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule2 = set(this, id2), on2 = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove(name)) : void 0;
    if (on2 !== on0 || listener0 !== listener)
      (on1 = (on0 = on2).copy()).on(event, listener0 = listener);
    schedule2.on = on1;
  };
}
function transition_style(name, value2, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
  return value2 == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove(name)) : typeof value2 === "function" ? this.styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value2))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i, value2), priority).on("end.style." + name, null);
}
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value2, priority) {
  var t, i0;
  function tween() {
    var i = value2.apply(this, arguments);
    if (i !== i0)
      t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value2;
  return tween;
}
function transition_styleTween(name, value2, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value2 == null)
    return this.tween(key, null);
  if (typeof value2 !== "function")
    throw new Error();
  return this.tween(key, styleTween(name, value2, priority == null ? "" : priority));
}
function textConstant(value2) {
  return function() {
    this.textContent = value2;
  };
}
function textFunction(value2) {
  return function() {
    var value1 = value2(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function transition_text(value2) {
  return this.tween("text", typeof value2 === "function" ? textFunction(tweenValue(this, "text", value2)) : textConstant(value2 == null ? "" : value2 + ""));
}
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value2) {
  var t02, i0;
  function tween() {
    var i = value2.apply(this, arguments);
    if (i !== i0)
      t02 = (i0 = i) && textInterpolate(i);
    return t02;
  }
  tween._value = value2;
  return tween;
}
function transition_textTween(value2) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value2 == null)
    return this.tween(key, null);
  if (typeof value2 !== "function")
    throw new Error();
  return this.tween(key, textTween(value2));
}
function transition_transition() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit2 = get(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}
function transition_end() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve();
    } };
    that.each(function() {
      var schedule2 = set(this, id2), on2 = schedule2.on;
      if (on2 !== on0) {
        on1 = (on0 = on2).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule2.on = on1;
    });
    if (size === 0)
      resolve();
  });
}
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function newId() {
  return ++id;
}
var selection_prototype = selection.prototype;
Transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};
var defaultTiming = {
  time: null,
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function selection_transition(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id2, i, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}
selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
var constant = (x2) => () => x2;
function BrushEvent(type2, {
  sourceEvent: sourceEvent2,
  target,
  selection: selection2,
  mode,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    selection: { value: selection2, enumerable: true, configurable: true },
    mode: { value: mode, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
var MODE_DRAG = { name: "drag" }, MODE_SPACE = { name: "space" }, MODE_HANDLE = { name: "handle" }, MODE_CENTER = { name: "center" };
const { abs, max, min } = Math;
function number1(e) {
  return [+e[0], +e[1]];
}
function number2(e) {
  return [number1(e[0]), number1(e[1])];
}
var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x2, e) {
    return x2 == null ? null : [[+x2[0], e[0][1]], [+x2[1], e[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y2, e) {
    return y2 == null ? null : [[e[0][0], +y2[0]], [e[1][0], +y2[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};
var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};
var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};
var signsX = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
};
var signsY = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function type(t) {
  return { type: t };
}
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}
function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  if (svg.hasAttribute("viewBox")) {
    svg = svg.viewBox.baseVal;
    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
  }
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function local(node) {
  while (!node.__brush)
    if (!(node = node.parentNode))
      return;
  return node.__brush;
}
function empty(extent2) {
  return extent2[0][0] === extent2[1][0] || extent2[0][1] === extent2[1][1];
}
function brushX() {
  return brush(X);
}
function brush(dim) {
  var extent2 = defaultExtent, filter2 = defaultFilter, touchable = defaultTouchable, keys2 = true, listeners = dispatch("start", "brush", "end"), handleSize = 6, touchending;
  function brush2(group) {
    var overlay = group.property("__brush", initialize).selectAll(".overlay").data([type("overlay")]);
    overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function() {
      var extent3 = local(this).extent;
      select(this).attr("x", extent3[0][0]).attr("y", extent3[0][1]).attr("width", extent3[1][0] - extent3[0][0]).attr("height", extent3[1][1] - extent3[0][1]);
    });
    group.selectAll(".selection").data([type("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var handle = group.selectAll(".handle").data(dim.handles, function(d) {
      return d.type;
    });
    handle.exit().remove();
    handle.enter().append("rect").attr("class", function(d) {
      return "handle handle--" + d.type;
    }).attr("cursor", function(d) {
      return cursors[d.type];
    });
    group.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  brush2.move = function(group, selection2, event) {
    if (group.tween) {
      group.on("start.brush", function(event2) {
        emitter(this, arguments).beforestart().start(event2);
      }).on("interrupt.brush end.brush", function(event2) {
        emitter(this, arguments).end(event2);
      }).tween("brush", function() {
        var that = this, state = that.__brush, emit = emitter(that, arguments), selection0 = state.selection, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(this, arguments) : selection2, state.extent), i = interpolate$1(selection0, selection1);
        function tween(t) {
          state.selection = t === 1 && selection1 === null ? null : i(t);
          redraw.call(that);
          emit.brush();
        }
        return selection0 !== null && selection1 !== null ? tween : tween(1);
      });
    } else {
      group.each(function() {
        var that = this, args = arguments, state = that.__brush, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(that, args) : selection2, state.extent), emit = emitter(that, args).beforestart();
        interrupt(that);
        state.selection = selection1 === null ? null : selection1;
        redraw.call(that);
        emit.start(event).brush(event).end(event);
      });
    }
  };
  brush2.clear = function(group, event) {
    brush2.move(group, null, event);
  };
  function redraw() {
    var group = select(this), selection2 = local(this).selection;
    if (selection2) {
      group.selectAll(".selection").style("display", null).attr("x", selection2[0][0]).attr("y", selection2[0][1]).attr("width", selection2[1][0] - selection2[0][0]).attr("height", selection2[1][1] - selection2[0][1]);
      group.selectAll(".handle").style("display", null).attr("x", function(d) {
        return d.type[d.type.length - 1] === "e" ? selection2[1][0] - handleSize / 2 : selection2[0][0] - handleSize / 2;
      }).attr("y", function(d) {
        return d.type[0] === "s" ? selection2[1][1] - handleSize / 2 : selection2[0][1] - handleSize / 2;
      }).attr("width", function(d) {
        return d.type === "n" || d.type === "s" ? selection2[1][0] - selection2[0][0] + handleSize : handleSize;
      }).attr("height", function(d) {
        return d.type === "e" || d.type === "w" ? selection2[1][1] - selection2[0][1] + handleSize : handleSize;
      });
    } else {
      group.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
    }
  }
  function emitter(that, args, clean) {
    var emit = that.__brush.emitter;
    return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
  }
  function Emitter(that, args, clean) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
    this.clean = clean;
  }
  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1)
        this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function(event, mode) {
      if (this.starting)
        this.starting = false, this.emit("start", event, mode);
      else
        this.emit("brush", event);
      return this;
    },
    brush: function(event, mode) {
      this.emit("brush", event, mode);
      return this;
    },
    end: function(event, mode) {
      if (--this.active === 0)
        delete this.state.emitter, this.emit("end", event, mode);
      return this;
    },
    emit: function(type2, event, mode) {
      var d = select(this.that).datum();
      listeners.call(type2, this.that, new BrushEvent(type2, {
        sourceEvent: event,
        target: brush2,
        selection: dim.output(this.state.selection),
        mode,
        dispatch: listeners
      }), d);
    }
  };
  function started(event) {
    if (touchending && !event.touches)
      return;
    if (!filter2.apply(this, arguments))
      return;
    var that = this, type2 = event.target.__data__.type, mode = (keys2 && event.metaKey ? type2 = "overlay" : type2) === "selection" ? MODE_DRAG : keys2 && event.altKey ? MODE_CENTER : MODE_HANDLE, signX = dim === Y ? null : signsX[type2], signY = dim === X ? null : signsY[type2], state = local(that), extent3 = state.extent, selection2 = state.selection, W = extent3[0][0], w0, w1, N = extent3[0][1], n0, n1, E = extent3[1][0], e0, e1, S = extent3[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys2 && event.shiftKey, lockX, lockY, points = Array.from(event.touches || [event], (t) => {
      const i = t.identifier;
      t = pointer(t, that);
      t.point0 = t.slice();
      t.identifier = i;
      return t;
    });
    interrupt(that);
    var emit = emitter(that, arguments, true).beforestart();
    if (type2 === "overlay") {
      if (selection2)
        moving = true;
      const pts = [points[0], points[1] || points[0]];
      state.selection = selection2 = [[
        w0 = dim === Y ? W : min(pts[0][0], pts[1][0]),
        n0 = dim === X ? N : min(pts[0][1], pts[1][1])
      ], [
        e0 = dim === Y ? E : max(pts[0][0], pts[1][0]),
        s0 = dim === X ? S : max(pts[0][1], pts[1][1])
      ]];
      if (points.length > 1)
        move(event);
    } else {
      w0 = selection2[0][0];
      n0 = selection2[0][1];
      e0 = selection2[1][0];
      s0 = selection2[1][1];
    }
    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;
    var group = select(that).attr("pointer-events", "none");
    var overlay = group.selectAll(".overlay").attr("cursor", cursors[type2]);
    if (event.touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = select(event.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
      if (keys2)
        view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
      dragDisable(event.view);
    }
    redraw.call(that);
    emit.start(event, mode.name);
    function moved(event2) {
      for (const p of event2.changedTouches || [event2]) {
        for (const d of points)
          if (d.identifier === p.identifier)
            d.cur = pointer(p, that);
      }
      if (shifting && !lockX && !lockY && points.length === 1) {
        const point2 = points[0];
        if (abs(point2.cur[0] - point2[0]) > abs(point2.cur[1] - point2[1]))
          lockY = true;
        else
          lockX = true;
      }
      for (const point2 of points)
        if (point2.cur)
          point2[0] = point2.cur[0], point2[1] = point2.cur[1];
      moving = true;
      noevent(event2);
      move(event2);
    }
    function move(event2) {
      const point2 = points[0], point0 = point2.point0;
      var t;
      dx = point2[0] - point0[0];
      dy = point2[1] - point0[1];
      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX)
            dx = max(W - w0, min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY)
            dy = max(N - n0, min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (points[1]) {
            if (signX)
              w1 = max(W, min(E, points[0][0])), e1 = max(W, min(E, points[1][0])), signX = 1;
            if (signY)
              n1 = max(N, min(S, points[0][1])), s1 = max(N, min(S, points[1][1])), signY = 1;
          } else {
            if (signX < 0)
              dx = max(W - w0, min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
            else if (signX > 0)
              dx = max(W - e0, min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
            if (signY < 0)
              dy = max(N - n0, min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
            else if (signY > 0)
              dy = max(N - s0, min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          }
          break;
        }
        case MODE_CENTER: {
          if (signX)
            w1 = max(W, min(E, w0 - dx * signX)), e1 = max(W, min(E, e0 + dx * signX));
          if (signY)
            n1 = max(N, min(S, n0 - dy * signY)), s1 = max(N, min(S, s0 + dy * signY));
          break;
        }
      }
      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type2 in flipX)
          overlay.attr("cursor", cursors[type2 = flipX[type2]]);
      }
      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type2 in flipY)
          overlay.attr("cursor", cursors[type2 = flipY[type2]]);
      }
      if (state.selection)
        selection2 = state.selection;
      if (lockX)
        w1 = selection2[0][0], e1 = selection2[1][0];
      if (lockY)
        n1 = selection2[0][1], s1 = selection2[1][1];
      if (selection2[0][0] !== w1 || selection2[0][1] !== n1 || selection2[1][0] !== e1 || selection2[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush(event2, mode.name);
      }
    }
    function ended(event2) {
      nopropagation(event2);
      if (event2.touches) {
        if (event2.touches.length)
          return;
        if (touchending)
          clearTimeout(touchending);
        touchending = setTimeout(function() {
          touchending = null;
        }, 500);
      } else {
        yesdrag(event2.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection)
        selection2 = state.selection;
      if (empty(selection2))
        state.selection = null, redraw.call(that);
      emit.end(event2, mode.name);
    }
    function keydowned(event2) {
      switch (event2.keyCode) {
        case 16: {
          shifting = signX && signY;
          break;
        }
        case 18: {
          if (mode === MODE_HANDLE) {
            if (signX)
              e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY)
              s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move(event2);
          }
          break;
        }
        case 32: {
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0)
              e0 = e1 - dx;
            else if (signX > 0)
              w0 = w1 - dx;
            if (signY < 0)
              s0 = s1 - dy;
            else if (signY > 0)
              n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move(event2);
          }
          break;
        }
        default:
          return;
      }
      noevent(event2);
    }
    function keyupped(event2) {
      switch (event2.keyCode) {
        case 16: {
          if (shifting) {
            lockX = lockY = shifting = false;
            move(event2);
          }
          break;
        }
        case 18: {
          if (mode === MODE_CENTER) {
            if (signX < 0)
              e0 = e1;
            else if (signX > 0)
              w0 = w1;
            if (signY < 0)
              s0 = s1;
            else if (signY > 0)
              n0 = n1;
            mode = MODE_HANDLE;
            move(event2);
          }
          break;
        }
        case 32: {
          if (mode === MODE_SPACE) {
            if (event2.altKey) {
              if (signX)
                e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY)
                s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0)
                e0 = e1;
              else if (signX > 0)
                w0 = w1;
              if (signY < 0)
                s0 = s1;
              else if (signY > 0)
                n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type2]);
            move(event2);
          }
          break;
        }
        default:
          return;
      }
      noevent(event2);
    }
  }
  function touchmoved(event) {
    emitter(this, arguments).moved(event);
  }
  function touchended(event) {
    emitter(this, arguments).ended(event);
  }
  function initialize() {
    var state = this.__brush || { selection: null };
    state.extent = number2(extent2.apply(this, arguments));
    state.dim = dim;
    return state;
  }
  brush2.extent = function(_) {
    return arguments.length ? (extent2 = typeof _ === "function" ? _ : constant(number2(_)), brush2) : extent2;
  };
  brush2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant(!!_), brush2) : filter2;
  };
  brush2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), brush2) : touchable;
  };
  brush2.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush2) : handleSize;
  };
  brush2.keyModifiers = function(_) {
    return arguments.length ? (keys2 = !!_, brush2) : keys2;
  };
  brush2.on = function() {
    var value2 = listeners.on.apply(listeners, arguments);
    return value2 === listeners ? brush2 : value2;
  };
  return brush2;
}
var __extends$L = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ChartBrush = function(_super) {
  __extends$L(ChartBrush2, _super);
  function ChartBrush2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "grid-brush";
    _this.renderType = RenderTypes.SVG;
    _this.selectionSelector = "rect.selection";
    _this.frontSelectionSelector = "rect.frontSelection";
    return _this;
  }
  ChartBrush2.prototype.render = function(animate) {
    var _this = this;
    var svg = this.parent;
    var frontSelectionArea = this.getComponentContainer();
    var backdrop = DOMUtils.appendOrSelect(svg, "svg.chart-grid-backdrop");
    var brushArea = DOMUtils.appendOrSelect(backdrop, "g." + this.type);
    var d3Selection = DOMUtils.appendOrSelect(brushArea, this.selectionSelector);
    var _a2 = DOMUtils.getSVGElementSize(backdrop, {
      useAttrs: true
    }), width = _a2.width, height = _a2.height;
    var cartesianScales = this.services.cartesianScales;
    var mainXScaleType = cartesianScales.getMainXScaleType();
    var mainXScale = cartesianScales.getMainXScale();
    var _b = mainXScale.range(), xScaleStart = _b[0];
    _b[1];
    frontSelectionArea.attr("transform", "translate(" + xScaleStart + ",0)");
    var frontSelection = DOMUtils.appendOrSelect(frontSelectionArea, this.frontSelectionSelector);
    if (mainXScale && mainXScaleType === ScaleTypes.TIME) {
      var zoomDomain_1 = this.model.get("zoomDomain");
      if (zoomDomain_1 === void 0) {
        zoomDomain_1 = this.services.zoom.getDefaultZoomBarDomain();
        if (zoomDomain_1) {
          this.model.set({ zoomDomain: zoomDomain_1 }, { animate: false });
        }
      }
      var updateSelectionDash_1 = function(selection2) {
        var selectionWidth = selection2[1] - selection2[0];
        var dashArray = "0," + selectionWidth.toString();
        var dashCount = Math.floor(height / ChartBrush2.DASH_LENGTH);
        var totalRightDash = dashCount * ChartBrush2.DASH_LENGTH;
        for (var i = 0; i < dashCount; i++) {
          dashArray += "," + ChartBrush2.DASH_LENGTH;
        }
        dashArray += "," + (height - totalRightDash);
        if (dashCount % 2 === 1) {
          dashArray += ",0";
        }
        dashArray += "," + selectionWidth.toString();
        dashArray += "," + height.toString();
        frontSelection.attr("stroke-dasharray", dashArray);
      };
      var brushEventHandler = function(event) {
        var selection2 = event.selection;
        if (selection2 === null || selection2[0] === selection2[1]) {
          return;
        }
        frontSelection.attr("x", parseFloat(d3Selection.attr("x")) + parseFloat(backdrop.attr("x"))).attr("y", d3Selection.attr("y")).attr("width", d3Selection.attr("width")).attr("height", d3Selection.attr("height")).style("cursor", "pointer").style("display", null);
        updateSelectionDash_1(selection2);
      };
      var updateZoomDomain_1 = function(startPoint, endPoint) {
        var xScale = time().range([0, width]).domain(zoomDomain_1);
        var newDomain = [
          xScale.invert(startPoint),
          xScale.invert(endPoint)
        ];
        if (newDomain[0].valueOf() === newDomain[1].valueOf()) {
          newDomain = _this.services.zoom.getDefaultZoomBarDomain();
        }
        if (zoomDomain_1[0].valueOf() !== newDomain[0].valueOf() || zoomDomain_1[1].valueOf() !== newDomain[1].valueOf()) {
          _this.services.zoom.handleDomainChange(newDomain);
        }
      };
      var brushed = function(event) {
        var selection2 = event.selection;
        if (selection2 !== null) {
          updateZoomDomain_1(selection2[0], selection2[1]);
          brushArea.call(brush_1.move, null);
          frontSelection.style("display", "none");
        }
      };
      var brush_1 = brushX().extent([
        [0, 0],
        [width - 1, height]
      ]).on("start brush end", brushEventHandler).on("end.brushed", brushed);
      brushArea.call(brush_1);
      var zoomRatio_1 = this.services.zoom.getZoomRatio();
      backdrop.on("click", function(event) {
        if (event.shiftKey) {
          var holder = this.services.domUtils.getHolder();
          var clickedX = pointer(brushArea.node(), holder)[0];
          var leftPoint = clickedX - width * zoomRatio_1 / 2;
          if (leftPoint < 0) {
            leftPoint = 0;
          }
          var rightPoint = clickedX + width * zoomRatio_1 / 2;
          if (rightPoint > width) {
            rightPoint = width;
          }
          updateZoomDomain_1(leftPoint, rightPoint);
        }
      });
    }
  };
  ChartBrush2.DASH_LENGTH = 4;
  return ChartBrush2;
}(Component);
var __extends$K = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Grid = function(_super) {
  __extends$K(Grid2, _super);
  function Grid2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "grid";
    _this.renderType = RenderTypes.SVG;
    return _this;
  }
  Grid2.prototype.render = function(animate) {
    if (animate === void 0) {
      animate = true;
    }
    var isXGridEnabled = Tools.getProperty(this.getOptions(), "grid", "x", "enabled");
    var isYGridEnabled = Tools.getProperty(this.getOptions(), "grid", "y", "enabled");
    this.drawBackdrop(isXGridEnabled, isYGridEnabled);
    if (!isXGridEnabled && !isYGridEnabled) {
      return;
    }
    if (isXGridEnabled) {
      DOMUtils.appendOrSelect(this.backdrop, "g.x.grid");
      this.drawXGrid(animate);
    }
    if (isYGridEnabled) {
      DOMUtils.appendOrSelect(this.backdrop, "g.y.grid");
      this.drawYGrid(animate);
    }
  };
  Grid2.prototype.drawXGrid = function(animate) {
    var _this = this;
    var svg = this.parent;
    var height = this.backdrop.attr("height");
    var mainXScale = this.services.cartesianScales.getMainXScale();
    var xGrid = axisBottom(mainXScale).tickSizeInner(-height).tickSizeOuter(0);
    var alignToTicks = Tools.getProperty(this.getOptions(), "grid", "x", "alignWithAxisTicks");
    if (alignToTicks) {
      var mainXPosition = this.services.cartesianScales.getDomainAxisPosition();
      var customDomain = Tools.getProperty(this.getOptions(), "axes", mainXPosition, "ticks", "values");
      if (customDomain) {
        xGrid.tickValues(customDomain);
      }
    } else {
      var numberOfTicks = Tools.getProperty(this.getOptions(), "grid", "x", "numberOfTicks");
      xGrid.ticks(numberOfTicks);
    }
    var g = svg.select(".x.grid").attr("transform", "translate(" + -this.backdrop.attr("x") + ", " + height + ")");
    if (animate) {
      g.transition().call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "grid-update",
          animate
        });
      }).call(xGrid);
    } else {
      g.call(xGrid);
    }
    this.cleanGrid(g);
  };
  Grid2.prototype.drawYGrid = function(animate) {
    var _this = this;
    var svg = this.parent;
    var width = this.backdrop.attr("width");
    var mainYScale = this.services.cartesianScales.getMainYScale();
    var yGrid = axisLeft(mainYScale).tickSizeInner(-width).tickSizeOuter(0);
    var alignToTicks = Tools.getProperty(this.getOptions(), "grid", "y", "alignWithAxisTicks");
    if (alignToTicks) {
      var mainYPosition = this.services.cartesianScales.getRangeAxisPosition();
      var customDomain = Tools.getProperty(this.getOptions(), "axes", mainYPosition, "ticks", "values");
      if (customDomain) {
        yGrid.tickValues(customDomain);
      }
    } else {
      var numberOfTicks = Tools.getProperty(this.getOptions(), "grid", "y", "numberOfTicks");
      yGrid.ticks(numberOfTicks);
    }
    var g = svg.select(".y.grid").attr("transform", "translate(0, " + -this.backdrop.attr("y") + ")");
    if (animate) {
      g.transition().call(function(t) {
        return _this.services.transitions.setupTransition({
          transition: t,
          name: "grid-update",
          animate
        });
      }).call(yGrid);
    } else {
      g.call(yGrid);
    }
    this.cleanGrid(g);
  };
  Grid2.prototype.getGridlineThreshold = function(mousePos) {
    var svg = this.parent;
    var gridlinesX = svg.selectAll(".x.grid .tick").nodes().sort(function(a, b) {
      return Number(Tools.getTranslationValues(a).tx) - Number(Tools.getTranslationValues(b).tx);
    });
    var floor = -1;
    var ceiling;
    if (!gridlinesX.length) {
      return;
    }
    gridlinesX.forEach(function(line3, i) {
      if (mousePos[0] >= +Tools.getTranslationValues(line3).tx) {
        floor++;
      }
    });
    ceiling = floor + 1 < gridlinesX.length ? floor + 1 : gridlinesX.length;
    var line1 = gridlinesX[floor];
    var line2 = gridlinesX[ceiling];
    var lineSpacing;
    if (!line1) {
      lineSpacing = +Tools.getTranslationValues(line2).tx;
    } else if (!line2) {
      var gridElement = svg.select("rect.chart-grid-backdrop").node();
      var width = DOMUtils.getSVGElementSize(gridElement).width;
      lineSpacing = width - +Tools.getTranslationValues(line1).tx;
    } else {
      lineSpacing = +Tools.getTranslationValues(line2).tx - +Tools.getTranslationValues(line1).tx;
    }
    var threshold = this.getOptions().tooltip.gridline.threshold;
    return lineSpacing * threshold;
  };
  Grid2.prototype.getActiveGridline = function(position) {
    var userSpecifiedThreshold = Tools.getProperty(this.getOptions, "tooltip", "gridline", "threshold");
    var threshold = userSpecifiedThreshold ? userSpecifiedThreshold : this.getGridlineThreshold(position);
    var svg = this.parent;
    var xGridlines = svg.selectAll(".x.grid .tick").filter(function() {
      var translations = Tools.getTranslationValues(this);
      var bounds = {
        min: Number(translations.tx) - threshold,
        max: Number(translations.tx) + threshold
      };
      return bounds.min <= position[0] && position[0] <= bounds.max;
    });
    return xGridlines;
  };
  Grid2.prototype.drawBackdrop = function(isXGridEnabled, isYGridEnabled) {
    var svg = this.parent;
    var mainXScale = this.services.cartesianScales.getMainXScale();
    var mainYScale = this.services.cartesianScales.getMainYScale();
    var _a2 = mainXScale.range(), xScaleStart = _a2[0], xScaleEnd = _a2[1];
    var _b = mainYScale.range(), yScaleEnd = _b[0], yScaleStart = _b[1];
    this.backdrop = DOMUtils.appendOrSelect(svg, "svg.chart-grid-backdrop");
    var backdropRect = DOMUtils.appendOrSelect(this.backdrop, isXGridEnabled || isYGridEnabled ? "rect.chart-grid-backdrop.stroked" : "rect.chart-grid-backdrop");
    this.backdrop.merge(backdropRect).attr("x", xScaleStart).attr("y", yScaleStart).attr("width", Math.abs(xScaleEnd - xScaleStart)).attr("height", Math.abs(yScaleEnd - yScaleStart)).lower();
    backdropRect.attr("width", "100%").attr("height", "100%");
  };
  Grid2.prototype.cleanGrid = function(g) {
    g.selectAll("text").remove();
    g.select(".domain").remove();
  };
  return Grid2;
}(Component);
var __extends$J = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var THRESHOLD = 5;
function pointIsWithinThreshold(dx, x2) {
  return dx > x2 - THRESHOLD && dx < x2 + THRESHOLD;
}
var Ruler = function(_super) {
  __extends$J(Ruler2, _super);
  function Ruler2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "ruler";
    _this.renderType = RenderTypes.SVG;
    _this.isXGridEnabled = Tools.getProperty(_this.getOptions(), "grid", "x", "enabled");
    _this.isYGridEnabled = Tools.getProperty(_this.getOptions(), "grid", "y", "enabled");
    _this.isEventListenerAdded = false;
    return _this;
  }
  Ruler2.prototype.render = function() {
    var isRulerEnabled = Tools.getProperty(this.getOptions(), "ruler", "enabled");
    this.drawBackdrop();
    if (isRulerEnabled && !this.isEventListenerAdded) {
      this.addBackdropEventListeners();
    } else if (!isRulerEnabled && this.isEventListenerAdded) {
      this.removeBackdropEventListeners();
    }
  };
  Ruler2.prototype.removeBackdropEventListeners = function() {
    this.isEventListenerAdded = false;
    this.backdrop.on("mousemove mouseover mouseout", null);
  };
  Ruler2.prototype.formatTooltipData = function(tooltipData) {
    return tooltipData;
  };
  Ruler2.prototype.showRuler = function(event, _a2) {
    var _this = this;
    var x2 = _a2[0], y2 = _a2[1];
    var svg = this.parent;
    var orientation = this.services.cartesianScales.getOrientation();
    var displayData = this.model.getDisplayData();
    var rangeScale = this.services.cartesianScales.getRangeScale();
    var _b = rangeScale.range(), yScaleEnd = _b[0], yScaleStart = _b[1];
    var mouseCoordinate = orientation === CartesianOrientations.HORIZONTAL ? y2 : x2;
    var ruler2 = DOMUtils.appendOrSelect(svg, "g.ruler").attr("aria-label", "ruler");
    var rulerLine = DOMUtils.appendOrSelect(ruler2, "line.ruler-line");
    var dataPointElements = svg.selectAll("[role=graphics-symbol]");
    var pointsWithinLine = displayData.map(function(d) {
      return {
        domainValue: _this.services.cartesianScales.getDomainValue(d),
        originalData: d
      };
    }).filter(function(d) {
      return pointIsWithinThreshold(d.domainValue, mouseCoordinate);
    });
    if (this.pointsWithinLine && pointsWithinLine.length === this.pointsWithinLine.length && pointsWithinLine.map(function(point2) {
      return point2.domainValue;
    }).join() === this.pointsWithinLine.map(function(point2) {
      return point2.domainValue;
    }).join()) {
      this.pointsWithinLine = pointsWithinLine;
      return this.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
        mousePosition: [x2, y2]
      });
    }
    this.pointsWithinLine = pointsWithinLine;
    var dataPointsMatchingRulerLine = this.pointsWithinLine.reduce(function(accum, currentValue) {
      if (accum.length === 0) {
        accum.push(currentValue);
        return accum;
      }
      var sampleAccumValue = accum[0].domainValue;
      var distanceToCurrentValue = Math.abs(mouseCoordinate - currentValue.domainValue);
      var distanceToAccumValue = Math.abs(mouseCoordinate - sampleAccumValue);
      if (distanceToCurrentValue > distanceToAccumValue) {
        return accum;
      } else if (distanceToCurrentValue < distanceToAccumValue) {
        accum = [currentValue];
      } else {
        accum.push(currentValue);
      }
      return accum;
    }, []);
    if (dataPointsMatchingRulerLine.length > 0) {
      var tooltipData = dataPointsMatchingRulerLine.map(function(d) {
        return d.originalData;
      }).filter(function(d) {
        var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(d);
        var value2 = d[rangeIdentifier];
        return value2 !== null && value2 !== void 0;
      });
      var domainValuesMatchingRulerLine_1 = dataPointsMatchingRulerLine.map(function(d) {
        return d.domainValue;
      });
      var elementsToHighlight = dataPointElements.filter(function(d) {
        var domainValue = _this.services.cartesianScales.getDomainValue(d);
        return domainValuesMatchingRulerLine_1.includes(domainValue);
      });
      if (this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !Tools.isEqual(this.elementsToHighlight, elementsToHighlight)) {
        this.hideRuler();
      }
      elementsToHighlight.dispatch("mouseover");
      this.elementsToHighlight = elementsToHighlight;
      this.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
        mousePosition: [x2, y2],
        hoveredElement: rulerLine,
        data: this.formatTooltipData(tooltipData)
      });
      ruler2.attr("opacity", 1);
      var sampleMatch = dataPointsMatchingRulerLine[0];
      if (orientation === "horizontal") {
        rulerLine.attr("x1", yScaleStart).attr("x2", yScaleEnd).attr("y1", sampleMatch.domainValue).attr("y2", sampleMatch.domainValue);
      } else {
        rulerLine.attr("y1", yScaleStart).attr("y2", yScaleEnd).attr("x1", sampleMatch.domainValue).attr("x2", sampleMatch.domainValue);
      }
    } else {
      this.hideRuler();
    }
  };
  Ruler2.prototype.hideRuler = function() {
    var svg = this.parent;
    var ruler2 = DOMUtils.appendOrSelect(svg, "g.ruler");
    var dataPointElements = svg.selectAll("[role=graphics-symbol]");
    dataPointElements.dispatch("mouseout");
    this.services.events.dispatchEvent(Events$1.Tooltip.HIDE);
    ruler2.attr("opacity", 0);
  };
  Ruler2.prototype.addBackdropEventListeners = function() {
    this.isEventListenerAdded = true;
    var self2 = this;
    var holder = this.services.domUtils.getHolder();
    var displayData = this.model.getDisplayData();
    var mouseMoveCallback = function(event) {
      var pos = pointer(event, self2.parent.node());
      self2.showRuler(event, pos);
    };
    if (displayData.length > 100) {
      var debounceThreshold = displayData.length % 50 * 12.5;
      mouseMoveCallback = Tools.debounceWithD3MousePosition(function(event) {
        var mousePosition = this.mousePosition;
        self2.showRuler(event, mousePosition);
      }, debounceThreshold, holder);
    }
    this.backdrop.on("mousemove mouseover", mouseMoveCallback).on("mouseout", this.hideRuler.bind(this));
  };
  Ruler2.prototype.drawBackdrop = function() {
    var svg = this.parent;
    this.backdrop = DOMUtils.appendOrSelect(svg, "svg.chart-grid-backdrop");
  };
  return Ruler2;
}(Component);
var __extends$I = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays$g = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var BinnedRuler = function(_super) {
  __extends$I(BinnedRuler2, _super);
  function BinnedRuler2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "ruler-binned";
    _this.renderType = RenderTypes.SVG;
    return _this;
  }
  BinnedRuler2.prototype.showRuler = function(event, _a2) {
    var _this = this;
    var x2 = _a2[0], y2 = _a2[1];
    var svg = this.parent;
    var options2 = this.model.getOptions();
    var orientation = this.services.cartesianScales.getOrientation();
    var rangeScale = this.services.cartesianScales.getRangeScale();
    var _b = rangeScale.range(), yScaleEnd = _b[0], yScaleStart = _b[1];
    var domainScale = this.services.cartesianScales.getDomainScale();
    var correspondingDomainValue = domainScale.invert(orientation === CartesianOrientations.VERTICAL ? x2 : y2);
    var ruler2 = DOMUtils.appendOrSelect(svg, "g.ruler").attr("aria-label", "ruler");
    var rulerLine = DOMUtils.appendOrSelect(ruler2, "line.ruler-line");
    var dataPointElements = svg.selectAll("[role=graphics-symbol]");
    var elementsToHighlight = dataPointElements.filter(function(d) {
      if (parseFloat(get$3(d, "data.x0")) <= correspondingDomainValue && parseFloat(get$3(d, "data.x1")) >= correspondingDomainValue) {
        return true;
      }
    });
    if (elementsToHighlight.size() > 0) {
      if (this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !Tools.isEqual(this.elementsToHighlight, elementsToHighlight)) {
        this.hideRuler();
      }
      elementsToHighlight.dispatch("mouseover");
      this.elementsToHighlight = elementsToHighlight;
      var sampleMatchData_1 = select(elementsToHighlight.nodes()[0]).datum();
      var x0 = parseFloat(get$3(sampleMatchData_1, "data.x0"));
      var x1 = parseFloat(get$3(sampleMatchData_1, "data.x1"));
      var activeDataGroupNames = this.model.getActiveDataGroupNames();
      var tooltipDataGroups = activeDataGroupNames.reverse().map(function(dataGroupName) {
        return {
          label: dataGroupName,
          value: get$3(sampleMatchData_1, "data." + dataGroupName),
          class: _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.TOOLTIP],
            dataGroupName
          })
        };
      }).filter(function(d) {
        return d.value !== 0;
      });
      var thereIsMatchingData = tooltipDataGroups.length > 0;
      if (thereIsMatchingData) {
        this.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
          mousePosition: [x2, y2],
          hoveredElement: rulerLine,
          items: __spreadArrays$g([
            {
              label: get$3(options2, "bins.rangeLabel") || "Range",
              value: x0 + " \u2013 " + x1
            }
          ], tooltipDataGroups, Tools.getProperty(options2, "tooltip", "showTotal") === true ? [
            {
              label: get$3(options2, "tooltip.totalLabel") || "Total",
              value: activeDataGroupNames.reduce(function(accum, currentValue) {
                return accum + parseFloat(get$3(sampleMatchData_1, "data." + currentValue));
              }, 0)
            }
          ] : [])
        });
        ruler2.attr("opacity", 1);
        var rulerPosition = domainScale((x0 + x1) / 2);
        if (orientation === "horizontal") {
          rulerLine.attr("x1", yScaleStart).attr("x2", yScaleEnd).attr("y1", rulerPosition).attr("y2", rulerPosition);
        } else {
          rulerLine.attr("y1", yScaleStart).attr("y2", yScaleEnd).attr("x1", rulerPosition).attr("x2", rulerPosition);
        }
      } else {
        this.hideRuler();
      }
    } else {
      this.hideRuler();
    }
  };
  return BinnedRuler2;
}(Ruler);
var __extends$H = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var StackedRuler = function(_super) {
  __extends$H(StackedRuler2, _super);
  function StackedRuler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  StackedRuler2.prototype.formatTooltipData = function(tooltipData) {
    return tooltipData.reverse();
  };
  return StackedRuler2;
}(Ruler);
var __extends$G = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Toolbar = function(_super) {
  __extends$G(Toolbar2, _super);
  function Toolbar2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "toolbar";
    _this.renderType = RenderTypes.HTML;
    return _this;
  }
  Toolbar2.prototype.init = function() {
    var _this = this;
    var bodyOnClickHandler = function() {
      return _this.updateOverflowMenu(false);
    };
    this.services.events.addEventListener(Events$1.Toolbar.SHOW_OVERFLOW_MENU, function() {
      _this.renderOverflowMenu();
      document.body.addEventListener("click", bodyOnClickHandler);
    });
    this.services.events.addEventListener(Events$1.Toolbar.HIDE_OVERFLOW_MENU, function() {
      document.body.removeEventListener("click", bodyOnClickHandler);
    });
  };
  Toolbar2.prototype.render = function(animate) {
    var _this = this;
    var container = this.getComponentContainer().attr("role", "toolbar");
    var isDataLoading = Tools.getProperty(this.getOptions(), "data", "loading");
    if (isDataLoading) {
      container.html("");
      this.overflowMenu = null;
    } else {
      if (!this.overflowMenu) {
        this.overflowMenu = container.append("div").attr("class", "bx--overflow-menu-options bx--overflow-menu--flip").attr("tabindex", -1).attr("role", "menu").html("<ul></ul>");
      }
      var _a2 = this.getControlConfigs(), buttonList = _a2.buttonList, overflowMenuItemList = _a2.overflowMenuItemList;
      if (!!overflowMenuItemList) {
        buttonList.push(this.getOverflowButtonConfig());
      }
      var toolbarControls = container.selectAll("div.toolbar-control").data(buttonList, function(button) {
        return button.id;
      });
      toolbarControls.exit().remove();
      var enteringToolbarControls = toolbarControls.enter().append("div").attr("class", "toolbar-control bx--overflow-menu").attr("role", "button");
      var self_1 = this;
      enteringToolbarControls.merge(toolbarControls).classed("disabled", function(d) {
        return d.shouldBeDisabled();
      }).attr("aria-disabled", function(d) {
        return d.shouldBeDisabled();
      }).attr("aria-label", function(d) {
        return d.title;
      }).html(function(d) {
        return '\n			<button\n				class="bx--overflow-menu__trigger"\n				aria-haspopup="true" aria-expanded="false" id="' + _this.services.domUtils.generateElementIDString("control-" + d.id) + '" aria-label="' + d.title + '">\n				<svg focusable="false" preserveAspectRatio="xMidYMid meet" style="will-change: transform; width: ' + (d.iconSVG.width !== void 0 ? d.iconSVG.width : "20px") + "; height: " + (d.iconSVG.height !== void 0 ? d.iconSVG.height : "20px") + '" xmlns="http://www.w3.org/2000/svg" class="bx--overflow-menu__icon" viewBox="0 0 32 32" aria-hidden="true">\n					' + d.iconSVG.content + "\n				</svg>\n			</button>";
      }).each(function(d, index2) {
        var _this2 = this;
        select(this).select("button").on("click", function(event) {
          if (!d.shouldBeDisabled()) {
            self_1.triggerFunctionAndEvent(d, event, _this2);
          }
        }).on("keydown", function(event) {
          if (event.key && event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            self_1.triggerFunctionAndEvent(d, event, _this2);
          } else if (event.key && event.key === "ArrowLeft") {
            self_1.focusOnPreviousEnabledToolbarItem(index2);
          } else if (event.key && event.key === "ArrowRight") {
            self_1.focusOnNextEnabledToolbarItem(index2);
          }
        });
      });
      this.overflowButton = this.getComponentContainer().select("button.bx--overflow-menu__trigger#" + this.services.domUtils.generateElementIDString("control-toolbar-overflow-menu"));
    }
  };
  Toolbar2.prototype.renderOverflowMenu = function() {
    var _this = this;
    var overflowMenuItemList = this.getControlConfigs().overflowMenuItemList;
    var overflowMenuControls = this.overflowMenu.select("ul").selectAll("li.bx--overflow-menu-options__option").data(overflowMenuItemList, function(button) {
      return Tools.getProperty(button, "id");
    });
    overflowMenuControls.exit().remove();
    var enteringOverflowMenuControls = overflowMenuControls.enter().append("li").attr("id", function(d) {
      return _this.services.domUtils.generateElementIDString("control-" + d.id);
    }).attr("class", "bx--overflow-menu-options__option").attr("role", "menuitem");
    enteringOverflowMenuControls.append("button").attr("class", "bx--overflow-menu-options__btn");
    enteringOverflowMenuControls.merge(overflowMenuControls).classed("bx--overflow-menu-options__option--disabled", function(d) {
      return d.shouldBeDisabled();
    }).attr("aria-disabled", function(d) {
      return d.shouldBeDisabled();
    }).selectAll("button").text(function(d) {
      return d.text;
    });
  };
  Toolbar2.prototype.isOverflowMenuOpen = function() {
    return this.overflowMenu.classed("is-open");
  };
  Toolbar2.prototype.updateOverflowMenu = function(show) {
    if (!this.overflowMenu) {
      return;
    }
    this.overflowMenu.classed("is-open", show);
    if (this.overflowButton) {
      this.overflowButton.attr("aria-expanded", show);
      select(this.overflowButton.node().parentNode).classed("bx--overflow-menu--open", show);
    }
    if (show) {
      this.services.events.dispatchEvent(Events$1.Toolbar.SHOW_OVERFLOW_MENU);
    } else {
      this.services.events.dispatchEvent(Events$1.Toolbar.HIDE_OVERFLOW_MENU);
    }
  };
  Toolbar2.prototype.focusOnPreviousEnabledToolbarItem = function(currentItemIndex) {
    var buttonList = this.getToolbarButtonItems();
    var previousItemIndex = buttonList.length;
    for (var i = currentItemIndex - 1; i >= 0; i--) {
      var previousButtonItem = buttonList[i];
      if (!previousButtonItem.shouldBeDisabled()) {
        previousItemIndex = i;
        break;
      }
    }
    if (previousItemIndex < buttonList.length) {
      var previousItemNode = select("button#" + this.services.domUtils.generateElementIDString("control-" + buttonList[previousItemIndex].id)).node();
      if ("focus" in previousItemNode) {
        previousItemNode.focus();
      }
    }
  };
  Toolbar2.prototype.focusOnNextEnabledToolbarItem = function(currentItemIndex) {
    var buttonList = this.getToolbarButtonItems();
    var nextItemIndex = -1;
    for (var i = currentItemIndex + 1; i < buttonList.length; i++) {
      var nextOverflowMenuItem = buttonList[i];
      if (!nextOverflowMenuItem.shouldBeDisabled()) {
        nextItemIndex = i;
        break;
      }
    }
    if (nextItemIndex > -1) {
      var nextItemNode = select("button#" + this.services.domUtils.generateElementIDString("control-" + buttonList[nextItemIndex].id)).node();
      if ("focus" in nextItemNode) {
        nextItemNode.focus();
      }
    }
  };
  Toolbar2.prototype.focusOnPreviousEnabledMenuItem = function(currentItemIndex) {
    var overflowMenuItems = this.getOverflowMenuItems();
    var previousItemIndex = overflowMenuItems.length;
    for (var i = currentItemIndex - 1; i >= 0; i--) {
      var previousOverflowMenuItem = overflowMenuItems[i];
      if (!previousOverflowMenuItem.shouldBeDisabled()) {
        previousItemIndex = i;
        break;
      }
    }
    if (previousItemIndex < overflowMenuItems.length) {
      var previousItemNode = select("#" + this.services.domUtils.generateElementIDString("control-" + overflowMenuItems[previousItemIndex].id) + " button").node();
      if ("focus" in previousItemNode) {
        previousItemNode.focus();
      }
    }
  };
  Toolbar2.prototype.focusOnNextEnabledMenuItem = function(currentItemIndex) {
    var overflowMenuItems = this.getOverflowMenuItems();
    var nextItemIndex = -1;
    for (var i = currentItemIndex + 1; i < overflowMenuItems.length; i++) {
      var nextOverflowMenuItem = overflowMenuItems[i];
      if (!nextOverflowMenuItem.shouldBeDisabled()) {
        nextItemIndex = i;
        break;
      }
    }
    if (nextItemIndex > -1) {
      var nextItemNode = select("#" + this.services.domUtils.generateElementIDString("control-" + overflowMenuItems[nextItemIndex].id) + " button").node();
      if ("focus" in nextItemNode) {
        nextItemNode.focus();
      }
    }
  };
  Toolbar2.prototype.toggleOverflowMenu = function(event) {
    var _this = this;
    if (this.isOverflowMenuOpen()) {
      this.updateOverflowMenu(false);
    } else {
      this.updateOverflowMenu(true);
      var self_2 = this;
      var overflowMenuItems = this.getOverflowMenuItems();
      overflowMenuItems.forEach(function(menuItem, index2) {
        var element = select("#" + _this.services.domUtils.generateElementIDString("control-" + menuItem.id));
        if (element !== null) {
          element.on("click", function() {
            self_2.triggerFunctionAndEvent(menuItem, event, element.node());
            self_2.updateOverflowMenu(false);
          });
          element.on("keydown", function(keyEvent) {
            if (keyEvent && keyEvent.key === "Enter") {
              self_2.triggerFunctionAndEvent(menuItem, event, element.node());
            } else if (keyEvent && keyEvent.key === "ArrowUp") {
              self_2.focusOnPreviousEnabledMenuItem(index2);
            } else if (keyEvent && keyEvent.key === "ArrowDown") {
              self_2.focusOnNextEnabledMenuItem(index2);
            } else if (keyEvent && keyEvent.key === "Escape") {
              self_2.updateOverflowMenu(false);
            }
            keyEvent.preventDefault();
          });
        }
      });
      self_2.focusOnNextEnabledMenuItem(-1);
    }
    if (!!event) {
      event.stopImmediatePropagation();
    }
  };
  Toolbar2.prototype.triggerFunctionAndEvent = function(control, event, element) {
    if (typeof control.clickFunction === "function") {
      control.clickFunction(event);
    }
    this.services.events.dispatchEvent(Events$1.Toolbar.BUTTON_CLICK, {
      control,
      event,
      element
    });
  };
  Toolbar2.prototype.getControlConfigs = function() {
    var _this = this;
    var numberOfIcons = Tools.getProperty(this.getOptions(), "toolbar", "numberOfIcons") - 1;
    var controls = Tools.getProperty(this.getOptions(), "toolbar", "controls");
    var overflowSpecificControls = [];
    var buttonList = [];
    var overflowList = [];
    controls.forEach(function(control) {
      var controlConfig = null;
      if (control.type === ToolbarControlTypes.CUSTOM) {
        if (Tools.getProperty(control, "id") === null) {
          control.id = "toolbar-button-" + Toolbar2.buttonID++;
        }
        if (Tools.getProperty(control, "shouldBeDisabled") === null) {
          control.shouldBeDisabled = function() {
            return false;
          };
        }
        controlConfig = control;
      } else {
        controlConfig = _this.getControlConfigByType(control.type);
      }
      if (controlConfig) {
        controlConfig.text = control.text ? control.text : control.type;
        if (controlConfig.id.indexOf("toolbar-export") !== -1) {
          overflowSpecificControls.push(controlConfig);
        } else if (buttonList.length < numberOfIcons) {
          if (Tools.getProperty(controlConfig, "iconSVG", "content") === null) {
            overflowList.push(controlConfig);
          } else {
            buttonList.push(controlConfig);
          }
        } else {
          overflowList.push(controlConfig);
        }
      }
    });
    overflowList.push.apply(overflowList, overflowSpecificControls);
    if (!overflowList.length) {
      return {
        buttonList
      };
    }
    return {
      buttonList,
      overflowMenuItemList: overflowList
    };
  };
  Toolbar2.prototype.getToolbarButtonItems = function() {
    var _a2 = this.getControlConfigs(), buttonList = _a2.buttonList, overflowMenuItemList = _a2.overflowMenuItemList;
    if (!!overflowMenuItemList) {
      buttonList.push(this.getOverflowButtonConfig());
    }
    if (!!buttonList) {
      return buttonList;
    }
    return [];
  };
  Toolbar2.prototype.getOverflowMenuItems = function() {
    var overflowMenuItemList = this.getControlConfigs().overflowMenuItemList;
    if (!!overflowMenuItemList) {
      return overflowMenuItemList;
    } else {
      return [];
    }
  };
  Toolbar2.prototype.getOverflowButtonConfig = function() {
    var _this = this;
    return {
      id: "toolbar-overflow-menu",
      title: "More options",
      shouldBeDisabled: function() {
        return false;
      },
      iconSVG: {
        content: '<circle cx="16" cy="8" r="2"></circle>\n				<circle cx="16" cy="16" r="2"></circle>\n				<circle cx="16" cy="24" r="2"></circle>'
      },
      clickFunction: function(event) {
        return _this.toggleOverflowMenu(event);
      }
    };
  };
  Toolbar2.prototype.getControlConfigByType = function(controlType) {
    var _this = this;
    var isZoomBarEnabled = this.services.zoom && this.services.zoom.isZoomBarEnabled() && !this.services.zoom.isEmptyState();
    var displayData = this.model.getDisplayData();
    var controlConfig;
    switch (controlType) {
      case ToolbarControlTypes.ZOOM_IN:
        if (isZoomBarEnabled) {
          controlConfig = {
            id: "toolbar-zoomIn",
            title: "Zoom in",
            shouldBeDisabled: function() {
              return _this.services.zoom.isMinZoomDomain();
            },
            iconSVG: {
              content: this.getControlIconByType(controlType)
            },
            clickFunction: function() {
              return _this.services.zoom.zoomIn();
            }
          };
        }
        break;
      case ToolbarControlTypes.ZOOM_OUT:
        if (isZoomBarEnabled) {
          controlConfig = {
            id: "toolbar-zoomOut",
            title: "Zoom out",
            shouldBeDisabled: function() {
              return _this.services.zoom.isMaxZoomDomain();
            },
            iconSVG: {
              content: this.getControlIconByType(controlType)
            },
            clickFunction: function() {
              return _this.services.zoom.zoomOut();
            }
          };
        }
        break;
      case ToolbarControlTypes.RESET_ZOOM:
        if (isZoomBarEnabled) {
          controlConfig = {
            id: "toolbar-resetZoom",
            title: "Reset zoom",
            shouldBeDisabled: function() {
              return _this.services.zoom.isMaxZoomDomain();
            },
            iconSVG: {
              content: this.getControlIconByType(controlType)
            },
            clickFunction: function() {
              return _this.services.zoom.resetZoomDomain();
            }
          };
        }
        break;
      case ToolbarControlTypes.MAKE_FULLSCREEN:
        controlConfig = {
          id: "toolbar-makefullscreen",
          iconSVG: {
            content: this.getControlIconByType(controlType),
            width: "15px",
            height: "15px"
          },
          title: "Make fullscreen",
          shouldBeDisabled: function() {
            return false;
          },
          clickFunction: function() {
            _this.services.domUtils.toggleFullscreen();
          }
        };
        break;
      case ToolbarControlTypes.SHOW_AS_DATATABLE:
        controlConfig = {
          id: "toolbar-showasdatatable",
          iconSVG: {
            content: this.getControlIconByType(controlType)
          },
          title: "Show as table",
          shouldBeDisabled: function() {
            return displayData.length === 0;
          },
          clickFunction: function() {
            return _this.services.events.dispatchEvent(Events$1.Modal.SHOW);
          }
        };
        break;
      case ToolbarControlTypes.EXPORT_CSV:
        controlConfig = {
          id: "toolbar-export-CSV",
          title: "Export as CSV",
          shouldBeDisabled: function() {
            return false;
          },
          iconSVG: {
            content: this.getControlIconByType(controlType)
          },
          clickFunction: function() {
            return _this.model.exportToCSV();
          }
        };
        break;
      case ToolbarControlTypes.EXPORT_PNG:
        controlConfig = {
          id: "toolbar-export-PNG",
          title: "Export as PNG",
          shouldBeDisabled: function() {
            return false;
          },
          iconSVG: {
            content: this.getControlIconByType(controlType)
          },
          clickFunction: function() {
            return _this.services.domUtils.exportToPNG();
          }
        };
        break;
      case ToolbarControlTypes.EXPORT_JPG:
        controlConfig = {
          id: "toolbar-export-JPG",
          title: "Export as JPG",
          shouldBeDisabled: function() {
            return false;
          },
          iconSVG: {
            content: this.getControlIconByType(controlType)
          },
          clickFunction: function() {
            return _this.services.domUtils.exportToJPG();
          }
        };
        break;
      default:
        throw Error("Not supported toolbar control type: " + controlType);
    }
    return controlConfig;
  };
  Toolbar2.prototype.getControlIconByType = function(controlType) {
    switch (controlType) {
      case ToolbarControlTypes.ZOOM_IN:
        return '<polygon points="19 13 15 13 15 9 13 9 13 13 9 13 9 15 13 15 13 19 15 19 15 15 19 15 19 13"/>\n						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>';
      case ToolbarControlTypes.ZOOM_OUT:
        return '<rect x="9" y="13" width="10" height="2"/>\n						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>';
      case ToolbarControlTypes.RESET_ZOOM:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case ToolbarControlTypes.MAKE_FULLSCREEN:
        return '<polygon points="21 2 21 4 26.59 4 17 13.58 18.41 15 28 5.41 28 11 30 11 30 2 21 2"/><polygon points="15 18.42 13.59 17 4 26.59 4 21 2 21 2 30 11 30 11 28 5.41 28 15 18.42"/>';
      case ToolbarControlTypes.SHOW_AS_DATATABLE:
        return '<rect x="4" y="6" width="18" height="2"/><rect x="4" y="12" width="18" height="2"/><rect x="4" y="18" width="18" height="2"/><rect x="4" y="24" width="18" height="2"/><rect x="26" y="6" width="2" height="2"/><rect x="26" y="12" width="2" height="2"/><rect x="26" y="18" width="2" height="2"/><rect x="26" y="24" width="2" height="2"/>';
      case ToolbarControlTypes.EXPORT_CSV:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case ToolbarControlTypes.EXPORT_JPG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case ToolbarControlTypes.EXPORT_PNG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      default:
        throw Error("Not supported toolbar control type: " + controlType);
    }
  };
  Toolbar2.buttonID = 0;
  return Toolbar2;
}(Component);
var __extends$F = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ZeroLine = function(_super) {
  __extends$F(ZeroLine2, _super);
  function ZeroLine2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "zero-line";
    _this.renderType = RenderTypes.SVG;
    return _this;
  }
  ZeroLine2.prototype.render = function(animate) {
    var _this = this;
    var axisPosition = this.services.cartesianScales.getRangeAxisPosition({ groups: this.configs.groups });
    var rangeScale = this.services.cartesianScales.getScaleByPosition(axisPosition);
    var _a2 = rangeScale.domain(), minDomainValue = _a2[0], maxDomainValue = _a2[1];
    var drawZeroLine = minDomainValue > 0 && maxDomainValue < 0 || minDomainValue < 0 && maxDomainValue > 0;
    var svg = this.getComponentContainer();
    if (!drawZeroLine) {
      svg.selectAll("line.domain").remove();
      return;
    }
    var _b = this.services.cartesianScales.getDomainScale().range(), x0 = _b[0], x1 = _b[1];
    var yPosition = +rangeScale(0) + 0.5;
    if (!yPosition) {
      yPosition = rangeScale.range()[0];
    }
    var lineCoordinates = Tools.flipSVGCoordinatesBasedOnOrientation({
      x0,
      x1,
      y0: yPosition,
      y1: yPosition
    }, this.services.cartesianScales.getOrientation());
    var line2 = DOMUtils.appendOrSelect(svg, "line.domain");
    line2.transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "zero-line-update",
        animate
      });
    }).attr("y1", lineCoordinates.y0).attr("y2", lineCoordinates.y1).attr("x1", lineCoordinates.x0).attr("x2", lineCoordinates.x1);
  };
  return ZeroLine2;
}(Component);
var __extends$E = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ZoomBar = function(_super) {
  __extends$E(ZoomBar2, _super);
  function ZoomBar2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "zoom-bar";
    _this.renderType = RenderTypes.SVG;
    _this.MIN_SELECTION_DIFF = 9e-10;
    _this.brushSelector = "g.zoom-bar-brush";
    _this.clipId = "zoomBarClip-" + Math.floor(Math.random() * 99999999999);
    _this.brush = brushX();
    _this.highlightStrokeWidth = 1;
    return _this;
  }
  ZoomBar2.prototype.init = function() {
    this.services.events.addEventListener(Events$1.ZoomBar.UPDATE, this.render.bind(this));
    var definedZoomBarData = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "data");
    this.model.setZoomBarData(definedZoomBarData);
  };
  ZoomBar2.prototype.render = function(animate) {
    var _this = this;
    var svg = this.getComponentContainer();
    var isTopZoomBarLoading = this.services.zoom.isZoomBarLoading(AxisPositions.TOP);
    var isTopZoomBarLocked = this.services.zoom.isZoomBarLocked(AxisPositions.TOP);
    var zoombarType = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "type");
    var highlight = Tools.getProperty(this.getOptions(), "axes", AxisPositions.BOTTOM, "highlights");
    var zoombarHeight = zoomBar.height[zoombarType];
    var width = DOMUtils.getSVGElementSize(this.parent, {
      useAttrs: true
    }).width;
    if (width === 0) {
      return;
    }
    var axesLeftMargin = 0;
    var axesMargins = this.model.get("axesMargins");
    if (axesMargins && axesMargins.left) {
      axesLeftMargin = axesMargins.left;
    }
    var container = DOMUtils.appendOrSelect(svg, "svg.zoom-container").attr("width", "100%").attr("height", zoombarHeight).attr("opacity", 1);
    DOMUtils.appendOrSelect(svg, "rect.zoom-spacer").attr("x", 0).attr("y", zoombarHeight).attr("width", "100%").attr("height", zoomBar.spacerHeight).attr("opacity", 1).attr("fill", "none");
    if (zoombarType === ZoomBarTypes.GRAPH_VIEW) {
      DOMUtils.appendOrSelect(container, "rect.zoom-bg").attr("x", axesLeftMargin).attr("y", 0).attr("width", width - axesLeftMargin).attr("height", "100%").classed("zoom-bg-skeleton", isTopZoomBarLoading).style("stroke", isTopZoomBarLoading ? "url(#" + this.services.domUtils.generateElementIDString("shimmer-lines") + ")" : null);
    } else if (zoombarType === ZoomBarTypes.SLIDER_VIEW) {
      DOMUtils.appendOrSelect(container, "rect.zoom-slider-bg").attr("x", axesLeftMargin).attr("y", zoombarHeight / 2 - 1).attr("width", width - axesLeftMargin).attr("height", 2).classed("zoom-slider-bg-skeleton", isTopZoomBarLoading).style("stroke", isTopZoomBarLoading ? "url(#" + this.services.domUtils.generateElementIDString("shimmer-lines") + ")" : null);
    }
    if (isTopZoomBarLoading) {
      this.renderSkeleton(container, axesLeftMargin, width);
      return;
    }
    var cartesianScales = this.services.cartesianScales;
    var mainXScale = cartesianScales.getMainXScale();
    var mainYScale = cartesianScales.getMainYScale();
    var mainXScaleType = cartesianScales.getMainXScaleType();
    if (mainXScale && mainXScaleType === ScaleTypes.TIME) {
      var zoomBarData = this.services.zoom.getZoomBarData();
      if (Tools.isEmpty(zoomBarData) || zoomBarData.length === 1) {
        return;
      }
      this.xScale = mainXScale.copy();
      this.yScale = mainYScale.copy();
      var defaultDomain = this.services.zoom.getDefaultZoomBarDomain(zoomBarData);
      zoomBarData = this.compensateDataForDefaultDomain(zoomBarData, defaultDomain);
      var oldInitialZoomDomain = this.model.get("initialZoomDomain");
      var newInitialZoomDomain = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "initialZoomDomain");
      if (newInitialZoomDomain && newInitialZoomDomain[0] && newInitialZoomDomain[1]) {
        newInitialZoomDomain[0] = new Date(newInitialZoomDomain[0]);
        newInitialZoomDomain[1] = new Date(newInitialZoomDomain[1]);
      }
      if (newInitialZoomDomain && !(oldInitialZoomDomain && oldInitialZoomDomain[0].valueOf() === newInitialZoomDomain[0].valueOf() && oldInitialZoomDomain[1].valueOf() === newInitialZoomDomain[1].valueOf())) {
        this.model.set({
          initialZoomDomain: Tools.merge([], newInitialZoomDomain),
          zoomDomain: newInitialZoomDomain ? Tools.merge([], newInitialZoomDomain) : defaultDomain
        }, { skipUpdate: true });
      } else if (newInitialZoomDomain === null && oldInitialZoomDomain !== null) {
        this.model.set({
          initialZoomDomain: null,
          zoomDomain: Tools.merge([], defaultDomain)
        }, { skipUpdate: true });
      }
      this.xScale.range([axesLeftMargin, width]).domain(defaultDomain);
      this.maxSelectionRange = this.xScale.range();
      this.yScale.range([0, zoombarHeight - 6]).domain(extent(zoomBarData, function(d) {
        return d.value;
      }));
      var zoomDomain = this.model.get("zoomDomain");
      if (zoombarType === ZoomBarTypes.GRAPH_VIEW) {
        this.renderZoomBarArea(container, "path.zoom-graph-area-unselected", zoomBarData, null);
        this.updateClipPath(svg, this.clipId, 0, 0, 0, 0);
        this.renderZoomBarArea(container, "path.zoom-graph-area", zoomBarData, this.clipId);
        this.renderZoomBarBaseline(container, axesLeftMargin, width);
        if (highlight) {
          var startHighlight_1 = highlight.highlightStartMapsTo;
          var endHighlight_1 = highlight.highlightEndMapsTo;
          var color_1 = highlight.color;
          var labelMapTo_1 = highlight.labelMapsTo;
          highlight.data.forEach(function(element, index2) {
            DOMUtils.appendOrSelect(container, "rect.highlight-" + index2).attr("height", zoombarHeight - 2 * _this.highlightStrokeWidth).attr("y", _this.highlightStrokeWidth).attr("x", _this.xScale(element[startHighlight_1])).attr("width", _this.xScale(element[endHighlight_1]) - _this.xScale(element[startHighlight_1])).style("fill", color_1 && color_1.scale[element[labelMapTo_1]] ? color_1.scale[element[labelMapTo_1]] : null).style("fill-opacity", 0.1).style("stroke", color_1 && color_1.scale[element[labelMapTo_1]] ? color_1.scale[element[labelMapTo_1]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", 1 + "px");
          });
        }
      }
      this.addBrushEventListener(zoomDomain, axesLeftMargin, width);
      var brushArea = DOMUtils.appendOrSelect(svg, this.brushSelector).call(this.brush);
      if (zoomDomain === void 0)
        ;
      else if (zoomDomain[0].valueOf() === zoomDomain[1].valueOf()) {
        brushArea.call(this.brush.move, this.xScale.range());
        this.updateBrushHandle(this.getComponentContainer(), this.xScale.range(), this.xScale.domain());
      } else {
        var selected = zoomDomain.map(function(domain) {
          return _this.xScale(domain);
        });
        if (selected[1] - selected[0] < this.MIN_SELECTION_DIFF)
          ;
        else {
          brushArea.call(this.brush.move, selected);
          this.updateBrushHandle(this.getComponentContainer(), selected, zoomDomain);
        }
      }
      if (isTopZoomBarLocked) {
        this.brush.filter(function() {
          return false;
        });
        brushArea.selectAll("rect").attr("cursor", "auto");
      }
    }
  };
  ZoomBar2.prototype.addBrushEventListener = function(zoomDomain, axesLeftMargin, width) {
    var _this = this;
    var brushEventListener = function(event) {
      var selection2 = event.selection;
      if (selection2 === null) {
        _this.handleBrushedEvent(event, zoomDomain, _this.xScale, _this.xScale.range());
      } else if (selection2[0] === selection2[1])
        ;
      else {
        _this.handleBrushedEvent(event, zoomDomain, _this.xScale, selection2);
      }
    };
    var zoombarType = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "type");
    var zoombarHeight = zoomBar.height[zoombarType];
    this.brush.extent([
      [axesLeftMargin, 0],
      [width, zoombarHeight]
    ]).on("start brush end", null).on("start brush end", brushEventListener);
  };
  ZoomBar2.prototype.handleBrushedEvent = function(event, zoomDomain, scale, selection2) {
    var newDomain = [
      scale.invert(selection2[0]),
      scale.invert(selection2[1])
    ];
    this.updateBrushHandle(this.getComponentContainer(), selection2, newDomain);
    if (event.sourceEvent != null && (event.sourceEvent.type === "mousemove" || event.sourceEvent.type === "mouseup" || event.sourceEvent.type === "mousedown" || event.sourceEvent.type === "touchstart" || event.sourceEvent.type === "touchmove" || event.sourceEvent.type === "touchend")) {
      if (zoomDomain === void 0 || zoomDomain[0] !== newDomain[0] || zoomDomain[1] !== newDomain[1]) {
        this.services.zoom.handleDomainChange(newDomain, {
          dispatchEvent: false
        });
      }
      var zoomBarEventType = void 0;
      if (event.type === "start") {
        zoomBarEventType = Events$1.ZoomBar.SELECTION_START;
      } else if (event.type === "brush") {
        zoomBarEventType = Events$1.ZoomBar.SELECTION_IN_PROGRESS;
      } else if (event.type === "end") {
        zoomBarEventType = Events$1.ZoomBar.SELECTION_END;
        this.services.events.dispatchEvent(Events$1.ZoomDomain.CHANGE, {
          newDomain
        });
      }
      this.services.events.dispatchEvent(zoomBarEventType, {
        selection: selection2,
        newDomain
      });
    }
  };
  ZoomBar2.prototype.updateBrushHandle = function(svg, selection2, domain) {
    var self2 = this;
    var handleWidth = zoomBar.handleWidth;
    var zoombarType = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "type");
    var handleHeight = zoomBar.height[zoombarType];
    var handleXDiff = -handleWidth / 2;
    var handleBarWidth = zoomBar.handleBarWidth;
    var handleBarHeight = zoombarType === ZoomBarTypes.GRAPH_VIEW ? zoomBar.handleBarHeight : 6;
    var handleBarXDiff = -handleBarWidth / 2;
    var handleYBarDiff = (handleHeight - handleBarHeight) / 2;
    svg.select(this.brushSelector).selectAll("rect.handle").data([{ type: "w" }, { type: "e" }]).attr("x", function(d) {
      if (d.type === "w") {
        return Math.max(selection2[0] + handleXDiff, self2.maxSelectionRange[0]);
      } else if (d.type === "e") {
        return Math.min(selection2[1] + handleXDiff, self2.maxSelectionRange[1] - handleWidth);
      }
    }).attr("y", 0).attr("width", handleWidth).attr("height", handleHeight).attr("cursor", "ew-resize").style("display", null);
    var handleBars = svg.select(this.brushSelector).selectAll("rect.handle-bar").data([{ type: "w" }, { type: "e" }]);
    handleBars.enter().append("rect").attr("class", function(d) {
      return "handle-bar handle-bar--" + d.type;
    });
    handleBars.attr("x", function(d) {
      if (d.type === "w") {
        return Math.max(selection2[0] + handleBarXDiff, self2.maxSelectionRange[0] - handleXDiff + handleBarXDiff);
      } else if (d.type === "e") {
        return Math.min(selection2[1] + handleBarXDiff, self2.maxSelectionRange[1] + handleXDiff + handleBarXDiff);
      }
    }).attr("y", handleYBarDiff).attr("width", handleBarWidth).attr("height", handleBarHeight).attr("cursor", "ew-resize");
    if (zoombarType === ZoomBarTypes.SLIDER_VIEW) {
      this.updateSliderSelectedArea(selection2);
    }
    this.updateClipPath(svg, this.clipId, selection2[0], 0, selection2[1] - selection2[0], handleHeight);
  };
  ZoomBar2.prototype.updateSliderSelectedArea = function(selection2) {
    var zoombarType = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "type");
    var zoombarHeight = zoomBar.height[zoombarType];
    DOMUtils.getSVGElementSize(this.parent, {
      useAttrs: true
    }).width;
    var axesMargins = this.model.get("axesMargins");
    if (axesMargins && axesMargins.left)
      ;
    var svg = this.getComponentContainer();
    var container = svg.select("svg.zoom-container");
    DOMUtils.appendOrSelect(container, "rect.zoom-slider-selected-area").attr("x", selection2[0]).attr("y", zoombarHeight / 2 - 1).attr("width", selection2[1] - selection2[0]).attr("height", 2);
  };
  ZoomBar2.prototype.renderZoomBarArea = function(container, querySelector, data, clipId) {
    var cartesianScales = this.services.cartesianScales;
    var mainXAxisPosition = cartesianScales.getMainXAxisPosition();
    var mainYAxisPosition = cartesianScales.getMainYAxisPosition();
    var mainXScaleType = cartesianScales.getMainXScaleType();
    var mainYScaleType = cartesianScales.getMainYScaleType();
    var accessorFunction = function(scale, scaleType, axisPosition) {
      return function(d, i) {
        return cartesianScales.getValueFromScale(scale, scaleType, axisPosition, d, i);
      };
    };
    var xAccessor = accessorFunction(this.xScale, mainXScaleType, mainXAxisPosition);
    var yAccessor = accessorFunction(this.yScale, mainYScaleType, mainYAxisPosition);
    var zoombarType = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "type");
    var zoombarHeight = zoomBar.height[zoombarType];
    var areaGenerator = area().x(function(d, i) {
      return xAccessor(d, i);
    }).y0(zoombarHeight).y1(function(d, i) {
      return zoombarHeight - yAccessor(d, i);
    });
    var areaGraph = DOMUtils.appendOrSelect(container, querySelector).datum(data).attr("d", areaGenerator);
    if (clipId) {
      areaGraph.attr("clip-path", "url(#" + clipId + ")");
    }
  };
  ZoomBar2.prototype.updateClipPath = function(svg, clipId, x2, y2, width, height) {
    var zoomBarClipPath = DOMUtils.appendOrSelect(svg, "clipPath").attr("id", clipId);
    DOMUtils.appendOrSelect(zoomBarClipPath, "rect").attr("x", x2).attr("y", y2).attr("width", width).attr("height", height);
  };
  ZoomBar2.prototype.compensateDataForDefaultDomain = function(data, defaultDomain) {
    if (!data || data.length < 2) {
      return;
    }
    var zoomBarData = Tools.clone(data);
    var domainIdentifier = this.services.cartesianScales.getDomainIdentifier();
    var rangeIdentifier = this.services.cartesianScales.getRangeIdentifier();
    if (Number(defaultDomain[0]) < Number(zoomBarData[0][domainIdentifier])) {
      var newDatum = {};
      newDatum[domainIdentifier] = defaultDomain[0];
      newDatum[rangeIdentifier] = 0;
      zoomBarData.unshift(newDatum);
    }
    if (Number(defaultDomain[1]) > Number(zoomBarData[zoomBarData.length - 1][domainIdentifier])) {
      var newDatum = {};
      newDatum[domainIdentifier] = defaultDomain[1];
      newDatum[rangeIdentifier] = 0;
      zoomBarData.push(newDatum);
    }
    return zoomBarData;
  };
  ZoomBar2.prototype.renderZoomBarBaseline = function(container, startX, endX, skeletonClass) {
    if (skeletonClass === void 0) {
      skeletonClass = false;
    }
    var zoombarType = Tools.getProperty(this.model.getOptions(), "zoomBar", AxisPositions.TOP, "type");
    var zoombarHeight = zoomBar.height[zoombarType];
    var baselineGenerator = line()([
      [startX, zoombarHeight],
      [endX, zoombarHeight]
    ]);
    DOMUtils.appendOrSelect(container, "path.zoom-bg-baseline").attr("d", baselineGenerator).classed("zoom-bg-baseline-skeleton", skeletonClass).style("stroke", skeletonClass ? "url(#" + this.services.domUtils.generateElementIDString("shimmer-lines") + ")" : null);
  };
  ZoomBar2.prototype.renderSkeleton = function(container, startX, endX) {
    this.renderZoomBarArea(container, "path.zoom-graph-area-unselected", [], null);
    this.renderZoomBarArea(container, "path.zoom-graph-area", [], this.clipId);
    this.brush.on("start brush end", null);
    DOMUtils.appendOrSelect(this.getComponentContainer(), this.brushSelector).html(null);
    var zoombarType = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "type");
    if (zoombarType === ZoomBarTypes.GRAPH_VIEW) {
      this.renderZoomBarBaseline(container, startX, endX, true);
    }
  };
  ZoomBar2.prototype.destroy = function() {
    this.brush.on("start brush end", null);
    this.services.events.removeEventListener(Events$1.ZoomBar.UPDATE, this.render.bind(this));
  };
  return ZoomBar2;
}(Component);
var __spreadArrays$f = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var Chart = function() {
  function Chart2(holder, chartConfigs) {
    this.services = {
      domUtils: DOMUtils,
      files: Files,
      events: Events,
      gradientUtils: GradientUtils,
      transitions: Transitions,
      canvasZoom: CanvasZoom
    };
    this.model = new ChartModel(this.services);
  }
  Chart2.prototype.init = function(holder, chartConfigs) {
    var _this = this;
    this.model.set({ holder }, { skipUpdate: true });
    Object.keys(this.services).forEach(function(serviceName) {
      var serviceObj = _this.services[serviceName];
      _this.services[serviceName] = new serviceObj(_this.model, _this.services);
    });
    this.services.events.addEventListener(Events$1.Model.UPDATE, function(e) {
      var animate = !!Tools.getProperty(e, "detail", "animate");
      _this.update(animate);
    });
    this.model.setData(chartConfigs.data);
    this.services.events.addEventListener(Events$1.Chart.RESIZE, function() {
      _this.update(false);
    });
    this.components = this.getComponents();
    this.update();
  };
  Chart2.prototype.getComponents = function() {
    console.error("getComponents() method is not implemented");
    return null;
  };
  Chart2.prototype.update = function(animate) {
    var _this = this;
    if (animate === void 0) {
      animate = true;
    }
    if (!this.components) {
      return;
    }
    Object.keys(this.services).forEach(function(serviceName) {
      var serviceObj = _this.services[serviceName];
      serviceObj.update();
    });
    this.components.forEach(function(component) {
      return component.render(animate);
    });
    var pendingTransitions = this.services.transitions.getPendingTransitions();
    var promises = Object.keys(pendingTransitions).map(function(transitionID) {
      var transition = pendingTransitions[transitionID];
      return transition.end().catch(function(e) {
        return e;
      });
    });
    Promise.all(promises).then(function() {
      return _this.services.events.dispatchEvent(Events$1.Chart.RENDER_FINISHED);
    });
  };
  Chart2.prototype.destroy = function() {
    this.components.forEach(function(component) {
      return component.destroy();
    });
    this.services.domUtils.getHolder().remove();
    this.model.set({ destroyed: true }, { skipUpdate: true });
  };
  Chart2.prototype.getChartComponents = function(graphFrameComponents, configs) {
    var options2 = this.model.getOptions();
    var toolbarEnabled = Tools.getProperty(options2, "toolbar", "enabled");
    var legendComponent = {
      id: "legend",
      components: [new Legend(this.model, this.services)],
      growth: LayoutGrowth.PREFERRED
    };
    var isZoomEnabled = Tools.getProperty(options2, "canvasZoom", "enabled");
    if (isZoomEnabled && isZoomEnabled === true) {
      graphFrameComponents.push(new CanvasChartClip(this.model, this.services));
    }
    var titleAvailable = !!this.model.getOptions().title;
    var titleComponent = {
      id: "title",
      components: [new Title(this.model, this.services)],
      growth: LayoutGrowth.STRETCH
    };
    var toolbarComponent = {
      id: "toolbar",
      components: [new Toolbar(this.model, this.services)],
      growth: LayoutGrowth.PREFERRED
    };
    var headerComponent = {
      id: "header",
      components: [
        new LayoutComponent(this.model, this.services, __spreadArrays$f([
          titleComponent
        ], toolbarEnabled ? [toolbarComponent] : []), {
          direction: LayoutDirection.ROW,
          alignItems: LayoutAlignItems.CENTER
        })
      ],
      growth: LayoutGrowth.PREFERRED
    };
    var graphFrameComponent = {
      id: "graph-frame",
      components: graphFrameComponents,
      growth: LayoutGrowth.STRETCH,
      renderType: Tools.getProperty(configs, "graphFrameRenderType") || RenderTypes.SVG
    };
    var isLegendEnabled = Tools.getProperty(configs, "excludeLegend") !== true && options2.legend.enabled !== false;
    var fullFrameComponentDirection = LayoutDirection.COLUMN;
    if (isLegendEnabled) {
      var legendPosition = Tools.getProperty(options2, "legend", "position");
      if (legendPosition === "left") {
        fullFrameComponentDirection = LayoutDirection.ROW;
        if (!options2.legend.orientation) {
          options2.legend.orientation = LegendOrientations.VERTICAL;
        }
      } else if (legendPosition === "right") {
        fullFrameComponentDirection = LayoutDirection.ROW_REVERSE;
        if (!options2.legend.orientation) {
          options2.legend.orientation = LegendOrientations.VERTICAL;
        }
      } else if (legendPosition === "bottom") {
        fullFrameComponentDirection = LayoutDirection.COLUMN_REVERSE;
      }
    }
    var legendSpacerComponent = {
      id: "spacer",
      components: [new Spacer(this.model, this.services)],
      growth: LayoutGrowth.PREFERRED
    };
    var fullFrameComponent = {
      id: "full-frame",
      components: [
        new LayoutComponent(this.model, this.services, __spreadArrays$f(isLegendEnabled ? [legendComponent] : [], isLegendEnabled ? [legendSpacerComponent] : [], [
          graphFrameComponent
        ]), {
          direction: fullFrameComponentDirection
        })
      ],
      growth: LayoutGrowth.STRETCH
    };
    var topLevelLayoutComponents = [];
    if (titleAvailable || toolbarEnabled) {
      topLevelLayoutComponents.push(headerComponent);
      var titleSpacerComponent = {
        id: "spacer",
        components: [
          new Spacer(this.model, this.services, toolbarEnabled ? { size: 15 } : void 0)
        ],
        growth: LayoutGrowth.PREFERRED
      };
      topLevelLayoutComponents.push(titleSpacerComponent);
    }
    topLevelLayoutComponents.push(fullFrameComponent);
    return [
      new Tooltip(this.model, this.services),
      new Modal(this.model, this.services),
      new LayoutComponent(this.model, this.services, topLevelLayoutComponents, {
        direction: LayoutDirection.COLUMN
      })
    ];
  };
  return Chart2;
}();
var __extends$D = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays$e = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var ChartModelCartesian = function(_super) {
  __extends$D(ChartModelCartesian2, _super);
  function ChartModelCartesian2(services) {
    var _this = _super.call(this, services) || this;
    _this.axisFlavor = AxisFlavor.DEFAULT;
    return _this;
  }
  ChartModelCartesian2.prototype.assignRangeAndDomains = function() {
    var cartesianScales = this.services.cartesianScales;
    var options2 = this.getOptions();
    var isDualAxes = cartesianScales.isDualAxes();
    var scales = {
      primaryDomain: cartesianScales.domainAxisPosition,
      primaryRange: cartesianScales.rangeAxisPosition,
      secondaryDomain: null,
      secondaryRange: null
    };
    if (isDualAxes) {
      scales.secondaryDomain = cartesianScales.secondaryDomainAxisPosition;
      scales.secondaryRange = cartesianScales.secondaryRangeAxisPosition;
    }
    Object.keys(scales).forEach(function(scale) {
      var position = scales[scale];
      if (cartesianScales.scales[position]) {
        scales[scale] = {
          position,
          label: cartesianScales.getScaleLabel(position),
          identifier: Tools.getProperty(options2, "axes", position, "mapsTo")
        };
      } else {
        scales[scale] = null;
      }
    });
    return scales;
  };
  ChartModelCartesian2.prototype.getTabularDataArray = function() {
    var displayData = this.getDisplayData();
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var cartesianScales = this.services.cartesianScales;
    var _a2 = this.assignRangeAndDomains(), primaryDomain = _a2.primaryDomain, primaryRange = _a2.primaryRange, secondaryDomain = _a2.secondaryDomain, secondaryRange = _a2.secondaryRange;
    var domainScaleType = cartesianScales.getDomainAxisScaleType();
    var domainValueFormatter;
    if (domainScaleType === ScaleTypes.TIME) {
      domainValueFormatter = function(d) {
        return format(d, "MMM d, yyyy");
      };
    }
    var result = __spreadArrays$e([
      __spreadArrays$e([
        "Group",
        primaryDomain.label,
        primaryRange.label
      ], secondaryDomain ? [secondaryDomain.label] : [], secondaryRange ? [secondaryRange.label] : [])
    ], displayData.map(function(datum2) {
      return __spreadArrays$e([
        datum2[groupMapsTo],
        datum2[primaryDomain.identifier] === null ? "&ndash;" : domainValueFormatter ? domainValueFormatter(datum2[primaryDomain.identifier]) : datum2[primaryDomain.identifier],
        datum2[primaryRange.identifier] === null || isNaN(datum2[primaryRange.identifier]) ? "&ndash;" : datum2[primaryRange.identifier].toLocaleString()
      ], secondaryDomain ? [
        datum2[secondaryDomain.identifier] === null ? "&ndash;" : datum2[secondaryDomain.identifier]
      ] : [], secondaryRange ? [
        datum2[secondaryRange.identifier] === null || isNaN(datum2[secondaryRange.identifier]) ? "&ndash;" : datum2[secondaryRange.identifier]
      ] : []);
    }));
    return result;
  };
  ChartModelCartesian2.prototype.setData = function(newData) {
    var data;
    if (newData) {
      data = _super.prototype.setData.call(this, newData);
      if (Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "enabled")) {
        var definedZoomBarData = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "data");
        this.setZoomBarData(definedZoomBarData);
      }
    }
    return data;
  };
  ChartModelCartesian2.prototype.setZoomBarData = function(newZoomBarData) {
    var sanitizedData = newZoomBarData ? this.sanitize(Tools.clone(newZoomBarData)) : this.getDisplayData();
    var zoomBarNormalizedValues = sanitizedData;
    var cartesianScales = this.services.cartesianScales;
    if (sanitizedData && cartesianScales.domainAxisPosition && cartesianScales.rangeAxisPosition) {
      var domainIdentifier_1 = cartesianScales.getDomainIdentifier();
      var rangeIdentifier_1 = cartesianScales.getRangeIdentifier();
      var allDates = sanitizedData.map(function(datum2) {
        return datum2[domainIdentifier_1].getTime();
      });
      allDates = Tools.removeArrayDuplicates(allDates).sort();
      zoomBarNormalizedValues = allDates.map(function(date2) {
        var sum2 = 0;
        var datum2 = {};
        sanitizedData.forEach(function(data) {
          if (data[domainIdentifier_1].getTime() === date2) {
            sum2 += data[rangeIdentifier_1];
          }
        });
        datum2[domainIdentifier_1] = new Date(date2);
        datum2[rangeIdentifier_1] = sum2;
        return datum2;
      });
    }
    this.set({ zoomBarData: zoomBarNormalizedValues });
  };
  ChartModelCartesian2.prototype.getZoomBarData = function() {
    return this.get("zoomBarData");
  };
  ChartModelCartesian2.prototype.sanitizeDateValues = function(data) {
    var options2 = this.getOptions();
    if (!options2.axes) {
      return data;
    }
    var keysToCheck = [];
    Object.keys(AxisPositions).forEach(function(axisPositionKey) {
      var axisPosition = AxisPositions[axisPositionKey];
      var axisOptions = options2.axes[axisPosition];
      if (axisOptions && axisOptions.scaleType === ScaleTypes.TIME) {
        var axisMapsTo = axisOptions.mapsTo;
        if (axisMapsTo !== null || axisMapsTo !== void 0) {
          keysToCheck.push(axisMapsTo);
        }
      }
    });
    if (keysToCheck.length > 0) {
      data.forEach(function(datum2) {
        keysToCheck.forEach(function(key) {
          if (Tools.getProperty(datum2, key, "getTime") === null) {
            datum2[key] = new Date(datum2[key]);
          }
        });
      });
    }
    return data;
  };
  ChartModelCartesian2.prototype.sanitize = function(data) {
    data = _super.prototype.sanitize.call(this, data);
    data = this.sanitizeDateValues(data);
    return data;
  };
  return ChartModelCartesian2;
}(ChartModel);
var __extends$C = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays$d = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var AxisChart = function(_super) {
  __extends$C(AxisChart2, _super);
  function AxisChart2(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.services = Object.assign(_this.services, {
      cartesianScales: CartesianScales,
      curves: Curves,
      zoom: Zoom
    });
    _this.model = new ChartModelCartesian(_this.services);
    return _this;
  }
  AxisChart2.prototype.getAxisChartComponents = function(graphFrameComponents, configs) {
    var options2 = this.model.getOptions();
    var isZoomBarEnabled = Tools.getProperty(options2, "zoomBar", AxisPositions.TOP, "enabled");
    var toolbarEnabled = Tools.getProperty(options2, "toolbar", "enabled");
    this.services.cartesianScales.determineAxisDuality();
    this.services.cartesianScales.findDomainAndRangeAxes();
    this.services.cartesianScales.determineOrientation();
    var mainXAxisPosition = this.services.cartesianScales.getMainXAxisPosition();
    var mainXScaleType = Tools.getProperty(options2, "axes", mainXAxisPosition, "scaleType");
    var zoomBarEnabled = isZoomBarEnabled && mainXAxisPosition === AxisPositions.BOTTOM && mainXScaleType === ScaleTypes.TIME;
    var isZoomBarLocked = this.services.zoom.isZoomBarLocked(AxisPositions.TOP);
    var titleAvailable = !!this.model.getOptions().title;
    var titleComponent = {
      id: "title",
      components: [new Title(this.model, this.services)],
      growth: LayoutGrowth.STRETCH
    };
    var toolbarComponent = {
      id: "toolbar",
      components: [new Toolbar(this.model, this.services)],
      growth: LayoutGrowth.PREFERRED
    };
    var headerComponent = {
      id: "header",
      components: [
        new LayoutComponent(this.model, this.services, __spreadArrays$d([
          titleComponent
        ], toolbarEnabled ? [toolbarComponent] : []), {
          direction: LayoutDirection.ROW,
          alignItems: LayoutAlignItems.CENTER
        })
      ],
      growth: LayoutGrowth.PREFERRED
    };
    var legendComponent = {
      id: "legend",
      components: [new Legend(this.model, this.services)],
      growth: LayoutGrowth.PREFERRED
    };
    if (zoomBarEnabled && !isZoomBarLocked) {
      graphFrameComponents.push(new ChartClip(this.model, this.services), new ChartBrush(this.model, this.services));
    }
    graphFrameComponents.push(new Threshold(this.model, this.services));
    graphFrameComponents.push(new Highlight(this.model, this.services));
    var graphFrameComponent = {
      id: "graph-frame",
      components: graphFrameComponents,
      growth: LayoutGrowth.STRETCH,
      renderType: RenderTypes.SVG
    };
    var isLegendEnabled = Tools.getProperty(configs, "legend", "enabled") !== false && this.model.getOptions().legend.enabled !== false;
    var fullFrameComponentDirection = LayoutDirection.COLUMN;
    if (isLegendEnabled) {
      var legendPosition = Tools.getProperty(this.model.getOptions(), "legend", "position");
      if (legendPosition === LegendPositions.LEFT) {
        fullFrameComponentDirection = LayoutDirection.ROW;
        if (!this.model.getOptions().legend.orientation) {
          this.model.getOptions().legend.orientation = LegendOrientations.VERTICAL;
        }
      } else if (legendPosition === LegendPositions.RIGHT) {
        fullFrameComponentDirection = LayoutDirection.ROW_REVERSE;
        if (!this.model.getOptions().legend.orientation) {
          this.model.getOptions().legend.orientation = LegendOrientations.VERTICAL;
        }
      } else if (legendPosition === LegendPositions.BOTTOM) {
        fullFrameComponentDirection = LayoutDirection.COLUMN_REVERSE;
      }
    }
    var legendSpacerComponent = {
      id: "spacer",
      components: [new Spacer(this.model, this.services)],
      growth: LayoutGrowth.PREFERRED
    };
    var fullFrameComponent = {
      id: "full-frame",
      components: [
        new LayoutComponent(this.model, this.services, __spreadArrays$d(isLegendEnabled ? [legendComponent] : [], isLegendEnabled ? [legendSpacerComponent] : [], [
          graphFrameComponent
        ]), {
          direction: fullFrameComponentDirection
        })
      ],
      growth: LayoutGrowth.STRETCH
    };
    var zoomBarComponent = {
      id: "zoom-bar",
      components: [new ZoomBar(this.model, this.services)],
      growth: LayoutGrowth.PREFERRED,
      renderType: RenderTypes.SVG
    };
    var topLevelLayoutComponents = [];
    if (titleAvailable || toolbarEnabled) {
      topLevelLayoutComponents.push(headerComponent);
      var titleSpacerComponent = {
        id: "spacer",
        components: [
          new Spacer(this.model, this.services, toolbarEnabled ? { size: 15 } : void 0)
        ],
        growth: LayoutGrowth.PREFERRED
      };
      topLevelLayoutComponents.push(titleSpacerComponent);
    }
    if (zoomBarEnabled) {
      topLevelLayoutComponents.push(zoomBarComponent);
    }
    topLevelLayoutComponents.push(fullFrameComponent);
    return [
      new AxisChartsTooltip(this.model, this.services),
      new Modal(this.model, this.services),
      new LayoutComponent(this.model, this.services, topLevelLayoutComponents, {
        direction: LayoutDirection.COLUMN
      })
    ];
  };
  return AxisChart2;
}(Chart);
var __extends$B = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$B(AreaChart, _super);
  function AreaChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model.setOptions(Tools.mergeDefaultChartOptions(Tools.clone(options.areaChart), chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  AreaChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new TwoDimensionalAxes(this.model, this.services),
      new Grid(this.model, this.services),
      new Ruler(this.model, this.services),
      new Line(this.model, this.services),
      new Area(this.model, this.services),
      new Scatter(this.model, this.services, {
        fadeInOnChartHolderMouseover: true,
        handleThresholds: true
      }),
      new Skeleton(this.model, this.services, {
        skeleton: Skeletons.GRID
      })
    ];
    var components = this.getAxisChartComponents(graphFrameComponents);
    return components;
  };
  return AreaChart;
})(AxisChart);
var __extends$A = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$A(StackedAreaChart, _super);
  function StackedAreaChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.stackedAreaChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  StackedAreaChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new TwoDimensionalAxes(this.model, this.services),
      new Grid(this.model, this.services),
      new StackedRuler(this.model, this.services),
      new StackedArea(this.model, this.services),
      new Line(this.model, this.services, { stacked: true }),
      new StackedScatter(this.model, this.services, {
        fadeInOnChartHolderMouseover: true,
        handleThresholds: true,
        stacked: true
      }),
      new Skeleton(this.model, this.services, {
        skeleton: Skeletons.GRID
      })
    ];
    var components = this.getAxisChartComponents(graphFrameComponents);
    return components;
  };
  return StackedAreaChart;
})(AxisChart);
var __extends$z = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$z(SimpleBarChart, _super);
  function SimpleBarChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.simpleBarChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  SimpleBarChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new TwoDimensionalAxes(this.model, this.services),
      new Grid(this.model, this.services),
      new SimpleBar(this.model, this.services),
      new ZeroLine(this.model, this.services),
      new Skeleton(this.model, this.services, {
        skeleton: Skeletons.VERT_OR_HORIZ
      })
    ];
    var components = this.getAxisChartComponents(graphFrameComponents);
    return components;
  };
  return SimpleBarChart;
})(AxisChart);
var __extends$y = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$y(GroupedBarChart, _super);
  function GroupedBarChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.groupedBarChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  GroupedBarChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new TwoDimensionalAxes(this.model, this.services),
      new Grid(this.model, this.services),
      new GroupedBar(this.model, this.services),
      new ZeroLine(this.model, this.services),
      new Skeleton(this.model, this.services, {
        skeleton: Skeletons.VERT_OR_HORIZ
      })
    ];
    var components = this.getAxisChartComponents(graphFrameComponents);
    return components;
  };
  return GroupedBarChart;
})(AxisChart);
var __extends$x = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$x(StackedBarChart, _super);
  function StackedBarChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.stackedBarChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  StackedBarChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new TwoDimensionalAxes(this.model, this.services),
      new Grid(this.model, this.services),
      new StackedRuler(this.model, this.services),
      new StackedBar(this.model, this.services),
      new Skeleton(this.model, this.services, {
        skeleton: Skeletons.VERT_OR_HORIZ
      }),
      new ZeroLine(this.model, this.services)
    ];
    var components = this.getAxisChartComponents(graphFrameComponents);
    return components;
  };
  return StackedBarChart;
})(AxisChart);
var __extends$w = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays$c = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var BoxplotChartModel = function(_super) {
  __extends$w(BoxplotChartModel2, _super);
  function BoxplotChartModel2(services) {
    return _super.call(this, services) || this;
  }
  BoxplotChartModel2.prototype.getBoxQuartiles = function(d) {
    return {
      q_25: quantile(d, 0.25),
      q_50: quantile(d, 0.5),
      q_75: quantile(d, 0.75)
    };
  };
  BoxplotChartModel2.prototype.getBoxplotData = function() {
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var groupedData = this.getGroupedData();
    var boxplotData = [];
    var _loop_1 = function(group2, data2) {
      var _a3;
      var rangeIdentifier = this_1.services.cartesianScales.getRangeIdentifier();
      var values = data2.map(function(d) {
        return d[rangeIdentifier];
      }).sort(ascending);
      var record = (_a3 = {}, _a3[groupMapsTo] = group2, _a3.counts = values, _a3.quartiles = this_1.getBoxQuartiles(values), _a3.outliers = null, _a3.whiskers = null, _a3);
      var q1 = record.quartiles.q_25;
      var q3 = record.quartiles.q_75;
      var iqr = (q3 - q1) * 1.5;
      var irq1 = q1 - iqr;
      var irq3 = q3 + iqr;
      var outliers = [];
      var normalValues = [];
      for (var _i2 = 0, values_1 = values; _i2 < values_1.length; _i2++) {
        var value2 = values_1[_i2];
        if (value2 < irq1) {
          outliers.push(value2);
        } else if (value2 > irq3) {
          outliers.push(value2);
        } else {
          normalValues.push(value2);
        }
      }
      record.outliers = outliers;
      var minNormalValue = min$3(normalValues);
      var maxNormalValue = max$3(normalValues);
      record.whiskers = {
        min: minNormalValue ? minNormalValue : min$3([
          record.quartiles.q_25,
          record.quartiles.q_50,
          record.quartiles.q_75
        ]),
        max: maxNormalValue ? maxNormalValue : max$3([
          record.quartiles.q_25,
          record.quartiles.q_50,
          record.quartiles.q_75
        ])
      };
      boxplotData.push(record);
    };
    var this_1 = this;
    for (var _i = 0, groupedData_1 = groupedData; _i < groupedData_1.length; _i++) {
      var _a2 = groupedData_1[_i], group = _a2.name, data = _a2.data;
      _loop_1(group, data);
    }
    return boxplotData;
  };
  BoxplotChartModel2.prototype.getTabularDataArray = function() {
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var boxplotData = this.getBoxplotData();
    var result = __spreadArrays$c([
      [
        "Group",
        "Minimum",
        "Q1",
        "Median",
        "Q3",
        "Maximum",
        "IQR",
        "Outlier(s)"
      ]
    ], boxplotData.map(function(datum2) {
      var outliers = Tools.getProperty(datum2, "outliers");
      if (outliers === null || outliers.length === 0) {
        outliers = ["&ndash;"];
      }
      return [
        datum2[groupMapsTo],
        Tools.getProperty(datum2, "whiskers", "min") !== null ? Tools.getProperty(datum2, "whiskers", "min").toLocaleString() : "&ndash;",
        Tools.getProperty(datum2, "quartiles", "q_25") !== null ? Tools.getProperty(datum2, "quartiles", "q_25").toLocaleString() : "&ndash;",
        Tools.getProperty(datum2, "quartiles", "q_50") !== null ? Tools.getProperty(datum2, "quartiles", "q_50").toLocaleString() : "&ndash;",
        Tools.getProperty(datum2, "quartiles", "q_75") !== null ? Tools.getProperty(datum2, "quartiles", "q_75").toLocaleString() : "&ndash;",
        Tools.getProperty(datum2, "whiskers", "max") !== null ? Tools.getProperty(datum2, "whiskers", "max").toLocaleString() : "&ndash;",
        Tools.getProperty(datum2, "quartiles", "q_75") !== null && Tools.getProperty(datum2, "quartiles", "q_25") !== null ? (Tools.getProperty(datum2, "quartiles", "q_75") - Tools.getProperty(datum2, "quartiles", "q_25")).toLocaleString() : "&ndash;",
        outliers.map(function(d) {
          return d.toLocaleString();
        }).join(",")
      ];
    }));
    return result;
  };
  BoxplotChartModel2.prototype.setColorClassNames = function() {
    var numberOfColors = 1;
    var colorPairingOptions = Tools.getProperty(this.getOptions(), "color", "pairing");
    var pairingOption = Tools.getProperty(colorPairingOptions, "option");
    var colorPairingCounts = color$1.pairingOptions;
    pairingOption = pairingOption <= colorPairingCounts[numberOfColors + "-color"] ? pairingOption : 1;
    var colorPairing = this.allDataGroups.map(function(dataGroup, index2) {
      return numberOfColors + "-" + pairingOption + "-1";
    });
    this.colorClassNames = ordinal().range(colorPairing).domain(this.allDataGroups);
  };
  return BoxplotChartModel2;
}(ChartModelCartesian);
var __extends$v = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$v(BoxplotChart, _super);
  function BoxplotChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model = new BoxplotChartModel(_this.services);
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.boxplotChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  BoxplotChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new TwoDimensionalAxes(this.model, this.services),
      new Grid(this.model, this.services),
      new Boxplot(this.model, this.services),
      new ZeroLine(this.model, this.services),
      new Skeleton(this.model, this.services, {
        skeleton: Skeletons.VERT_OR_HORIZ
      })
    ];
    var components = this.getAxisChartComponents(graphFrameComponents, {
      legend: {
        enabled: false
      }
    });
    return components;
  };
  return BoxplotChart;
})(AxisChart);
var __extends$u = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$u(BubbleChart, _super);
  function BubbleChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.bubbleChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  BubbleChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new TwoDimensionalAxes(this.model, this.services),
      new Grid(this.model, this.services),
      new Ruler(this.model, this.services),
      new Bubble(this.model, this.services),
      new Skeleton(this.model, this.services, {
        skeleton: Skeletons.GRID
      })
    ];
    var components = this.getAxisChartComponents(graphFrameComponents);
    return components;
  };
  return BubbleChart;
})(AxisChart);
var __extends$t = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays$b = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var BulletChartModel = function(_super) {
  __extends$t(BulletChartModel2, _super);
  function BulletChartModel2(services) {
    return _super.call(this, services) || this;
  }
  BulletChartModel2.prototype.getMatchingRangeIndexForDatapoint = function(datum2) {
    var matchingRangeIndex;
    for (var i = datum2.ranges.length - 1; i > 0; i--) {
      var range2 = datum2.ranges[i];
      if (datum2.value >= range2) {
        matchingRangeIndex = i;
        return matchingRangeIndex;
      }
    }
    return 0;
  };
  BulletChartModel2.prototype.getTabularDataArray = function() {
    var _this = this;
    var displayData = this.getDisplayData();
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var rangeIdentifier = this.services.cartesianScales.getRangeIdentifier();
    var performanceAreaTitles = Tools.getProperty(options2, "bullet", "performanceAreaTitles");
    var result = __spreadArrays$b([
      ["Title", "Group", "Value", "Target", "Percentage", "Performance"]
    ], displayData.map(function(datum2) {
      return [
        datum2["title"],
        datum2[groupMapsTo],
        datum2["value"] === null ? "&ndash;" : datum2["value"],
        Tools.getProperty(datum2, "marker") === null ? "&ndash;" : datum2["marker"],
        Tools.getProperty(datum2, "marker") === null ? "&ndash;" : Math.floor(datum2[rangeIdentifier] / datum2.marker * 100) + "%",
        performanceAreaTitles[_this.getMatchingRangeIndexForDatapoint(datum2)]
      ];
    }));
    return result;
  };
  return BulletChartModel2;
}(ChartModelCartesian);
var __extends$s = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$s(BulletChart, _super);
  function BulletChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model = new BulletChartModel(_this.services);
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.bulletChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  BulletChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new TwoDimensionalAxes(this.model, this.services),
      new Grid(this.model, this.services),
      new Bullet(this.model, this.services),
      new Skeleton(this.model, this.services, {
        skeleton: Skeletons.GRID
      })
    ];
    var components = this.getAxisChartComponents(graphFrameComponents);
    return components;
  };
  return BulletChart;
})(AxisChart);
var __extends$r = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays$a = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var ChartModelBinned = function(_super) {
  __extends$r(ChartModelBinned2, _super);
  function ChartModelBinned2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ChartModelBinned2.prototype.getTabularDataArray = function() {
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var binnedStackedData = this.getBinnedStackedData();
    var result = __spreadArrays$a([
      __spreadArrays$a([
        get$3(options2, "bins.rangeLabel") || "Range"
      ], binnedStackedData.map(function(datum2) {
        return get$3(datum2, "0." + groupMapsTo);
      }))
    ], get$3(binnedStackedData, 0).map(function(d, i) {
      return __spreadArrays$a([
        get$3(d, "data.x0") + " \u2013 " + get$3(d, "data.x1")
      ], binnedStackedData.map(function(datum2) {
        return get$3(datum2[i], "data." + get$3(datum2[i], groupMapsTo));
      }));
    }));
    return result;
  };
  return ChartModelBinned2;
}(ChartModelCartesian);
var __extends$q = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$q(HistogramChart, _super);
  function HistogramChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model = new ChartModelBinned(_this.services);
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.histogramChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    _this.update();
    return _this;
  }
  HistogramChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new TwoDimensionalAxes(this.model, this.services),
      new Grid(this.model, this.services),
      new BinnedRuler(this.model, this.services),
      new Histogram(this.model, this.services)
    ];
    var components = this.getAxisChartComponents(graphFrameComponents);
    return components;
  };
  return HistogramChart;
})(AxisChart);
var __extends$p = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$p(LineChart, _super);
  function LineChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.lineChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  LineChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new TwoDimensionalAxes(this.model, this.services),
      new Grid(this.model, this.services),
      new Ruler(this.model, this.services),
      new Line(this.model, this.services),
      new Scatter(this.model, this.services, { handleThresholds: true }),
      new SkeletonLines(this.model, this.services),
      new ZeroLine(this.model, this.services)
    ];
    var components = this.getAxisChartComponents(graphFrameComponents);
    return components;
  };
  return LineChart;
})(AxisChart);
var __extends$o = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$o(LollipopChart, _super);
  function LollipopChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.lollipopChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  LollipopChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new TwoDimensionalAxes(this.model, this.services),
      new Grid(this.model, this.services),
      new Ruler(this.model, this.services),
      new Lollipop(this.model, this.services),
      new Scatter(this.model, this.services),
      new Skeleton(this.model, this.services, {
        skeleton: Skeletons.GRID
      })
    ];
    var components = this.getAxisChartComponents(graphFrameComponents);
    return components;
  };
  return LollipopChart;
})(AxisChart);
var __extends$n = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$n(ScatterChart, _super);
  function ScatterChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.scatterChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  ScatterChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new TwoDimensionalAxes(this.model, this.services),
      new Grid(this.model, this.services),
      new Ruler(this.model, this.services),
      new Scatter(this.model, this.services),
      new Skeleton(this.model, this.services, {
        skeleton: Skeletons.GRID
      })
    ];
    var components = this.getAxisChartComponents(graphFrameComponents);
    return components;
  };
  return ScatterChart;
})(AxisChart);
var __extends$m = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays$9 = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var PieChartModel = function(_super) {
  __extends$m(PieChartModel2, _super);
  function PieChartModel2(services) {
    return _super.call(this, services) || this;
  }
  PieChartModel2.prototype.getTabularData = function(data) {
    var tabularData = _super.prototype.getTabularData.call(this, data);
    if (data !== tabularData) {
      tabularData.forEach(function(d) {
        if (d.key && d.key !== d.group) {
          d.group = d.key;
        }
      });
    }
    return tabularData;
  };
  PieChartModel2.prototype.getTabularDataArray = function() {
    var displayData = this.getDisplayData();
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var result = __spreadArrays$9([
      ["Group", "Value"]
    ], displayData.map(function(datum2) {
      return [
        datum2[groupMapsTo],
        datum2["value"] === null ? "&ndash;" : datum2["value"].toLocaleString()
      ];
    }));
    return result;
  };
  PieChartModel2.prototype.sanitize = function(data) {
    var tabularData = this.getTabularData(data);
    return tabularData.sort(function(a, b) {
      return b.value - a.value;
    });
  };
  return PieChartModel2;
}(ChartModel);
var __extends$l = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PieChart = function(_super) {
  __extends$l(PieChart2, _super);
  function PieChart2(holder, chartConfigs, extending) {
    if (extending === void 0) {
      extending = false;
    }
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model = new PieChartModel(_this.services);
    if (extending) {
      return _this;
    }
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.pieChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  PieChart2.prototype.getComponents = function() {
    var graphFrameComponents = [
      new Pie(this.model, this.services),
      new Skeleton(this.model, this.services, {
        skeleton: Skeletons.PIE
      })
    ];
    var components = this.getChartComponents(graphFrameComponents);
    return components;
  };
  return PieChart2;
}(Chart);
var __extends$k = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$k(DonutChart, _super);
  function DonutChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs, true) || this;
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.donutChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  DonutChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new Donut(this.model, this.services),
      new Skeleton(this.model, this.services, {
        skeleton: Skeletons.DONUT
      })
    ];
    var components = this.getChartComponents(graphFrameComponents);
    return components;
  };
  return DonutChart;
})(PieChart);
var __extends$j = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays$8 = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var MeterChartModel = function(_super) {
  __extends$j(MeterChartModel2, _super);
  function MeterChartModel2(services) {
    return _super.call(this, services) || this;
  }
  MeterChartModel2.prototype.getMaximumDomain = function(data) {
    var max2 = data.reduce(function(accumulator, datum2) {
      return accumulator + datum2.value;
    }, 0);
    return max2;
  };
  MeterChartModel2.prototype.getFillColor = function(group) {
    var options2 = this.getOptions();
    var userProvidedScale = Tools.getProperty(options2, "color", "scale");
    var status = this.getStatus();
    if (userProvidedScale || !status) {
      return _super.prototype.getFillColor.call(this, group);
    } else {
      return null;
    }
  };
  MeterChartModel2.prototype.getStatus = function() {
    var options2 = this.getOptions();
    var dataValues = Tools.getProperty(this.getDisplayData());
    var totalValue = (dataValues ? dataValues.reduce(function(previous, current) {
      return { value: previous.value + current.value };
    }) : 0).value;
    var boundedValue = Tools.getProperty(options2, "meter", "proportional") ? totalValue : totalValue > 100 ? 100 : totalValue;
    var allRanges = Tools.getProperty(options2, "meter", "status", "ranges");
    if (allRanges) {
      var result = allRanges.filter(function(step) {
        return step.range[0] <= boundedValue && boundedValue <= step.range[1];
      });
      if (result.length > 0) {
        return result[0].status;
      }
    }
    return null;
  };
  MeterChartModel2.prototype.getTabularDataArray = function() {
    var displayData = this.getDisplayData();
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var status = this.getStatus();
    var proportional = Tools.getProperty(options2, "meter", "proportional");
    var result = [];
    var domainMax;
    if (proportional === null) {
      domainMax = 100;
      var datum2 = displayData[0];
      result = [
        __spreadArrays$8(["Group", "Value"], status ? ["Status"] : []),
        __spreadArrays$8([
          datum2[groupMapsTo],
          datum2["value"]
        ], status ? [status] : [])
      ];
    } else {
      var total = Tools.getProperty(proportional, "total");
      domainMax = total ? total : this.getMaximumDomain(displayData);
      result = __spreadArrays$8([
        ["Group", "Value", "Percentage of total"]
      ], displayData.map(function(datum3) {
        return [
          datum3[groupMapsTo],
          datum3["value"],
          (datum3["value"] / domainMax * 100).toFixed(2) + " %"
        ];
      }));
    }
    return result;
  };
  return MeterChartModel2;
}(ChartModel);
var __extends$i = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$1 = globalThis && globalThis.__assign || function() {
  __assign$1 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
var Meter = function(_super) {
  __extends$i(Meter2, _super);
  function Meter2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "meter";
    _this.renderType = RenderTypes.SVG;
    return _this;
  }
  Meter2.prototype.getStackedBounds = function(data, scale) {
    var prevX = 0;
    var stackedData = data.map(function(d, i) {
      if (i !== 0) {
        prevX += scale(d.value);
        return __assign$1(__assign$1({}, d), { width: Math.abs(scale(d.value) - meter.dividerWidth), x: prevX - scale(d.value) });
      } else {
        prevX = scale(d.value);
        return __assign$1(__assign$1({}, d), { width: Math.abs(scale(d.value) - meter.dividerWidth), x: 0 });
      }
    });
    return stackedData;
  };
  Meter2.prototype.render = function(animate) {
    var _this = this;
    if (animate === void 0) {
      animate = true;
    }
    var self2 = this;
    var svg = this.getComponentContainer();
    var options2 = this.getOptions();
    var proportional = Tools.getProperty(options2, "meter", "proportional");
    var data = this.model.getDisplayData();
    var status = this.model.getStatus();
    var width = DOMUtils.getSVGElementSize(svg, {
      useAttrs: true
    }).width;
    var groupMapsTo = options2.data.groupMapsTo;
    var domainMax;
    if (Tools.getProperty(options2, "meter", "proportional") === null) {
      domainMax = 100;
    } else {
      var total = Tools.getProperty(options2, "meter", "proportional", "total");
      domainMax = total ? total : this.model.getMaximumDomain(this.model.getDisplayData());
    }
    var xScale = linear().domain([0, domainMax]).range([0, width]);
    var stackedData = this.getStackedBounds(data, xScale);
    var userProvidedHeight = Tools.getProperty(options2, "meter", "height");
    DOMUtils.appendOrSelect(svg, "rect.container").attr("x", 0).attr("y", 0).attr("width", width).attr("height", userProvidedHeight ? userProvidedHeight : proportional ? meter.height.proportional : meter.height.default);
    DOMUtils.appendOrSelect(svg, "line.rangeIndicator").attr("x1", width).attr("x2", width).attr("y1", 0).attr("y2", userProvidedHeight ? userProvidedHeight : proportional ? meter.height.proportional : meter.height.default);
    var valued = svg.selectAll("rect.value").data(stackedData);
    var className = status != null && !self2.model.isUserProvidedColorScaleValid() && !proportional ? "value status--" + status : "value";
    valued.enter().append("rect").classed("value", true).merge(valued).attr("x", function(d) {
      return d.x;
    }).attr("y", 0).attr("height", function() {
      var userProvidedHeight2 = Tools.getProperty(options2, "meter", "height");
      return userProvidedHeight2 ? userProvidedHeight2 : proportional ? meter.height.proportional : meter.height.default;
    }).attr("class", function(d) {
      return _this.model.getColorClassName({
        classNameTypes: [ColorClassNameTypes.FILL],
        dataGroupName: d[groupMapsTo],
        originalClassName: className
      });
    }).transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "meter-bar-update",
        animate
      });
    }).attr("width", function(d, i) {
      return d.value > domainMax ? xScale(domainMax) : d.width;
    }).style("fill", function(d) {
      return self2.model.getFillColor(d[groupMapsTo]);
    }).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", function(d) {
      return d.value;
    });
    valued.exit().remove();
    var peakValue = Tools.getProperty(options2, "meter", "peak");
    var peakData = peakValue;
    if (peakValue !== null) {
      if (peakValue > domainMax) {
        peakData = domainMax;
      } else if (peakValue < data[0].value) {
        peakData = data[0].value > domainMax ? domainMax : data[0].value;
      }
    }
    var peak = svg.selectAll("line.peak").data(peakData == null ? [] : [peakData]);
    peak.enter().append("line").classed("peak", true).merge(peak).attr("y1", 0).attr("y2", function() {
      var userProvidedHeight2 = Tools.getProperty(options2, "meter", "height");
      return userProvidedHeight2 ? userProvidedHeight2 : proportional ? meter.height.proportional : meter.height.default;
    }).transition().call(function(t) {
      return _this.services.transitions.setupTransition({
        transition: t,
        name: "peak-line-update",
        animate
      });
    }).attr("x1", function(d) {
      return xScale(d);
    }).attr("x2", function(d) {
      return xScale(d);
    }).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "peak").attr("aria-label", function(d) {
      return d;
    });
    peak.exit().remove();
    this.services.domUtils.setSVGMaxHeight();
    this.addEventListeners();
  };
  Meter2.prototype.addEventListeners = function() {
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var self2 = this;
    var proportional = Tools.getProperty(options2, "meter", "proportional");
    this.parent.selectAll("rect.value").on("mouseover", function(event, datum2) {
      var hoveredElement = select(this);
      self2.services.events.dispatchEvent(Events$1.Meter.METER_MOUSEOVER, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      if (proportional) {
        hoveredElement.classed("hovered", true);
        self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
          event,
          hoveredElement,
          items: [
            {
              label: datum2[groupMapsTo],
              value: datum2.value
            }
          ]
        });
      }
    }).on("mousemove", function(event, datum2) {
      var hoveredElement = select(this);
      self2.services.events.dispatchEvent(Events$1.Meter.METER_MOUSEMOVE, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      if (proportional) {
        self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
          event
        });
      }
    }).on("click", function(event, datum2) {
      self2.services.events.dispatchEvent(Events$1.Meter.METER_CLICK, {
        event,
        element: select(this),
        datum: datum2
      });
    }).on("mouseout", function(event, datum2) {
      var hoveredElement = select(this);
      self2.services.events.dispatchEvent(Events$1.Meter.METER_MOUSEOUT, {
        event,
        element: hoveredElement,
        datum: datum2
      });
      if (proportional) {
        hoveredElement.classed("hovered", false);
        self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
          hoveredElement
        });
      }
    });
  };
  Meter2.prototype.destroy = function() {
    this.parent.selectAll("rect.value").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
  };
  return Meter2;
}(Component);
var __extends$h = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays$7 = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
(function(_super) {
  __extends$h(MeterChart, _super);
  function MeterChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model = new MeterChartModel(_this.services);
    var options$1 = chartConfigs.options.meter.proportional ? Tools.merge(Tools.clone(options.proportionalMeterChart), chartConfigs.options) : Tools.merge(Tools.clone(options.meterChart), chartConfigs.options);
    _this.model.setOptions(options$1);
    _this.init(holder, chartConfigs);
    return _this;
  }
  MeterChart.prototype.getComponents = function() {
    var showLabels = Tools.getProperty(this.model.getOptions(), "meter", "showLabels");
    var meterComponents = __spreadArrays$7(showLabels ? [
      {
        id: "meter-title",
        components: [
          new MeterTitle(this.model, this.services)
        ],
        growth: LayoutGrowth.STRETCH,
        renderType: RenderTypes.SVG
      },
      {
        id: "spacer",
        components: [
          new Spacer(this.model, this.services, {
            size: 8
          })
        ],
        growth: LayoutGrowth.STRETCH
      }
    ] : [], [
      {
        id: "meter-graph",
        components: [new Meter(this.model, this.services)],
        growth: LayoutGrowth.STRETCH,
        renderType: RenderTypes.SVG
      }
    ]);
    var graphFrame = [
      new LayoutComponent(this.model, this.services, meterComponents, {
        direction: LayoutDirection.COLUMN
      })
    ];
    var components = this.getChartComponents(graphFrame, {
      graphFrameRenderType: RenderTypes.HTML
    });
    return components;
  };
  return MeterChart;
})(Chart);
var __extends$g = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays$6 = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var RadarChartModel = function(_super) {
  __extends$g(RadarChartModel2, _super);
  function RadarChartModel2(services) {
    return _super.call(this, services) || this;
  }
  RadarChartModel2.prototype.getTabularDataArray = function() {
    var options2 = this.getOptions();
    var groupedData = this.getGroupedData();
    var _a2 = Tools.getProperty(options2, "radar", "axes"), angle = _a2.angle, value2 = _a2.value;
    var additionalHeaders = Tools.getProperty(groupedData, "0", "data").map(function(d) {
      return d[angle];
    });
    var result = __spreadArrays$6([
      __spreadArrays$6(["Group"], additionalHeaders)
    ], groupedData.map(function(datum2) {
      return __spreadArrays$6([
        datum2["name"]
      ], additionalHeaders.map(function(additionalHeader, i) {
        return Tools.getProperty(datum2, "data", i, value2) !== null ? Tools.getProperty(datum2, "data", i, value2).toLocaleString() : "&ndash;";
      }));
    }));
    return result;
  };
  return RadarChartModel2;
}(ChartModelCartesian);
var __extends$f = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$f(RadarChart, _super);
  function RadarChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model = new RadarChartModel(_this.services);
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.radarChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  RadarChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new Radar(this.model, this.services)
    ];
    var components = this.getChartComponents(graphFrameComponents);
    return components;
  };
  return RadarChart;
})(Chart);
var __extends$e = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays$5 = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var GaugeChartModel = function(_super) {
  __extends$e(GaugeChartModel2, _super);
  function GaugeChartModel2(services) {
    return _super.call(this, services) || this;
  }
  GaugeChartModel2.prototype.getDataGroups = function() {
    return _super.prototype.getDataGroups.call(this).filter(function(item) {
      return item.name !== "delta";
    });
  };
  GaugeChartModel2.prototype.getTabularDataArray = function() {
    var displayData = this.getDisplayData();
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var result = __spreadArrays$5([
      ["Group", "Value"]
    ], displayData.map(function(datum2) {
      return [
        datum2[groupMapsTo],
        datum2["value"] === null ? "&ndash;" : datum2["value"].toLocaleString()
      ];
    }));
    return result;
  };
  return GaugeChartModel2;
}(ChartModel);
var __extends$d = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$d(GaugeChart, _super);
  function GaugeChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model = new GaugeChartModel(_this.services);
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.gaugeChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  GaugeChart.prototype.getComponents = function() {
    var graphFrameComponents = [new Gauge(this.model, this.services)];
    var components = this.getChartComponents(graphFrameComponents);
    return components;
  };
  return GaugeChart;
})(Chart);
var __extends$c = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays$4 = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var _a;
var graphComponentsMap = (_a = {}, _a[ChartTypes.LINE] = [Line, Scatter], _a[ChartTypes.SCATTER] = [Scatter], _a[ChartTypes.AREA] = [Area, Line, Scatter], _a[ChartTypes.STACKED_AREA] = [
  StackedArea,
  Line,
  StackedScatter,
  StackedRuler
], _a[ChartTypes.SIMPLE_BAR] = [SimpleBar], _a[ChartTypes.GROUPED_BAR] = [GroupedBar, ZeroLine], _a[ChartTypes.STACKED_BAR] = [StackedBar, StackedRuler], _a);
(function(_super) {
  __extends$c(ComboChart, _super);
  function ComboChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    var chartOptions = Tools.mergeDefaultChartOptions(options.comboChart, chartConfigs.options);
    if (!chartConfigs.options.comboChartTypes) {
      console.error("No comboChartTypes defined for the Combo Chart!");
      chartOptions.comboChartTypes = [
        { type: ChartTypes.LINE, correspondingDatasets: [] }
      ];
    }
    _this.model.setOptions(chartOptions);
    _this.init(holder, chartConfigs);
    return _this;
  }
  ComboChart.prototype.getGraphComponents = function() {
    var _this = this;
    var comboChartTypes = this.model.getOptions().comboChartTypes;
    var counter = 0;
    var graphComponents = comboChartTypes.map(function(graph) {
      var type2 = graph.type;
      var options$1;
      if (typeof graph.type === "string") {
        if (!Object.keys(graphComponentsMap).includes(graph.type)) {
          console.error('Invalid chart type "' + graph.type + '" specified for combo chart. Please refer to the ComboChart tutorial for more guidance.');
          return null;
        }
        var stacked_1;
        options$1 = Tools.merge({}, options[Tools.camelCase(graph.type) + "Chart"], _this.model.getOptions(), graph.options);
        if (graph.type === ChartTypes.STACKED_AREA) {
          stacked_1 = true;
        }
        return graphComponentsMap[graph.type].map(function(Component2, i) {
          return new Component2(_this.model, _this.services, {
            groups: graph.correspondingDatasets,
            id: counter++,
            options: options$1,
            stacked: stacked_1
          });
        });
      } else {
        options$1 = Tools.merge({}, _this.model.getOptions(), graph.options);
        return new type2(_this.model, _this.services, {
          groups: graph.correspondingDatasets,
          id: counter++,
          options: options$1
        });
      }
    }).filter(function(item) {
      return item !== null;
    });
    return Tools.flatten(graphComponents);
  };
  ComboChart.prototype.getComponents = function() {
    var comboChartTypes = this.model.getOptions().comboChartTypes;
    var stackedRulerEnabled = comboChartTypes.some(function(chartObject) {
      return chartObject.type === ChartTypes.STACKED_BAR || chartObject.type === ChartTypes.STACKED_AREA;
    });
    var graphFrameComponents = __spreadArrays$4([
      new TwoDimensionalAxes(this.model, this.services),
      new Grid(this.model, this.services),
      new Skeleton(this.model, this.services, {
        skeleton: Skeletons.GRID
      })
    ], stackedRulerEnabled ? [] : [new Ruler(this.model, this.services)], this.getGraphComponents());
    var components = this.getAxisChartComponents(graphFrameComponents);
    return components;
  };
  return ComboChart;
})(AxisChart);
var __extends$b = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TreeChartModel = function(_super) {
  __extends$b(TreeChartModel2, _super);
  function TreeChartModel2(services) {
    return _super.call(this, services) || this;
  }
  TreeChartModel2.prototype.getTabularDataArray = function() {
    var _this = this;
    var displayData = this.getDisplayData();
    var result = [["Child", "Parent"]];
    displayData.forEach(function(datum2) {
      _this.getChildrenDatums(datum2, result);
      result.push([datum2.name, "&ndash;"]);
    });
    return result;
  };
  TreeChartModel2.prototype.getChildrenDatums = function(datum2, result) {
    var _this = this;
    if (result === void 0) {
      result = [];
    }
    if (datum2.children) {
      if (datum2.children.length > 0) {
        datum2.children.forEach(function(child) {
          _this.getChildrenDatums(child, result);
          result.push([child.name, datum2.name]);
        });
      }
    }
  };
  return TreeChartModel2;
}(ChartModel);
var __extends$a = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$a(TreeChart, _super);
  function TreeChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model = new TreeChartModel(_this.services);
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.treeChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  TreeChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new Tree(this.model, this.services)
    ];
    var components = this.getChartComponents(graphFrameComponents, {
      excludeLegend: true
    });
    return components;
  };
  return TreeChart;
})(Chart);
var __extends$9 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TreemapChartModel = function(_super) {
  __extends$9(TreemapChartModel2, _super);
  function TreemapChartModel2(services) {
    return _super.call(this, services) || this;
  }
  TreemapChartModel2.prototype.getTabularDataArray = function() {
    var displayData = this.getDisplayData();
    var result = [["Child", "Group", "Value"]];
    displayData.forEach(function(datum2) {
      if (Array.isArray(datum2.children)) {
        datum2.children.forEach(function(child) {
          result.push([child.name, datum2.name, child.value]);
        });
      } else if (Tools.getProperty(datum2.name) !== null && Tools.getProperty(datum2.value)) {
        result.push(["\u2013", datum2.name, datum2.value]);
      }
    });
    return result;
  };
  return TreemapChartModel2;
}(ChartModel);
var __extends$8 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$8(TreemapChart, _super);
  function TreemapChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model = new TreemapChartModel(_this.services);
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.treemapChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  TreemapChart.prototype.getComponents = function() {
    var graphFrameComponents = [new Treemap(this.model, this.services)];
    var components = this.getChartComponents(graphFrameComponents);
    return components;
  };
  return TreemapChart;
})(Chart);
var __extends$7 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var CirclePackChartModel = function(_super) {
  __extends$7(CirclePackChartModel2, _super);
  function CirclePackChartModel2(services) {
    var _this = _super.call(this, services) || this;
    _this.parentNode = false;
    _this.set({ depth: 2 }, { skipUpdate: true });
    return _this;
  }
  CirclePackChartModel2.prototype.setData = function(newData) {
    _super.prototype.setData.call(this, newData);
    this.setDataGroups();
    if (newData.length === 1) {
      this.parentNode = true;
    }
    this.setZoom();
  };
  CirclePackChartModel2.prototype.setOptions = function(newOptions) {
    var options2 = this.getOptions();
    var zoomOptions = Tools.merge({}, newOptions, this.getZoomOptions(newOptions));
    Tools.updateLegendAdditionalItems(options2, zoomOptions);
    var depth = this.getHierarchyLevel();
    var userProvidedDepth = Tools.getProperty(options2, "circlePack", "hierarchyLevel");
    this.set({
      options: Tools.merge(options2, zoomOptions),
      depth: userProvidedDepth && userProvidedDepth < 4 ? userProvidedDepth : depth
    });
  };
  CirclePackChartModel2.prototype.getZoomOptions = function(options2) {
    if (!this.getDisplayData()) {
      return {};
    }
    var displayData = this.getDisplayData();
    var zoomOptions = options2 ? options2 : this.getOptions();
    var data = displayData.length === 1 && Tools.getProperty(displayData, 0, "children") ? Tools.getProperty(displayData, 0, "children") : displayData;
    var depth = this.getHierarchyLevel();
    data.some(function(datum2) {
      if (datum2.children) {
        if (datum2.children.some(function(item) {
          return item.children;
        })) {
          depth = 3;
          return false;
        }
      }
    });
    if (Tools.getProperty(zoomOptions, "canvasZoom", "enabled") === true && depth > 2) {
      return {
        legend: {
          additionalItems: [
            {
              type: LegendItemType.ZOOM,
              name: "Click to zoom"
            }
          ]
        }
      };
    }
    return null;
  };
  CirclePackChartModel2.prototype.setZoom = function(options2) {
    this.setOptions(this.getZoomOptions(options2));
  };
  CirclePackChartModel2.prototype.updateHierarchyLevel = function(depth) {
    this.set({ depth });
  };
  CirclePackChartModel2.prototype.getHierarchyLevel = function() {
    return this.get("depth");
  };
  CirclePackChartModel2.prototype.hasParentNode = function() {
    return this.parentNode;
  };
  CirclePackChartModel2.prototype.setDataGroups = function() {
    var _this = this;
    var data = this.getData();
    var options2 = this.getOptions();
    var groupMapsTo = options2.data.groupMapsTo;
    var newData = data.map(function(depthOne) {
      var groupName = depthOne[groupMapsTo];
      return _this.setChildrenDataGroup(depthOne, groupName);
    });
    this.set({
      data: newData
    }, { skipUpdate: true });
  };
  CirclePackChartModel2.prototype.setChildrenDataGroup = function(node, name) {
    var _this = this;
    if (node.children) {
      return __assign(__assign({}, node), { dataGroupName: name, children: node.children.map(function(child, i) {
        return _this.setChildrenDataGroup(child, name);
      }) });
    } else {
      return __assign(__assign({}, node), { dataGroupName: name });
    }
  };
  CirclePackChartModel2.prototype.getTabularDataArray = function() {
    var _this = this;
    var displayData = this.getDisplayData();
    var result = [["Child", "Parent", "Value"]];
    displayData.forEach(function(datum2) {
      var value2 = datum2.value ? datum2.value : 0;
      if (datum2.children) {
        value2 += _this.getChildrenDatums(datum2.children, datum2.name, result, 0);
      }
      result.push(["&ndash;", datum2.name, value2]);
    });
    return result;
  };
  CirclePackChartModel2.prototype.getChildrenDatums = function(children2, parent, result, totalSum) {
    var _this = this;
    if (result === void 0) {
      result = [];
    }
    if (totalSum === void 0) {
      totalSum = 0;
    }
    var grandParent = parent;
    children2.forEach(function(child) {
      var parent2 = child.name;
      var sum2 = 0;
      if (child.children) {
        if (child.children.length > 0) {
          if (typeof child.value === "number") {
            totalSum += child.value;
          }
          sum2 += _this.getChildrenDatums(child.children, parent2, result, sum2);
          result.push([parent2, grandParent, sum2]);
          totalSum += sum2;
        }
      } else {
        var value2 = 0;
        if (typeof child.value === "number") {
          value2 = child.value;
          totalSum += child.value;
        }
        result.push([child.name, grandParent, value2]);
      }
    });
    return totalSum;
  };
  return CirclePackChartModel2;
}(ChartModel);
var __extends$6 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$6(CirclePackChart, _super);
  function CirclePackChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model = new CirclePackChartModel(_this.services);
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.circlePackChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  CirclePackChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new CirclePack(this.model, this.services)
    ];
    var components = this.getChartComponents(graphFrameComponents);
    return components;
  };
  return CirclePackChart;
})(Chart);
var __extends$5 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays$3 = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var WordCloudModel = function(_super) {
  __extends$5(WordCloudModel2, _super);
  function WordCloudModel2(services) {
    return _super.call(this, services) || this;
  }
  WordCloudModel2.prototype.getTabularDataArray = function() {
    var displayData = this.getDisplayData();
    var options2 = this.getOptions();
    var _a2 = options2.wordCloud, fontSizeMapsTo = _a2.fontSizeMapsTo, wordMapsTo = _a2.wordMapsTo;
    var groupMapsTo = options2.data.groupMapsTo;
    var result = __spreadArrays$3([
      [options2.tooltip.wordLabel, "Group", options2.tooltip.valueLabel]
    ], displayData.map(function(datum2) {
      return [
        datum2[wordMapsTo],
        datum2[groupMapsTo],
        datum2[fontSizeMapsTo]
      ];
    }));
    return result;
  };
  return WordCloudModel2;
}(ChartModel);
var __extends$4 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$4(WordCloudChart, _super);
  function WordCloudChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model = new WordCloudModel(_this.services);
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.wordCloudChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  WordCloudChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new WordCloud(this.model, this.services),
      new Skeleton(this.model, this.services, {
        skeleton: Skeletons.PIE
      })
    ];
    var components = this.getChartComponents(graphFrameComponents);
    return components;
  };
  return WordCloudChart;
})(Chart);
var __extends$3 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays$2 = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var AlluvialChartModel = function(_super) {
  __extends$3(AlluvialChartModel2, _super);
  function AlluvialChartModel2(services) {
    return _super.call(this, services) || this;
  }
  AlluvialChartModel2.prototype.getTabularDataArray = function() {
    var displayData = this.getDisplayData();
    displayData.sort(function(a, b) {
      return a["source"].localeCompare(b["source"]);
    });
    var result = __spreadArrays$2([
      ["Source", "Target", "Value"]
    ], displayData.map(function(datum2) {
      return [
        datum2["source"],
        datum2["target"],
        datum2["value"]
      ];
    }));
    return result;
  };
  return AlluvialChartModel2;
}(ChartModelCartesian);
var __extends$2 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
(function(_super) {
  __extends$2(AlluvialChart, _super);
  function AlluvialChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model = new AlluvialChartModel(_this.services);
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.alluvialChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  AlluvialChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new Alluvial(this.model, this.services)
    ];
    var components = this.getChartComponents(graphFrameComponents, {
      excludeLegend: true
    });
    return components;
  };
  return AlluvialChart;
})(Chart);
var __extends$1 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays$1 = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var HeatmapModel = function(_super) {
  __extends$1(HeatmapModel2, _super);
  function HeatmapModel2(services) {
    var _this = _super.call(this, services) || this;
    _this.axisFlavor = AxisFlavor.HOVERABLE;
    _this._colorScale = void 0;
    _this._domains = [];
    _this._ranges = [];
    _this._matrix = {};
    var axis2 = Tools.getProperty(_this.getOptions(), "axes");
    if (!!Tools.getProperty(axis2, "left", "scaleType") && Tools.getProperty(axis2, "left", "scaleType") !== ScaleTypes.LABELS || !!Tools.getProperty(axis2, "right", "scaleType") && Tools.getProperty(axis2, "right", "scaleType") !== ScaleTypes.LABELS || !!Tools.getProperty(axis2, "top", "scaleType") && Tools.getProperty(axis2, "top", "scaleType") !== ScaleTypes.LABELS || !!Tools.getProperty(axis2, "bottom", "scaleType") && Tools.getProperty(axis2, "bottom", "scaleType") !== ScaleTypes.LABELS) {
      throw Error("Heatmap only supports label scaletypes.");
    }
    return _this;
  }
  HeatmapModel2.prototype.getValueDomain = function() {
    var data = this.getDisplayData().map(function(element) {
      return element.value;
    });
    var limits = extent(data);
    var domain = [];
    limits.forEach(function(number3, index2) {
      var value2 = Number(number3);
      if (index2 === 0 && value2 >= 0) {
        value2 = 0;
      } else if (value2 % 10 === 0 || value2 === 0)
        ;
      else if (value2 < 0) {
        value2 = Math.floor(value2 / 10) * 10;
      } else {
        value2 = Math.ceil(value2 / 10) * 10;
      }
      domain.push(value2);
    });
    if (domain[0] < 0 && domain[1] > 0) {
      if (Math.abs(domain[0]) > domain[1]) {
        domain[1] = Math.abs(domain[0]);
      } else {
        domain[0] = -domain[1];
      }
    }
    return domain;
  };
  HeatmapModel2.prototype.getFillColor = function(value2) {
    return this._colorScale(value2);
  };
  HeatmapModel2.prototype.getUniqueDomain = function() {
    if (Tools.isEmpty(this._domains)) {
      var displayData = this.getDisplayData();
      var cartesianScales = this.services.cartesianScales;
      var domainIdentifier_1 = cartesianScales.getDomainIdentifier();
      var mainXAxisPosition = cartesianScales.getMainXAxisPosition();
      var customDomain = cartesianScales.getCustomDomainValuesByposition(mainXAxisPosition);
      if (!!customDomain) {
        return customDomain;
      }
      this._domains = Array.from(new Set(displayData.map(function(d) {
        return d[domainIdentifier_1];
      })));
    }
    return this._domains;
  };
  HeatmapModel2.prototype.getUniqueRanges = function() {
    if (Tools.isEmpty(this._ranges)) {
      var displayData = this.getDisplayData();
      var cartesianScales = this.services.cartesianScales;
      var rangeIdentifier_1 = cartesianScales.getRangeIdentifier();
      var mainYAxisPosition = cartesianScales.getMainYAxisPosition();
      var customDomain = cartesianScales.getCustomDomainValuesByposition(mainYAxisPosition);
      if (!!customDomain) {
        return customDomain;
      }
      this._ranges = Array.from(new Set(displayData.map(function(d) {
        return d[rangeIdentifier_1];
      })));
    }
    return this._ranges;
  };
  HeatmapModel2.prototype.getMatrix = function() {
    var _this = this;
    if (Tools.isEmpty(this._matrix)) {
      var uniqueDomain = this.getUniqueDomain();
      var uniqueRange = this.getUniqueRanges();
      var domainIdentifier_2 = this.services.cartesianScales.getDomainIdentifier();
      var rangeIdentifier_2 = this.services.cartesianScales.getRangeIdentifier();
      var range_1 = {};
      uniqueRange.forEach(function(ran) {
        range_1[ran] = {
          value: null,
          index: -1
        };
      });
      uniqueDomain.forEach(function(dom) {
        _this._matrix[dom] = Tools.clone(range_1);
      });
      this.getDisplayData().forEach(function(d, i) {
        _this._matrix[d[domainIdentifier_2]][d[rangeIdentifier_2]] = {
          value: d["value"],
          index: i
        };
      });
    }
    return this._matrix;
  };
  HeatmapModel2.prototype.setData = function(newData) {
    var sanitizedData = this.sanitize(Tools.clone(newData));
    var dataGroups = this.generateDataGroups(sanitizedData);
    this.set({
      data: sanitizedData,
      dataGroups
    });
    this._domains = [];
    this._ranges = [];
    this._matrix = {};
    return sanitizedData;
  };
  HeatmapModel2.prototype.getMatrixAsArray = function() {
    var _this = this;
    if (Tools.isEmpty(this._matrix)) {
      this.getMatrix();
    }
    var uniqueDomain = this.getUniqueDomain();
    var uniqueRange = this.getUniqueRanges();
    var domainIdentifier = this.services.cartesianScales.getDomainIdentifier();
    var rangeIdentifier = this.services.cartesianScales.getRangeIdentifier();
    var arr = [];
    uniqueDomain.forEach(function(domain) {
      uniqueRange.forEach(function(range2) {
        var element = {
          value: _this._matrix[domain][range2].value,
          index: _this._matrix[domain][range2].index
        };
        element[domainIdentifier] = domain;
        element[rangeIdentifier] = range2;
        arr.push(element);
      });
    });
    return arr;
  };
  HeatmapModel2.prototype.getTabularDataArray = function() {
    var displayData = this.getDisplayData();
    var _a2 = this.assignRangeAndDomains(), primaryDomain = _a2.primaryDomain, primaryRange = _a2.primaryRange;
    _a2.secondaryDomain;
    _a2.secondaryRange;
    var result = __spreadArrays$1([
      [primaryDomain.label, primaryRange.label, "Value"]
    ], displayData.map(function(datum2) {
      return [
        datum2[primaryDomain.identifier] === null ? "&ndash;" : datum2[primaryDomain.identifier],
        datum2[primaryRange.identifier] === null ? "&ndash;" : datum2[primaryRange.identifier].toLocaleString(),
        datum2["value"]
      ];
    }));
    return result;
  };
  HeatmapModel2.prototype.getColorClassName = function(configs) {
    return configs.originalClassName + " " + this._colorScale(configs.value);
  };
  HeatmapModel2.prototype.setColorClassNames = function() {
    var options2 = this.getOptions();
    var customColors = Tools.getProperty(options2, "color", "gradient", "colors");
    var customColorsEnabled = !Tools.isEmpty(customColors);
    var colorPairingOption = Tools.getProperty(options2, "color", "pairing", "option");
    var domain = this.getValueDomain();
    var colorScheme = domain[0] < 0 && domain[1] > 0 ? "diverge" : "mono";
    if (colorPairingOption < 1 && colorPairingOption > 4 && colorScheme === "mono") {
      colorPairingOption = 1;
    } else if (colorPairingOption < 1 && colorPairingOption > 2 && colorScheme === "diverge") {
      colorPairingOption = 1;
    }
    var colorPairing = customColorsEnabled ? customColors : [];
    if (!customColorsEnabled) {
      var colorGroupingLength = colorScheme === "diverge" ? 17 : 11;
      for (var i = 1; i < colorGroupingLength + 1; i++) {
        colorPairing.push("fill-" + colorScheme + "-" + colorPairingOption + "-" + i);
      }
    }
    this._colorScale = quantize().domain(this.getValueDomain()).range(colorPairing);
  };
  return HeatmapModel2;
}(ChartModelCartesian);
var __extends = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __spreadArrays = globalThis && globalThis.__spreadArrays || function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
(function(_super) {
  __extends(HeatmapChart, _super);
  function HeatmapChart(holder, chartConfigs) {
    var _this = _super.call(this, holder, chartConfigs) || this;
    _this.model = new HeatmapModel(_this.services);
    _this.model.setOptions(Tools.mergeDefaultChartOptions(options.heatmapChart, chartConfigs.options));
    _this.init(holder, chartConfigs);
    return _this;
  }
  HeatmapChart.prototype.getAxisChartComponents = function(graphFrameComponents, configs) {
    var options2 = this.model.getOptions();
    var toolbarEnabled = Tools.getProperty(options2, "toolbar", "enabled");
    this.services.cartesianScales.determineAxisDuality();
    this.services.cartesianScales.findDomainAndRangeAxes();
    this.services.cartesianScales.determineOrientation();
    var titleAvailable = !!this.model.getOptions().title;
    var titleComponent = {
      id: "title",
      components: [new Title(this.model, this.services)],
      growth: LayoutGrowth.STRETCH
    };
    var toolbarComponent = {
      id: "toolbar",
      components: [new Toolbar(this.model, this.services)],
      growth: LayoutGrowth.PREFERRED
    };
    var headerComponent = {
      id: "header",
      components: [
        new LayoutComponent(this.model, this.services, __spreadArrays([
          titleComponent
        ], toolbarEnabled ? [toolbarComponent] : []), {
          direction: LayoutDirection.ROW,
          alignItems: LayoutAlignItems.CENTER
        })
      ],
      growth: LayoutGrowth.PREFERRED
    };
    var legendComponent = {
      id: "legend",
      components: [new ColorScaleLegend(this.model, this.services)],
      growth: LayoutGrowth.PREFERRED,
      renderType: RenderTypes.SVG
    };
    var graphFrameComponent = {
      id: "graph-frame",
      components: graphFrameComponents,
      growth: LayoutGrowth.STRETCH,
      renderType: RenderTypes.SVG
    };
    var isLegendEnabled = Tools.getProperty(configs, "legend", "enabled") !== false && this.model.getOptions().legend.enabled !== false;
    var fullFrameComponentDirection = LayoutDirection.COLUMN_REVERSE;
    var legendSpacerComponent = {
      id: "spacer",
      components: [new Spacer(this.model, this.services, { size: 15 })],
      growth: LayoutGrowth.PREFERRED
    };
    var fullFrameComponent = {
      id: "full-frame",
      components: [
        new LayoutComponent(this.model, this.services, __spreadArrays(isLegendEnabled ? [legendComponent] : [], isLegendEnabled ? [legendSpacerComponent] : [], [
          graphFrameComponent
        ]), {
          direction: fullFrameComponentDirection
        })
      ],
      growth: LayoutGrowth.STRETCH
    };
    var topLevelLayoutComponents = [];
    if (titleAvailable || toolbarEnabled) {
      topLevelLayoutComponents.push(headerComponent);
      var titleSpacerComponent = {
        id: "spacer",
        components: [
          new Spacer(this.model, this.services, toolbarEnabled ? { size: 15 } : void 0)
        ],
        growth: LayoutGrowth.PREFERRED
      };
      topLevelLayoutComponents.push(titleSpacerComponent);
    }
    topLevelLayoutComponents.push(fullFrameComponent);
    return [
      new AxisChartsTooltip(this.model, this.services),
      new Modal(this.model, this.services),
      new LayoutComponent(this.model, this.services, topLevelLayoutComponents, {
        direction: LayoutDirection.COLUMN
      })
    ];
  };
  HeatmapChart.prototype.getComponents = function() {
    var graphFrameComponents = [
      new TwoDimensionalAxes(this.model, this.services),
      new Heatmap(this.model, this.services)
    ];
    var components = this.getAxisChartComponents(graphFrameComponents);
    return components;
  };
  return HeatmapChart;
})(AxisChart);
export { Accordion as A, AccordionItem as a };
